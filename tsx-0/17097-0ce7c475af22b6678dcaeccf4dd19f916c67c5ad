{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const hlo=require(\"./high-level-opt.js\");const Pack=require(\"./pack.js\");const fs=require(\"fs\");const fsm=require(\"fs-minipass\");const t=require(\"./list.js\");const path=require(\"path\");const Header=require(\"./header.js\");module.exports=(opt_,files,cb)=>{const opt=hlo(opt_);if(!opt.file){throw new TypeError(\"file is required\")}if(opt.gzip||opt.brotli||opt.file.endsWith(\".br\")||opt.file.endsWith(\".tbr\")){throw new TypeError(\"cannot append to compressed archives\")}if(!files||!Array.isArray(files)||!files.length){throw new TypeError(\"no files or directories specified\")}files=Array.from(files);return opt.sync?replaceSync(opt,files):replace(opt,files,cb)};const replaceSync=__name((opt,files)=>{const p=new Pack.Sync(opt);let threw=true;let fd;let position;try{try{fd=fs.openSync(opt.file,\"r+\")}catch(er){if(er.code===\"ENOENT\"){fd=fs.openSync(opt.file,\"w+\")}else{throw er}}const st=fs.fstatSync(fd);const headBuf=Buffer.alloc(512);POSITION:for(position=0;position<st.size;position+=512){for(let bufPos=0,bytes=0;bufPos<512;bufPos+=bytes){bytes=fs.readSync(fd,headBuf,bufPos,headBuf.length-bufPos,position+bufPos);if(position===0&&headBuf[0]===31&&headBuf[1]===139){throw new Error(\"cannot append to compressed archives\")}if(!bytes){break POSITION}}const h=new Header(headBuf);if(!h.cksumValid){break}const entryBlockSize=512*Math.ceil(h.size/512);if(position+entryBlockSize+512>st.size){break}position+=entryBlockSize;if(opt.mtimeCache){opt.mtimeCache.set(h.path,h.mtime)}}threw=false;streamSync(opt,p,position,fd,files)}finally{if(threw){try{fs.closeSync(fd)}catch(er){}}}},\"replaceSync\");const streamSync=__name((opt,p,position,fd,files)=>{const stream=new fsm.WriteStreamSync(opt.file,{fd,start:position});p.pipe(stream);addFilesSync(p,files)},\"streamSync\");const replace=__name((opt,files,cb)=>{files=Array.from(files);const p=new Pack(opt);const getPos=__name((fd,size,cb_)=>{const cb2=__name((er,pos)=>{if(er){fs.close(fd,_=>cb_(er))}else{cb_(null,pos)}},\"cb\");let position=0;if(size===0){return cb2(null,0)}let bufPos=0;const headBuf=Buffer.alloc(512);const onread=__name((er,bytes)=>{if(er){return cb2(er)}bufPos+=bytes;if(bufPos<512&&bytes){return fs.read(fd,headBuf,bufPos,headBuf.length-bufPos,position+bufPos,onread)}if(position===0&&headBuf[0]===31&&headBuf[1]===139){return cb2(new Error(\"cannot append to compressed archives\"))}if(bufPos<512){return cb2(null,position)}const h=new Header(headBuf);if(!h.cksumValid){return cb2(null,position)}const entryBlockSize=512*Math.ceil(h.size/512);if(position+entryBlockSize+512>size){return cb2(null,position)}position+=entryBlockSize+512;if(position>=size){return cb2(null,position)}if(opt.mtimeCache){opt.mtimeCache.set(h.path,h.mtime)}bufPos=0;fs.read(fd,headBuf,0,512,position,onread)},\"onread\");fs.read(fd,headBuf,0,512,position,onread)},\"getPos\");const promise=new Promise((resolve,reject)=>{p.on(\"error\",reject);let flag=\"r+\";const onopen=__name((er,fd)=>{if(er&&er.code===\"ENOENT\"&&flag===\"r+\"){flag=\"w+\";return fs.open(opt.file,flag,onopen)}if(er){return reject(er)}fs.fstat(fd,(er2,st)=>{if(er2){return fs.close(fd,()=>reject(er2))}getPos(fd,st.size,(er3,position)=>{if(er3){return reject(er3)}const stream=new fsm.WriteStream(opt.file,{fd,start:position});p.pipe(stream);stream.on(\"error\",reject);stream.on(\"close\",resolve);addFilesAsync(p,files)})})},\"onopen\");fs.open(opt.file,flag,onopen)});return cb?promise.then(cb,cb):promise},\"replace\");const addFilesSync=__name((p,files)=>{files.forEach(file=>{if(file.charAt(0)===\"@\"){t({file:path.resolve(p.cwd,file.slice(1)),sync:true,noResume:true,onentry:entry=>p.add(entry)})}else{p.add(file)}});p.end()},\"addFilesSync\");const addFilesAsync=__name((p,files)=>{while(files.length){const file=files.shift();if(file.charAt(0)===\"@\"){return t({file:path.resolve(p.cwd,file.slice(1)),noResume:true,onentry:entry=>p.add(entry)}).then(_=>addFilesAsync(p,files))}else{p.add(file)}}p.end()},\"addFilesAsync\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["cb","er"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/replace.js"],"sourcesContent":["'use strict'\n\n// tar -r\nconst hlo = require('./high-level-opt.js')\nconst Pack = require('./pack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js')\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+')\n      } else {\n        throw er\n      }\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n          throw new Error('cannot append to compressed archives')\n        }\n\n        if (!bytes) {\n          break POSITION\n        }\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        break\n      }\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size) {\n        break\n      }\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) {\n        fs.close(fd, _ => cb_(er))\n      } else {\n        cb_(null, pos)\n      }\n    }\n\n    let position = 0\n    if (size === 0) {\n      return cb(null, 0)\n    }\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er) {\n        return cb(er)\n      }\n      bufPos += bytes\n      if (bufPos < 512 && bytes) {\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n      }\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n        return cb(new Error('cannot append to compressed archives'))\n      }\n\n      // truncated header\n      if (bufPos < 512) {\n        return cb(null, position)\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        return cb(null, position)\n      }\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position)\n      }\n\n      position += entryBlockSize + 512\n      if (position >= size) {\n        return cb(null, position)\n      }\n\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er) {\n        return reject(er)\n      }\n\n      fs.fstat(fd, (er, st) => {\n        if (er) {\n          return fs.close(fd, () => reject(er))\n        }\n\n        getPos(fd, st.size, (er, position) => {\n          if (er) {\n            return reject(er)\n          }\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position,\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n"]}}