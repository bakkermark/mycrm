{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const debug=require(\"debug\")(\"extract-zip\");const{createWriteStream,promises:fs}=require(\"fs\");const getStream=require(\"get-stream\");const path=require(\"path\");const{promisify}=require(\"util\");const stream=require(\"stream\");const yauzl=require(\"yauzl\");const openZip=promisify(yauzl.open);const pipeline=promisify(stream.pipeline);class Extractor{static{__name(this,\"Extractor\")}constructor(zipPath,opts){this.zipPath=zipPath;this.opts=opts}async extract(){debug(\"opening\",this.zipPath,\"with opts\",this.opts);this.zipfile=await openZip(this.zipPath,{lazyEntries:true});this.canceled=false;return new Promise((resolve,reject)=>{this.zipfile.on(\"error\",err=>{this.canceled=true;reject(err)});this.zipfile.readEntry();this.zipfile.on(\"close\",()=>{if(!this.canceled){debug(\"zip extraction complete\");resolve()}});this.zipfile.on(\"entry\",async entry=>{if(this.canceled){debug(\"skipping entry\",entry.fileName,{cancelled:this.canceled});return}debug(\"zipfile entry\",entry.fileName);if(entry.fileName.startsWith(\"__MACOSX/\")){this.zipfile.readEntry();return}const destDir=path.dirname(path.join(this.opts.dir,entry.fileName));try{await fs.mkdir(destDir,{recursive:true});const canonicalDestDir=await fs.realpath(destDir);const relativeDestDir=path.relative(this.opts.dir,canonicalDestDir);if(relativeDestDir.split(path.sep).includes(\"..\")){throw new Error(`Out of bound path \"${canonicalDestDir}\" found while processing file ${entry.fileName}`)}await this.extractEntry(entry);debug(\"finished processing\",entry.fileName);this.zipfile.readEntry()}catch(err){this.canceled=true;this.zipfile.close();reject(err)}})})}async extractEntry(entry){if(this.canceled){debug(\"skipping entry extraction\",entry.fileName,{cancelled:this.canceled});return}if(this.opts.onEntry){this.opts.onEntry(entry,this.zipfile)}const dest=path.join(this.opts.dir,entry.fileName);const mode=entry.externalFileAttributes>>16&65535;const IFMT=61440;const IFDIR=16384;const IFLNK=40960;const symlink=(mode&IFMT)===IFLNK;let isDir=(mode&IFMT)===IFDIR;if(!isDir&&entry.fileName.endsWith(\"/\")){isDir=true}const madeBy=entry.versionMadeBy>>8;if(!isDir)isDir=madeBy===0&&entry.externalFileAttributes===16;debug(\"extracting entry\",{filename:entry.fileName,isDir,isSymlink:symlink});const procMode=this.getExtractedMode(mode,isDir)&511;const destDir=isDir?dest:path.dirname(dest);const mkdirOptions={recursive:true};if(isDir){mkdirOptions.mode=procMode}debug(\"mkdir\",{dir:destDir,...mkdirOptions});await fs.mkdir(destDir,mkdirOptions);if(isDir)return;debug(\"opening read stream\",dest);const readStream=await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);if(symlink){const link=await getStream(readStream);debug(\"creating symlink\",link,dest);await fs.symlink(link,dest)}else{await pipeline(readStream,createWriteStream(dest,{mode:procMode}))}}getExtractedMode(entryMode,isDir){let mode=entryMode;if(mode===0){if(isDir){if(this.opts.defaultDirMode){mode=parseInt(this.opts.defaultDirMode,10)}if(!mode){mode=493}}else{if(this.opts.defaultFileMode){mode=parseInt(this.opts.defaultFileMode,10)}if(!mode){mode=420}}}return mode}}module.exports=async function(zipPath,opts){debug(\"creating target directory\",opts.dir);if(!path.isAbsolute(opts.dir)){throw new Error(\"Target directory is expected to be absolute\")}await fs.mkdir(opts.dir,{recursive:true});opts.dir=await fs.realpath(opts.dir);return new Extractor(zipPath,opts).extract()};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/extract-zip@2.0.1/node_modules/extract-zip/index.js"],"sourcesContent":["const debug = require('debug')('extract-zip')\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst { createWriteStream, promises: fs } = require('fs')\nconst getStream = require('get-stream')\nconst path = require('path')\nconst { promisify } = require('util')\nconst stream = require('stream')\nconst yauzl = require('yauzl')\n\nconst openZip = promisify(yauzl.open)\nconst pipeline = promisify(stream.pipeline)\n\nclass Extractor {\n  constructor (zipPath, opts) {\n    this.zipPath = zipPath\n    this.opts = opts\n  }\n\n  async extract () {\n    debug('opening', this.zipPath, 'with opts', this.opts)\n\n    this.zipfile = await openZip(this.zipPath, { lazyEntries: true })\n    this.canceled = false\n\n    return new Promise((resolve, reject) => {\n      this.zipfile.on('error', err => {\n        this.canceled = true\n        reject(err)\n      })\n      this.zipfile.readEntry()\n\n      this.zipfile.on('close', () => {\n        if (!this.canceled) {\n          debug('zip extraction complete')\n          resolve()\n        }\n      })\n\n      this.zipfile.on('entry', async entry => {\n        /* istanbul ignore if */\n        if (this.canceled) {\n          debug('skipping entry', entry.fileName, { cancelled: this.canceled })\n          return\n        }\n\n        debug('zipfile entry', entry.fileName)\n\n        if (entry.fileName.startsWith('__MACOSX/')) {\n          this.zipfile.readEntry()\n          return\n        }\n\n        const destDir = path.dirname(path.join(this.opts.dir, entry.fileName))\n\n        try {\n          await fs.mkdir(destDir, { recursive: true })\n\n          const canonicalDestDir = await fs.realpath(destDir)\n          const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir)\n\n          if (relativeDestDir.split(path.sep).includes('..')) {\n            throw new Error(`Out of bound path \"${canonicalDestDir}\" found while processing file ${entry.fileName}`)\n          }\n\n          await this.extractEntry(entry)\n          debug('finished processing', entry.fileName)\n          this.zipfile.readEntry()\n        } catch (err) {\n          this.canceled = true\n          this.zipfile.close()\n          reject(err)\n        }\n      })\n    })\n  }\n\n  async extractEntry (entry) {\n    /* istanbul ignore if */\n    if (this.canceled) {\n      debug('skipping entry extraction', entry.fileName, { cancelled: this.canceled })\n      return\n    }\n\n    if (this.opts.onEntry) {\n      this.opts.onEntry(entry, this.zipfile)\n    }\n\n    const dest = path.join(this.opts.dir, entry.fileName)\n\n    // convert external file attr int into a fs stat mode int\n    const mode = (entry.externalFileAttributes >> 16) & 0xFFFF\n    // check if it's a symlink or dir (using stat mode constants)\n    const IFMT = 61440\n    const IFDIR = 16384\n    const IFLNK = 40960\n    const symlink = (mode & IFMT) === IFLNK\n    let isDir = (mode & IFMT) === IFDIR\n\n    // Failsafe, borrowed from jsZip\n    if (!isDir && entry.fileName.endsWith('/')) {\n      isDir = true\n    }\n\n    // check for windows weird way of specifying a directory\n    // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566\n    const madeBy = entry.versionMadeBy >> 8\n    if (!isDir) isDir = (madeBy === 0 && entry.externalFileAttributes === 16)\n\n    debug('extracting entry', { filename: entry.fileName, isDir: isDir, isSymlink: symlink })\n\n    const procMode = this.getExtractedMode(mode, isDir) & 0o777\n\n    // always ensure folders are created\n    const destDir = isDir ? dest : path.dirname(dest)\n\n    const mkdirOptions = { recursive: true }\n    if (isDir) {\n      mkdirOptions.mode = procMode\n    }\n    debug('mkdir', { dir: destDir, ...mkdirOptions })\n    await fs.mkdir(destDir, mkdirOptions)\n    if (isDir) return\n\n    debug('opening read stream', dest)\n    const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry)\n\n    if (symlink) {\n      const link = await getStream(readStream)\n      debug('creating symlink', link, dest)\n      await fs.symlink(link, dest)\n    } else {\n      await pipeline(readStream, createWriteStream(dest, { mode: procMode }))\n    }\n  }\n\n  getExtractedMode (entryMode, isDir) {\n    let mode = entryMode\n    // Set defaults, if necessary\n    if (mode === 0) {\n      if (isDir) {\n        if (this.opts.defaultDirMode) {\n          mode = parseInt(this.opts.defaultDirMode, 10)\n        }\n\n        if (!mode) {\n          mode = 0o755\n        }\n      } else {\n        if (this.opts.defaultFileMode) {\n          mode = parseInt(this.opts.defaultFileMode, 10)\n        }\n\n        if (!mode) {\n          mode = 0o644\n        }\n      }\n    }\n\n    return mode\n  }\n}\n\nmodule.exports = async function (zipPath, opts) {\n  debug('creating target directory', opts.dir)\n\n  if (!path.isAbsolute(opts.dir)) {\n    throw new Error('Target directory is expected to be absolute')\n  }\n\n  await fs.mkdir(opts.dir, { recursive: true })\n  opts.dir = await fs.realpath(opts.dir)\n  return new Extractor(zipPath, opts).extract()\n}\n"]}}