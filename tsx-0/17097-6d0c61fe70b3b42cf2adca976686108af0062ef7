{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const warner=require(\"./warn-mixin.js\");const Header=require(\"./header.js\");const EE=require(\"events\");const Yallist=require(\"yallist\");const maxMetaEntrySize=1024*1024;const Entry=require(\"./read-entry.js\");const Pax=require(\"./pax.js\");const zlib=require(\"minizlib\");const{nextTick}=require(\"process\");const gzipHeader=Buffer.from([31,139]);const STATE=Symbol(\"state\");const WRITEENTRY=Symbol(\"writeEntry\");const READENTRY=Symbol(\"readEntry\");const NEXTENTRY=Symbol(\"nextEntry\");const PROCESSENTRY=Symbol(\"processEntry\");const EX=Symbol(\"extendedHeader\");const GEX=Symbol(\"globalExtendedHeader\");const META=Symbol(\"meta\");const EMITMETA=Symbol(\"emitMeta\");const BUFFER=Symbol(\"buffer\");const QUEUE=Symbol(\"queue\");const ENDED=Symbol(\"ended\");const EMITTEDEND=Symbol(\"emittedEnd\");const EMIT=Symbol(\"emit\");const UNZIP=Symbol(\"unzip\");const CONSUMECHUNK=Symbol(\"consumeChunk\");const CONSUMECHUNKSUB=Symbol(\"consumeChunkSub\");const CONSUMEBODY=Symbol(\"consumeBody\");const CONSUMEMETA=Symbol(\"consumeMeta\");const CONSUMEHEADER=Symbol(\"consumeHeader\");const CONSUMING=Symbol(\"consuming\");const BUFFERCONCAT=Symbol(\"bufferConcat\");const MAYBEEND=Symbol(\"maybeEnd\");const WRITING=Symbol(\"writing\");const ABORTED=Symbol(\"aborted\");const DONE=Symbol(\"onDone\");const SAW_VALID_ENTRY=Symbol(\"sawValidEntry\");const SAW_NULL_BLOCK=Symbol(\"sawNullBlock\");const SAW_EOF=Symbol(\"sawEOF\");const CLOSESTREAM=Symbol(\"closeStream\");const noop=__name(_=>true,\"noop\");module.exports=warner(class Parser extends EE{static{__name(this,\"Parser\")}constructor(opt){opt=opt||{};super(opt);this.file=opt.file||\"\";this[SAW_VALID_ENTRY]=null;this.on(DONE,_=>{if(this[STATE]===\"begin\"||this[SAW_VALID_ENTRY]===false){this.warn(\"TAR_BAD_ARCHIVE\",\"Unrecognized archive format\")}});if(opt.ondone){this.on(DONE,opt.ondone)}else{this.on(DONE,_=>{this.emit(\"prefinish\");this.emit(\"finish\");this.emit(\"end\")})}this.strict=!!opt.strict;this.maxMetaEntrySize=opt.maxMetaEntrySize||maxMetaEntrySize;this.filter=typeof opt.filter===\"function\"?opt.filter:noop;const isTBR=opt.file&&(opt.file.endsWith(\".tar.br\")||opt.file.endsWith(\".tbr\"));this.brotli=!opt.gzip&&opt.brotli!==void 0?opt.brotli:isTBR?void 0:false;this.writable=true;this.readable=false;this[QUEUE]=new Yallist;this[BUFFER]=null;this[READENTRY]=null;this[WRITEENTRY]=null;this[STATE]=\"begin\";this[META]=\"\";this[EX]=null;this[GEX]=null;this[ENDED]=false;this[UNZIP]=null;this[ABORTED]=false;this[SAW_NULL_BLOCK]=false;this[SAW_EOF]=false;this.on(\"end\",()=>this[CLOSESTREAM]());if(typeof opt.onwarn===\"function\"){this.on(\"warn\",opt.onwarn)}if(typeof opt.onentry===\"function\"){this.on(\"entry\",opt.onentry)}}[CONSUMEHEADER](chunk,position){if(this[SAW_VALID_ENTRY]===null){this[SAW_VALID_ENTRY]=false}let header;try{header=new Header(chunk,position,this[EX],this[GEX])}catch(er){return this.warn(\"TAR_ENTRY_INVALID\",er)}if(header.nullBlock){if(this[SAW_NULL_BLOCK]){this[SAW_EOF]=true;if(this[STATE]===\"begin\"){this[STATE]=\"header\"}this[EMIT](\"eof\")}else{this[SAW_NULL_BLOCK]=true;this[EMIT](\"nullBlock\")}}else{this[SAW_NULL_BLOCK]=false;if(!header.cksumValid){this.warn(\"TAR_ENTRY_INVALID\",\"checksum failure\",{header})}else if(!header.path){this.warn(\"TAR_ENTRY_INVALID\",\"path is required\",{header})}else{const type=header.type;if(/^(Symbolic)?Link$/.test(type)&&!header.linkpath){this.warn(\"TAR_ENTRY_INVALID\",\"linkpath required\",{header})}else if(!/^(Symbolic)?Link$/.test(type)&&header.linkpath){this.warn(\"TAR_ENTRY_INVALID\",\"linkpath forbidden\",{header})}else{const entry=this[WRITEENTRY]=new Entry(header,this[EX],this[GEX]);if(!this[SAW_VALID_ENTRY]){if(entry.remain){const onend=__name(()=>{if(!entry.invalid){this[SAW_VALID_ENTRY]=true}},\"onend\");entry.on(\"end\",onend)}else{this[SAW_VALID_ENTRY]=true}}if(entry.meta){if(entry.size>this.maxMetaEntrySize){entry.ignore=true;this[EMIT](\"ignoredEntry\",entry);this[STATE]=\"ignore\";entry.resume()}else if(entry.size>0){this[META]=\"\";entry.on(\"data\",c=>this[META]+=c);this[STATE]=\"meta\"}}else{this[EX]=null;entry.ignore=entry.ignore||!this.filter(entry.path,entry);if(entry.ignore){this[EMIT](\"ignoredEntry\",entry);this[STATE]=entry.remain?\"ignore\":\"header\";entry.resume()}else{if(entry.remain){this[STATE]=\"body\"}else{this[STATE]=\"header\";entry.end()}if(!this[READENTRY]){this[QUEUE].push(entry);this[NEXTENTRY]()}else{this[QUEUE].push(entry)}}}}}}}[CLOSESTREAM](){nextTick(()=>this.emit(\"close\"))}[PROCESSENTRY](entry){let go=true;if(!entry){this[READENTRY]=null;go=false}else if(Array.isArray(entry)){this.emit.apply(this,entry)}else{this[READENTRY]=entry;this.emit(\"entry\",entry);if(!entry.emittedEnd){entry.on(\"end\",_=>this[NEXTENTRY]());go=false}}return go}[NEXTENTRY](){do{}while(this[PROCESSENTRY](this[QUEUE].shift()));if(!this[QUEUE].length){const re=this[READENTRY];const drainNow=!re||re.flowing||re.size===re.remain;if(drainNow){if(!this[WRITING]){this.emit(\"drain\")}}else{re.once(\"drain\",_=>this.emit(\"drain\"))}}}[CONSUMEBODY](chunk,position){const entry=this[WRITEENTRY];const br=entry.blockRemain;const c=br>=chunk.length&&position===0?chunk:chunk.slice(position,position+br);entry.write(c);if(!entry.blockRemain){this[STATE]=\"header\";this[WRITEENTRY]=null;entry.end()}return c.length}[CONSUMEMETA](chunk,position){const entry=this[WRITEENTRY];const ret=this[CONSUMEBODY](chunk,position);if(!this[WRITEENTRY]){this[EMITMETA](entry)}return ret}[EMIT](ev,data,extra){if(!this[QUEUE].length&&!this[READENTRY]){this.emit(ev,data,extra)}else{this[QUEUE].push([ev,data,extra])}}[EMITMETA](entry){this[EMIT](\"meta\",this[META]);switch(entry.type){case\"ExtendedHeader\":case\"OldExtendedHeader\":this[EX]=Pax.parse(this[META],this[EX],false);break;case\"GlobalExtendedHeader\":this[GEX]=Pax.parse(this[META],this[GEX],true);break;case\"NextFileHasLongPath\":case\"OldGnuLongPath\":this[EX]=this[EX]||Object.create(null);this[EX].path=this[META].replace(/\\0.*/,\"\");break;case\"NextFileHasLongLinkpath\":this[EX]=this[EX]||Object.create(null);this[EX].linkpath=this[META].replace(/\\0.*/,\"\");break;default:throw new Error(\"unknown meta: \"+entry.type)}}abort(error){this[ABORTED]=true;this.emit(\"abort\",error);this.warn(\"TAR_ABORT\",error,{recoverable:false})}write(chunk){if(this[ABORTED]){return}const needSniff=this[UNZIP]===null||this.brotli===void 0&&this[UNZIP]===false;if(needSniff&&chunk){if(this[BUFFER]){chunk=Buffer.concat([this[BUFFER],chunk]);this[BUFFER]=null}if(chunk.length<gzipHeader.length){this[BUFFER]=chunk;return true}for(let i=0;this[UNZIP]===null&&i<gzipHeader.length;i++){if(chunk[i]!==gzipHeader[i]){this[UNZIP]=false}}const maybeBrotli=this.brotli===void 0;if(this[UNZIP]===false&&maybeBrotli){if(chunk.length<512){if(this[ENDED]){this.brotli=true}else{this[BUFFER]=chunk;return true}}else{try{new Header(chunk.slice(0,512));this.brotli=false}catch(_){this.brotli=true}}}if(this[UNZIP]===null||this[UNZIP]===false&&this.brotli){const ended=this[ENDED];this[ENDED]=false;this[UNZIP]=this[UNZIP]===null?new zlib.Unzip:new zlib.BrotliDecompress;this[UNZIP].on(\"data\",chunk2=>this[CONSUMECHUNK](chunk2));this[UNZIP].on(\"error\",er=>this.abort(er));this[UNZIP].on(\"end\",_=>{this[ENDED]=true;this[CONSUMECHUNK]()});this[WRITING]=true;const ret2=this[UNZIP][ended?\"end\":\"write\"](chunk);this[WRITING]=false;return ret2}}this[WRITING]=true;if(this[UNZIP]){this[UNZIP].write(chunk)}else{this[CONSUMECHUNK](chunk)}this[WRITING]=false;const ret=this[QUEUE].length?false:this[READENTRY]?this[READENTRY].flowing:true;if(!ret&&!this[QUEUE].length){this[READENTRY].once(\"drain\",_=>this.emit(\"drain\"))}return ret}[BUFFERCONCAT](c){if(c&&!this[ABORTED]){this[BUFFER]=this[BUFFER]?Buffer.concat([this[BUFFER],c]):c}}[MAYBEEND](){if(this[ENDED]&&!this[EMITTEDEND]&&!this[ABORTED]&&!this[CONSUMING]){this[EMITTEDEND]=true;const entry=this[WRITEENTRY];if(entry&&entry.blockRemain){const have=this[BUFFER]?this[BUFFER].length:0;this.warn(\"TAR_BAD_ARCHIVE\",`Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`,{entry});if(this[BUFFER]){entry.write(this[BUFFER])}entry.end()}this[EMIT](DONE)}}[CONSUMECHUNK](chunk){if(this[CONSUMING]){this[BUFFERCONCAT](chunk)}else if(!chunk&&!this[BUFFER]){this[MAYBEEND]()}else{this[CONSUMING]=true;if(this[BUFFER]){this[BUFFERCONCAT](chunk);const c=this[BUFFER];this[BUFFER]=null;this[CONSUMECHUNKSUB](c)}else{this[CONSUMECHUNKSUB](chunk)}while(this[BUFFER]&&this[BUFFER].length>=512&&!this[ABORTED]&&!this[SAW_EOF]){const c=this[BUFFER];this[BUFFER]=null;this[CONSUMECHUNKSUB](c)}this[CONSUMING]=false}if(!this[BUFFER]||this[ENDED]){this[MAYBEEND]()}}[CONSUMECHUNKSUB](chunk){let position=0;const length=chunk.length;while(position+512<=length&&!this[ABORTED]&&!this[SAW_EOF]){switch(this[STATE]){case\"begin\":case\"header\":this[CONSUMEHEADER](chunk,position);position+=512;break;case\"ignore\":case\"body\":position+=this[CONSUMEBODY](chunk,position);break;case\"meta\":position+=this[CONSUMEMETA](chunk,position);break;default:throw new Error(\"invalid state: \"+this[STATE])}}if(position<length){if(this[BUFFER]){this[BUFFER]=Buffer.concat([chunk.slice(position),this[BUFFER]])}else{this[BUFFER]=chunk.slice(position)}}}end(chunk){if(!this[ABORTED]){if(this[UNZIP]){this[UNZIP].end(chunk)}else{this[ENDED]=true;if(this.brotli===void 0)chunk=chunk||Buffer.alloc(0);this.write(chunk)}}}});\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAsBA,MAAM,OAAS,QAAQ,iBAAiB,EACxC,MAAM,OAAS,QAAQ,aAAa,EACpC,MAAM,GAAK,QAAQ,QAAQ,EAC3B,MAAM,QAAU,QAAQ,SAAS,EACjC,MAAM,iBAAmB,KAAO,KAChC,MAAM,MAAQ,QAAQ,iBAAiB,EACvC,MAAM,IAAM,QAAQ,UAAU,EAC9B,MAAM,KAAO,QAAQ,UAAU,EAC/B,KAAM,CAAE,QAAS,EAAI,QAAQ,SAAS,EAEtC,MAAM,WAAa,OAAO,KAAK,CAAC,GAAM,GAAI,CAAC,EAC3C,MAAM,MAAQ,OAAO,OAAO,EAC5B,MAAM,WAAa,OAAO,YAAY,EACtC,MAAM,UAAY,OAAO,WAAW,EACpC,MAAM,UAAY,OAAO,WAAW,EACpC,MAAM,aAAe,OAAO,cAAc,EAC1C,MAAM,GAAK,OAAO,gBAAgB,EAClC,MAAM,IAAM,OAAO,sBAAsB,EACzC,MAAM,KAAO,OAAO,MAAM,EAC1B,MAAM,SAAW,OAAO,UAAU,EAClC,MAAM,OAAS,OAAO,QAAQ,EAC9B,MAAM,MAAQ,OAAO,OAAO,EAC5B,MAAM,MAAQ,OAAO,OAAO,EAC5B,MAAM,WAAa,OAAO,YAAY,EACtC,MAAM,KAAO,OAAO,MAAM,EAC1B,MAAM,MAAQ,OAAO,OAAO,EAC5B,MAAM,aAAe,OAAO,cAAc,EAC1C,MAAM,gBAAkB,OAAO,iBAAiB,EAChD,MAAM,YAAc,OAAO,aAAa,EACxC,MAAM,YAAc,OAAO,aAAa,EACxC,MAAM,cAAgB,OAAO,eAAe,EAC5C,MAAM,UAAY,OAAO,WAAW,EACpC,MAAM,aAAe,OAAO,cAAc,EAC1C,MAAM,SAAW,OAAO,UAAU,EAClC,MAAM,QAAU,OAAO,SAAS,EAChC,MAAM,QAAU,OAAO,SAAS,EAChC,MAAM,KAAO,OAAO,QAAQ,EAC5B,MAAM,gBAAkB,OAAO,eAAe,EAC9C,MAAM,eAAiB,OAAO,cAAc,EAC5C,MAAM,QAAU,OAAO,QAAQ,EAC/B,MAAM,YAAc,OAAO,aAAa,EAExC,MAAM,KAAO,UAAK,KAAL,QAEb,OAAO,QAAU,OAAO,MAAM,eAAe,EAAG,CAlEhD,MAkEgD,uBAC9C,YAAa,IAAK,CAChB,IAAM,KAAO,CAAC,EACd,MAAM,GAAG,EAET,KAAK,KAAO,IAAI,MAAQ,GAIxB,KAAK,eAAe,EAAI,KAGxB,KAAK,GAAG,KAAM,GAAK,CACjB,GAAI,KAAK,KAAK,IAAM,SAAW,KAAK,eAAe,IAAM,MAAO,CAG9D,KAAK,KAAK,kBAAmB,6BAA6B,CAC5D,CACF,CAAC,EAED,GAAI,IAAI,OAAQ,CACd,KAAK,GAAG,KAAM,IAAI,MAAM,CAC1B,KAAO,CACL,KAAK,GAAG,KAAM,GAAK,CACjB,KAAK,KAAK,WAAW,EACrB,KAAK,KAAK,QAAQ,EAClB,KAAK,KAAK,KAAK,CACjB,CAAC,CACH,CAEA,KAAK,OAAS,CAAC,CAAC,IAAI,OACpB,KAAK,iBAAmB,IAAI,kBAAoB,iBAChD,KAAK,OAAS,OAAO,IAAI,SAAW,WAAa,IAAI,OAAS,KAI9D,MAAM,MAAS,IAAI,OACf,IAAI,KAAK,SAAS,SAAS,GAAK,IAAI,KAAK,SAAS,MAAM,GAG5D,KAAK,OAAS,CAAC,IAAI,MAAQ,IAAI,SAAW,OAAY,IAAI,OACtD,MAAQ,OACR,MAGJ,KAAK,SAAW,KAChB,KAAK,SAAW,MAEhB,KAAK,KAAK,EAAI,IAAI,QAClB,KAAK,MAAM,EAAI,KACf,KAAK,SAAS,EAAI,KAClB,KAAK,UAAU,EAAI,KACnB,KAAK,KAAK,EAAI,QACd,KAAK,IAAI,EAAI,GACb,KAAK,EAAE,EAAI,KACX,KAAK,GAAG,EAAI,KACZ,KAAK,KAAK,EAAI,MACd,KAAK,KAAK,EAAI,KACd,KAAK,OAAO,EAAI,MAChB,KAAK,cAAc,EAAI,MACvB,KAAK,OAAO,EAAI,MAEhB,KAAK,GAAG,MAAO,IAAM,KAAK,WAAW,EAAE,CAAC,EAExC,GAAI,OAAO,IAAI,SAAW,WAAY,CACpC,KAAK,GAAG,OAAQ,IAAI,MAAM,CAC5B,CACA,GAAI,OAAO,IAAI,UAAY,WAAY,CACrC,KAAK,GAAG,QAAS,IAAI,OAAO,CAC9B,CACF,CAEA,CAAC,aAAa,EAAG,MAAO,SAAU,CAChC,GAAI,KAAK,eAAe,IAAM,KAAM,CAClC,KAAK,eAAe,EAAI,KAC1B,CACA,IAAI,OACJ,GAAI,CACF,OAAS,IAAI,OAAO,MAAO,SAAU,KAAK,EAAE,EAAG,KAAK,GAAG,CAAC,CAC1D,OAAS,GAAI,CACX,OAAO,KAAK,KAAK,oBAAqB,EAAE,CAC1C,CAEA,GAAI,OAAO,UAAW,CACpB,GAAI,KAAK,cAAc,EAAG,CACxB,KAAK,OAAO,EAAI,KAEhB,GAAI,KAAK,KAAK,IAAM,QAAS,CAC3B,KAAK,KAAK,EAAI,QAChB,CACA,KAAK,IAAI,EAAE,KAAK,CAClB,KAAO,CACL,KAAK,cAAc,EAAI,KACvB,KAAK,IAAI,EAAE,WAAW,CACxB,CACF,KAAO,CACL,KAAK,cAAc,EAAI,MACvB,GAAI,CAAC,OAAO,WAAY,CACtB,KAAK,KAAK,oBAAqB,mBAAoB,CAAE,MAAO,CAAC,CAC/D,SAAW,CAAC,OAAO,KAAM,CACvB,KAAK,KAAK,oBAAqB,mBAAoB,CAAE,MAAO,CAAC,CAC/D,KAAO,CACL,MAAM,KAAO,OAAO,KACpB,GAAI,oBAAoB,KAAK,IAAI,GAAK,CAAC,OAAO,SAAU,CACtD,KAAK,KAAK,oBAAqB,oBAAqB,CAAE,MAAO,CAAC,CAChE,SAAW,CAAC,oBAAoB,KAAK,IAAI,GAAK,OAAO,SAAU,CAC7D,KAAK,KAAK,oBAAqB,qBAAsB,CAAE,MAAO,CAAC,CACjE,KAAO,CACL,MAAM,MAAQ,KAAK,UAAU,EAAI,IAAI,MAAM,OAAQ,KAAK,EAAE,EAAG,KAAK,GAAG,CAAC,EAItE,GAAI,CAAC,KAAK,eAAe,EAAG,CAC1B,GAAI,MAAM,OAAQ,CAEhB,MAAM,MAAQ,WAAM,CAClB,GAAI,CAAC,MAAM,QAAS,CAClB,KAAK,eAAe,EAAI,IAC1B,CACF,EAJc,SAKd,MAAM,GAAG,MAAO,KAAK,CACvB,KAAO,CACL,KAAK,eAAe,EAAI,IAC1B,CACF,CAEA,GAAI,MAAM,KAAM,CACd,GAAI,MAAM,KAAO,KAAK,iBAAkB,CACtC,MAAM,OAAS,KACf,KAAK,IAAI,EAAE,eAAgB,KAAK,EAChC,KAAK,KAAK,EAAI,SACd,MAAM,OAAO,CACf,SAAW,MAAM,KAAO,EAAG,CACzB,KAAK,IAAI,EAAI,GACb,MAAM,GAAG,OAAQ,GAAK,KAAK,IAAI,GAAK,CAAC,EACrC,KAAK,KAAK,EAAI,MAChB,CACF,KAAO,CACL,KAAK,EAAE,EAAI,KACX,MAAM,OAAS,MAAM,QAAU,CAAC,KAAK,OAAO,MAAM,KAAM,KAAK,EAE7D,GAAI,MAAM,OAAQ,CAEhB,KAAK,IAAI,EAAE,eAAgB,KAAK,EAChC,KAAK,KAAK,EAAI,MAAM,OAAS,SAAW,SACxC,MAAM,OAAO,CACf,KAAO,CACL,GAAI,MAAM,OAAQ,CAChB,KAAK,KAAK,EAAI,MAChB,KAAO,CACL,KAAK,KAAK,EAAI,SACd,MAAM,IAAI,CACZ,CAEA,GAAI,CAAC,KAAK,SAAS,EAAG,CACpB,KAAK,KAAK,EAAE,KAAK,KAAK,EACtB,KAAK,SAAS,EAAE,CAClB,KAAO,CACL,KAAK,KAAK,EAAE,KAAK,KAAK,CACxB,CACF,CACF,CACF,CACF,CACF,CACF,CAEA,CAAC,WAAW,GAAK,CACf,SAAS,IAAM,KAAK,KAAK,OAAO,CAAC,CACnC,CAEA,CAAC,YAAY,EAAG,MAAO,CACrB,IAAI,GAAK,KAET,GAAI,CAAC,MAAO,CACV,KAAK,SAAS,EAAI,KAClB,GAAK,KACP,SAAW,MAAM,QAAQ,KAAK,EAAG,CAC/B,KAAK,KAAK,MAAM,KAAM,KAAK,CAC7B,KAAO,CACL,KAAK,SAAS,EAAI,MAClB,KAAK,KAAK,QAAS,KAAK,EACxB,GAAI,CAAC,MAAM,WAAY,CACrB,MAAM,GAAG,MAAO,GAAK,KAAK,SAAS,EAAE,CAAC,EACtC,GAAK,KACP,CACF,CAEA,OAAO,EACT,CAEA,CAAC,SAAS,GAAK,CACb,EAAG,CAAC,OAAS,KAAK,YAAY,EAAE,KAAK,KAAK,EAAE,MAAM,CAAC,GAEnD,GAAI,CAAC,KAAK,KAAK,EAAE,OAAQ,CAQvB,MAAM,GAAK,KAAK,SAAS,EACzB,MAAM,SAAW,CAAC,IAAM,GAAG,SAAW,GAAG,OAAS,GAAG,OACrD,GAAI,SAAU,CACZ,GAAI,CAAC,KAAK,OAAO,EAAG,CAClB,KAAK,KAAK,OAAO,CACnB,CACF,KAAO,CACL,GAAG,KAAK,QAAS,GAAK,KAAK,KAAK,OAAO,CAAC,CAC1C,CACF,CACF,CAEA,CAAC,WAAW,EAAG,MAAO,SAAU,CAE9B,MAAM,MAAQ,KAAK,UAAU,EAC7B,MAAM,GAAK,MAAM,YACjB,MAAM,EAAK,IAAM,MAAM,QAAU,WAAa,EAAK,MAC/C,MAAM,MAAM,SAAU,SAAW,EAAE,EAEvC,MAAM,MAAM,CAAC,EAEb,GAAI,CAAC,MAAM,YAAa,CACtB,KAAK,KAAK,EAAI,SACd,KAAK,UAAU,EAAI,KACnB,MAAM,IAAI,CACZ,CAEA,OAAO,EAAE,MACX,CAEA,CAAC,WAAW,EAAG,MAAO,SAAU,CAC9B,MAAM,MAAQ,KAAK,UAAU,EAC7B,MAAM,IAAM,KAAK,WAAW,EAAE,MAAO,QAAQ,EAG7C,GAAI,CAAC,KAAK,UAAU,EAAG,CACrB,KAAK,QAAQ,EAAE,KAAK,CACtB,CAEA,OAAO,GACT,CAEA,CAAC,IAAI,EAAG,GAAI,KAAM,MAAO,CACvB,GAAI,CAAC,KAAK,KAAK,EAAE,QAAU,CAAC,KAAK,SAAS,EAAG,CAC3C,KAAK,KAAK,GAAI,KAAM,KAAK,CAC3B,KAAO,CACL,KAAK,KAAK,EAAE,KAAK,CAAC,GAAI,KAAM,KAAK,CAAC,CACpC,CACF,CAEA,CAAC,QAAQ,EAAG,MAAO,CACjB,KAAK,IAAI,EAAE,OAAQ,KAAK,IAAI,CAAC,EAC7B,OAAQ,MAAM,KAAM,CAClB,IAAK,iBACL,IAAK,oBACH,KAAK,EAAE,EAAI,IAAI,MAAM,KAAK,IAAI,EAAG,KAAK,EAAE,EAAG,KAAK,EAChD,MAEF,IAAK,uBACH,KAAK,GAAG,EAAI,IAAI,MAAM,KAAK,IAAI,EAAG,KAAK,GAAG,EAAG,IAAI,EACjD,MAEF,IAAK,sBACL,IAAK,iBACH,KAAK,EAAE,EAAI,KAAK,EAAE,GAAK,OAAO,OAAO,IAAI,EACzC,KAAK,EAAE,EAAE,KAAO,KAAK,IAAI,EAAE,QAAQ,OAAQ,EAAE,EAC7C,MAEF,IAAK,0BACH,KAAK,EAAE,EAAI,KAAK,EAAE,GAAK,OAAO,OAAO,IAAI,EACzC,KAAK,EAAE,EAAE,SAAW,KAAK,IAAI,EAAE,QAAQ,OAAQ,EAAE,EACjD,MAGF,QAAS,MAAM,IAAI,MAAM,iBAAmB,MAAM,IAAI,CACxD,CACF,CAEA,MAAO,MAAO,CACZ,KAAK,OAAO,EAAI,KAChB,KAAK,KAAK,QAAS,KAAK,EAExB,KAAK,KAAK,YAAa,MAAO,CAAE,YAAa,KAAM,CAAC,CACtD,CAEA,MAAO,MAAO,CACZ,GAAI,KAAK,OAAO,EAAG,CACjB,MACF,CAGA,MAAM,UAAY,KAAK,KAAK,IAAM,MAChC,KAAK,SAAW,QAAa,KAAK,KAAK,IAAM,MAC/C,GAAI,WAAa,MAAO,CACtB,GAAI,KAAK,MAAM,EAAG,CAChB,MAAQ,OAAO,OAAO,CAAC,KAAK,MAAM,EAAG,KAAK,CAAC,EAC3C,KAAK,MAAM,EAAI,IACjB,CACA,GAAI,MAAM,OAAS,WAAW,OAAQ,CACpC,KAAK,MAAM,EAAI,MACf,MAAO,KACT,CAGA,QAAS,EAAI,EAAG,KAAK,KAAK,IAAM,MAAQ,EAAI,WAAW,OAAQ,IAAK,CAClE,GAAI,MAAM,CAAC,IAAM,WAAW,CAAC,EAAG,CAC9B,KAAK,KAAK,EAAI,KAChB,CACF,CAEA,MAAM,YAAc,KAAK,SAAW,OACpC,GAAI,KAAK,KAAK,IAAM,OAAS,YAAa,CAKxC,GAAI,MAAM,OAAS,IAAK,CACtB,GAAI,KAAK,KAAK,EAAG,CACf,KAAK,OAAS,IAChB,KAAO,CACL,KAAK,MAAM,EAAI,MACf,MAAO,KACT,CACF,KAAO,CAGL,GAAI,CACF,IAAI,OAAO,MAAM,MAAM,EAAG,GAAG,CAAC,EAC9B,KAAK,OAAS,KAChB,OAAS,EAAG,CACV,KAAK,OAAS,IAChB,CACF,CACF,CAEA,GAAI,KAAK,KAAK,IAAM,MAAS,KAAK,KAAK,IAAM,OAAS,KAAK,OAAS,CAClE,MAAM,MAAQ,KAAK,KAAK,EACxB,KAAK,KAAK,EAAI,MACd,KAAK,KAAK,EAAI,KAAK,KAAK,IAAM,KAC1B,IAAI,KAAK,MACT,IAAI,KAAK,iBACb,KAAK,KAAK,EAAE,GAAG,OAAQA,QAAS,KAAK,YAAY,EAAEA,MAAK,CAAC,EACzD,KAAK,KAAK,EAAE,GAAG,QAAS,IAAM,KAAK,MAAM,EAAE,CAAC,EAC5C,KAAK,KAAK,EAAE,GAAG,MAAO,GAAK,CACzB,KAAK,KAAK,EAAI,KACd,KAAK,YAAY,EAAE,CACrB,CAAC,EACD,KAAK,OAAO,EAAI,KAChB,MAAMC,KAAM,KAAK,KAAK,EAAE,MAAQ,MAAQ,OAAO,EAAE,KAAK,EACtD,KAAK,OAAO,EAAI,MAChB,OAAOA,IACT,CACF,CAEA,KAAK,OAAO,EAAI,KAChB,GAAI,KAAK,KAAK,EAAG,CACf,KAAK,KAAK,EAAE,MAAM,KAAK,CACzB,KAAO,CACL,KAAK,YAAY,EAAE,KAAK,CAC1B,CACA,KAAK,OAAO,EAAI,MAGhB,MAAM,IACJ,KAAK,KAAK,EAAE,OAAS,MACrB,KAAK,SAAS,EAAI,KAAK,SAAS,EAAE,QAClC,KAGF,GAAI,CAAC,KAAO,CAAC,KAAK,KAAK,EAAE,OAAQ,CAC/B,KAAK,SAAS,EAAE,KAAK,QAAS,GAAK,KAAK,KAAK,OAAO,CAAC,CACvD,CAEA,OAAO,GACT,CAEA,CAAC,YAAY,EAAG,EAAG,CACjB,GAAI,GAAK,CAAC,KAAK,OAAO,EAAG,CACvB,KAAK,MAAM,EAAI,KAAK,MAAM,EAAI,OAAO,OAAO,CAAC,KAAK,MAAM,EAAG,CAAC,CAAC,EAAI,CACnE,CACF,CAEA,CAAC,QAAQ,GAAK,CACZ,GAAI,KAAK,KAAK,GACV,CAAC,KAAK,UAAU,GAChB,CAAC,KAAK,OAAO,GACb,CAAC,KAAK,SAAS,EAAG,CACpB,KAAK,UAAU,EAAI,KACnB,MAAM,MAAQ,KAAK,UAAU,EAC7B,GAAI,OAAS,MAAM,YAAa,CAE9B,MAAM,KAAO,KAAK,MAAM,EAAI,KAAK,MAAM,EAAE,OAAS,EAClD,KAAK,KAAK,kBAAmB,2BAC3B,MAAM,WAAW,qBAAqB,IAAI,cAAe,CAAE,KAAM,CAAC,EACpE,GAAI,KAAK,MAAM,EAAG,CAChB,MAAM,MAAM,KAAK,MAAM,CAAC,CAC1B,CACA,MAAM,IAAI,CACZ,CACA,KAAK,IAAI,EAAE,IAAI,CACjB,CACF,CAEA,CAAC,YAAY,EAAG,MAAO,CACrB,GAAI,KAAK,SAAS,EAAG,CACnB,KAAK,YAAY,EAAE,KAAK,CAC1B,SAAW,CAAC,OAAS,CAAC,KAAK,MAAM,EAAG,CAClC,KAAK,QAAQ,EAAE,CACjB,KAAO,CACL,KAAK,SAAS,EAAI,KAClB,GAAI,KAAK,MAAM,EAAG,CAChB,KAAK,YAAY,EAAE,KAAK,EACxB,MAAM,EAAI,KAAK,MAAM,EACrB,KAAK,MAAM,EAAI,KACf,KAAK,eAAe,EAAE,CAAC,CACzB,KAAO,CACL,KAAK,eAAe,EAAE,KAAK,CAC7B,CAEA,MAAO,KAAK,MAAM,GACd,KAAK,MAAM,EAAE,QAAU,KACvB,CAAC,KAAK,OAAO,GACb,CAAC,KAAK,OAAO,EAAG,CAClB,MAAM,EAAI,KAAK,MAAM,EACrB,KAAK,MAAM,EAAI,KACf,KAAK,eAAe,EAAE,CAAC,CACzB,CACA,KAAK,SAAS,EAAI,KACpB,CAEA,GAAI,CAAC,KAAK,MAAM,GAAK,KAAK,KAAK,EAAG,CAChC,KAAK,QAAQ,EAAE,CACjB,CACF,CAEA,CAAC,eAAe,EAAG,MAAO,CAGxB,IAAI,SAAW,EACf,MAAM,OAAS,MAAM,OACrB,MAAO,SAAW,KAAO,QAAU,CAAC,KAAK,OAAO,GAAK,CAAC,KAAK,OAAO,EAAG,CACnE,OAAQ,KAAK,KAAK,EAAG,CACnB,IAAK,QACL,IAAK,SACH,KAAK,aAAa,EAAE,MAAO,QAAQ,EACnC,UAAY,IACZ,MAEF,IAAK,SACL,IAAK,OACH,UAAY,KAAK,WAAW,EAAE,MAAO,QAAQ,EAC7C,MAEF,IAAK,OACH,UAAY,KAAK,WAAW,EAAE,MAAO,QAAQ,EAC7C,MAGF,QACE,MAAM,IAAI,MAAM,kBAAoB,KAAK,KAAK,CAAC,CACnD,CACF,CAEA,GAAI,SAAW,OAAQ,CACrB,GAAI,KAAK,MAAM,EAAG,CAChB,KAAK,MAAM,EAAI,OAAO,OAAO,CAAC,MAAM,MAAM,QAAQ,EAAG,KAAK,MAAM,CAAC,CAAC,CACpE,KAAO,CACL,KAAK,MAAM,EAAI,MAAM,MAAM,QAAQ,CACrC,CACF,CACF,CAEA,IAAK,MAAO,CACV,GAAI,CAAC,KAAK,OAAO,EAAG,CAClB,GAAI,KAAK,KAAK,EAAG,CACf,KAAK,KAAK,EAAE,IAAI,KAAK,CACvB,KAAO,CACL,KAAK,KAAK,EAAI,KACd,GAAI,KAAK,SAAW,OAAW,MAAQ,OAAS,OAAO,MAAM,CAAC,EAC9D,KAAK,MAAM,KAAK,CAClB,CACF,CACF,CACF,CAAC","names":["chunk","ret"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/parse.js"],"sourcesContent":["'use strict'\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js')\nconst Header = require('./header.js')\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = require('./read-entry.js')\nconst Pax = require('./pax.js')\nconst zlib = require('minizlib')\nconst { nextTick } = require('process')\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\nconst SAW_EOF = Symbol('sawEOF')\nconst CLOSESTREAM = Symbol('closeStream')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.file = opt.file || ''\n\n    // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n    this[SAW_VALID_ENTRY] = null\n\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\n      }\n    })\n\n    if (opt.ondone) {\n      this.on(DONE, opt.ondone)\n    } else {\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n      })\n    }\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n    // Unlike gzip, brotli doesn't have any magic bytes to identify it\n    // Users need to explicitly tell us they're extracting a brotli file\n    // Or we infer from the file extension\n    const isTBR = (opt.file && (\n        opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr')))\n    // if it's a tbr file it MIGHT be brotli, but we don't know until\n    // we look at it and verify it's not a valid tar file.\n    this.brotli = !opt.gzip && opt.brotli !== undefined ? opt.brotli\n      : isTBR ? undefined\n      : false\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    this[SAW_NULL_BLOCK] = false\n    this[SAW_EOF] = false\n\n    this.on('end', () => this[CLOSESTREAM]())\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n    if (typeof opt.onentry === 'function') {\n      this.on('entry', opt.onentry)\n    }\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null) {\n      this[SAW_VALID_ENTRY] = false\n    }\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er)\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true\n        // ending an archive with no entries.  pointless, but legal.\n        if (this[STATE] === 'begin') {\n          this[STATE] = 'header'\n        }\n        this[EMIT]('eof')\n      } else {\n        this[SAW_NULL_BLOCK] = true\n        this[EMIT]('nullBlock')\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false\n      if (!header.cksumValid) {\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header })\n      } else if (!header.path) {\n        this.warn('TAR_ENTRY_INVALID', 'path is required', { header })\n      } else {\n        const type = header.type\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', { header })\n        } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', { header })\n        } else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n          // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid) {\n                  this[SAW_VALID_ENTRY] = true\n                }\n              }\n              entry.on('end', onend)\n            } else {\n              this[SAW_VALID_ENTRY] = true\n            }\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = 'ignore'\n              entry.resume()\n            } else if (entry.size > 0) {\n              this[META] = ''\n              entry.on('data', c => this[META] += c)\n              this[STATE] = 'meta'\n            }\n          } else {\n            this[EX] = null\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = entry.remain ? 'ignore' : 'header'\n              entry.resume()\n            } else {\n              if (entry.remain) {\n                this[STATE] = 'body'\n              } else {\n                this[STATE] = 'header'\n                entry.end()\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry)\n                this[NEXTENTRY]()\n              } else {\n                this[QUEUE].push(entry)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [CLOSESTREAM] () {\n    nextTick(() => this.emit('close'))\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry)) {\n      this.emit.apply(this, entry)\n    } else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING]) {\n          this.emit('drain')\n        }\n      } else {\n        re.once('drain', _ => this.emit('drain'))\n      }\n    }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY]) {\n      this[EMITMETA](entry)\n    }\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY]) {\n      this.emit(ev, data, extra)\n    } else {\n      this[QUEUE].push([ev, data, extra])\n    }\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (error) {\n    this[ABORTED] = true\n    this.emit('abort', error)\n    // always throws, even in non-strict mode\n    this.warn('TAR_ABORT', error, { recoverable: false })\n  }\n\n  write (chunk) {\n    if (this[ABORTED]) {\n      return\n    }\n\n    // first write, might be gzipped\n    const needSniff = this[UNZIP] === null ||\n      this.brotli === undefined && this[UNZIP] === false\n    if (needSniff && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n\n      // look for gzip header\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i]) {\n          this[UNZIP] = false\n        }\n      }\n\n      const maybeBrotli = this.brotli === undefined\n      if (this[UNZIP] === false && maybeBrotli) {\n        // read the first header to see if it's a valid tar file. If so,\n        // we can safely assume that it's not actually brotli, despite the\n        // .tbr or .tar.br file extension.\n        // if we ended before getting a full chunk, yes, def brotli\n        if (chunk.length < 512) {\n          if (this[ENDED]) {\n            this.brotli = true\n          } else {\n            this[BUFFER] = chunk\n            return true\n          }\n        } else {\n          // if it's tar, it's pretty reliably not brotli, chances of\n          // that happening are astronomical.\n          try {\n            new Header(chunk.slice(0, 512))\n            this.brotli = false\n          } catch (_) {\n            this.brotli = true\n          }\n        }\n      }\n\n      if (this[UNZIP] === null || (this[UNZIP] === false && this.brotli)) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = this[UNZIP] === null\n          ? new zlib.Unzip()\n          : new zlib.BrotliDecompress()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er => this.abort(er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP]) {\n      this[UNZIP].write(chunk)\n    } else {\n      this[CONSUMECHUNK](chunk)\n    }\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length) {\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n    }\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED]) {\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n    }\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${\n          entry.blockRemain} more bytes, only ${have} available)`, { entry })\n        if (this[BUFFER]) {\n          entry.write(this[BUFFER])\n        }\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] &&\n          this[BUFFER].length >= 512 &&\n          !this[ABORTED] &&\n          !this[SAW_EOF]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED]) {\n      this[MAYBEEND]()\n    }\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    const length = chunk.length\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER]) {\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      } else {\n        this[BUFFER] = chunk.slice(position)\n      }\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP]) {\n        this[UNZIP].end(chunk)\n      } else {\n        this[ENDED] = true\n        if (this.brotli === undefined) chunk = chunk || Buffer.alloc(0)\n        this.write(chunk)\n      }\n    }\n  }\n})\n"]}}