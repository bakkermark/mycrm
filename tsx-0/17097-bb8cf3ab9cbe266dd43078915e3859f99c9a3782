{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{removeLeadingZero}=require(\"./svgo/tools\");const argsCountPerCommand={M:2,m:2,Z:0,z:0,L:2,l:2,H:1,h:1,V:1,v:1,C:6,c:6,S:4,s:4,Q:4,q:4,T:2,t:2,A:7,a:7};const isCommand=__name(c=>{return c in argsCountPerCommand},\"isCommand\");const isWsp=__name(c=>{const codePoint=c.codePointAt(0);return codePoint===32||codePoint===9||codePoint===13||codePoint===10},\"isWsp\");const isDigit=__name(c=>{const codePoint=c.codePointAt(0);if(codePoint==null){return false}return 48<=codePoint&&codePoint<=57},\"isDigit\");const readNumber=__name((string,cursor)=>{let i=cursor;let value=\"\";let state=\"none\";for(;i<string.length;i+=1){const c=string[i];if(c===\"+\"||c===\"-\"){if(state===\"none\"){state=\"sign\";value+=c;continue}if(state===\"e\"){state=\"exponent_sign\";value+=c;continue}}if(isDigit(c)){if(state===\"none\"||state===\"sign\"||state===\"whole\"){state=\"whole\";value+=c;continue}if(state===\"decimal_point\"||state===\"decimal\"){state=\"decimal\";value+=c;continue}if(state===\"e\"||state===\"exponent_sign\"||state===\"exponent\"){state=\"exponent\";value+=c;continue}}if(c===\".\"){if(state===\"none\"||state===\"sign\"||state===\"whole\"){state=\"decimal_point\";value+=c;continue}}if(c===\"E\"||c==\"e\"){if(state===\"whole\"||state===\"decimal_point\"||state===\"decimal\"){state=\"e\";value+=c;continue}}break}const number=Number.parseFloat(value);if(Number.isNaN(number)){return[cursor,null]}else{return[i-1,number]}},\"readNumber\");const parsePathData=__name(string=>{const pathData=[];let command=null;let args=[];let argsCount=0;let canHaveComma=false;let hadComma=false;for(let i=0;i<string.length;i+=1){const c=string.charAt(i);if(isWsp(c)){continue}if(canHaveComma&&c===\",\"){if(hadComma){break}hadComma=true;continue}if(isCommand(c)){if(hadComma){return pathData}if(command==null){if(c!==\"M\"&&c!==\"m\"){return pathData}}else{if(args.length!==0){return pathData}}command=c;args=[];argsCount=argsCountPerCommand[command];canHaveComma=false;if(argsCount===0){pathData.push({command,args})}continue}if(command==null){return pathData}let newCursor=i;let number=null;if(command===\"A\"||command===\"a\"){const position=args.length;if(position===0||position===1){if(c!==\"+\"&&c!==\"-\"){[newCursor,number]=readNumber(string,i)}}if(position===2||position===5||position===6){[newCursor,number]=readNumber(string,i)}if(position===3||position===4){if(c===\"0\"){number=0}if(c===\"1\"){number=1}}}else{[newCursor,number]=readNumber(string,i)}if(number==null){return pathData}args.push(number);canHaveComma=true;hadComma=false;i=newCursor;if(args.length===argsCount){pathData.push({command,args});if(command===\"M\"){command=\"L\"}if(command===\"m\"){command=\"l\"}args=[]}}return pathData},\"parsePathData\");exports.parsePathData=parsePathData;const stringifyNumber=__name((number,precision)=>{if(precision!=null){const ratio=10**precision;number=Math.round(number*ratio)/ratio}return removeLeadingZero(number)},\"stringifyNumber\");const stringifyArgs=__name((command,args,precision,disableSpaceAfterFlags)=>{let result=\"\";let prev=\"\";for(let i=0;i<args.length;i+=1){const number=args[i];const numberString=stringifyNumber(number,precision);if(disableSpaceAfterFlags&&(command===\"A\"||command===\"a\")&&(i%7===4||i%7===5)){result+=numberString}else if(i===0||numberString.startsWith(\"-\")){result+=numberString}else if(prev.includes(\".\")&&numberString.startsWith(\".\")){result+=numberString}else{result+=` ${numberString}`}prev=numberString}return result},\"stringifyArgs\");const stringifyPathData=__name(({pathData,precision,disableSpaceAfterFlags})=>{let combined=[];for(let i=0;i<pathData.length;i+=1){const{command,args}=pathData[i];if(i===0){combined.push({command,args})}else{const last=combined[combined.length-1];if(i===1){if(command===\"L\"){last.command=\"M\"}if(command===\"l\"){last.command=\"m\"}}if(last.command===command&&last.command!==\"M\"&&last.command!==\"m\"||last.command===\"M\"&&command===\"L\"||last.command===\"m\"&&command===\"l\"){last.args=[...last.args,...args]}else{combined.push({command,args})}}}let result=\"\";for(const{command,args}of combined){result+=command+stringifyArgs(command,args,precision,disableSpaceAfterFlags)}return result},\"stringifyPathData\");exports.stringifyPathData=stringifyPathData;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/lib/path.js"],"sourcesContent":["'use strict';\n\nconst { removeLeadingZero } = require('./svgo/tools');\n\n/**\n * @typedef {import('./types').PathDataItem} PathDataItem\n * @typedef {import('./types').PathDataCommand} PathDataCommand\n */\n\n// Based on https://www.w3.org/TR/SVG11/paths.html#PathDataBNF\n\nconst argsCountPerCommand = {\n  M: 2,\n  m: 2,\n  Z: 0,\n  z: 0,\n  L: 2,\n  l: 2,\n  H: 1,\n  h: 1,\n  V: 1,\n  v: 1,\n  C: 6,\n  c: 6,\n  S: 4,\n  s: 4,\n  Q: 4,\n  q: 4,\n  T: 2,\n  t: 2,\n  A: 7,\n  a: 7,\n};\n\n/**\n * @type {(c: string) => c is PathDataCommand}\n */\nconst isCommand = (c) => {\n  return c in argsCountPerCommand;\n};\n\n/**\n * @type {(c: string) => boolean}\n */\nconst isWsp = (c) => {\n  const codePoint = c.codePointAt(0);\n  return (\n    codePoint === 0x20 ||\n    codePoint === 0x9 ||\n    codePoint === 0xd ||\n    codePoint === 0xa\n  );\n};\n\n/**\n * @type {(c: string) => boolean}\n */\nconst isDigit = (c) => {\n  const codePoint = c.codePointAt(0);\n  if (codePoint == null) {\n    return false;\n  }\n  return 48 <= codePoint && codePoint <= 57;\n};\n\n/**\n * @typedef {'none' | 'sign' | 'whole' | 'decimal_point' | 'decimal' | 'e' | 'exponent_sign' | 'exponent'} ReadNumberState\n */\n\n/**\n * @type {(string: string, cursor: number) => [number, ?number]}\n */\nconst readNumber = (string, cursor) => {\n  let i = cursor;\n  let value = '';\n  let state = /** @type {ReadNumberState} */ ('none');\n  for (; i < string.length; i += 1) {\n    const c = string[i];\n    if (c === '+' || c === '-') {\n      if (state === 'none') {\n        state = 'sign';\n        value += c;\n        continue;\n      }\n      if (state === 'e') {\n        state = 'exponent_sign';\n        value += c;\n        continue;\n      }\n    }\n    if (isDigit(c)) {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'whole';\n        value += c;\n        continue;\n      }\n      if (state === 'decimal_point' || state === 'decimal') {\n        state = 'decimal';\n        value += c;\n        continue;\n      }\n      if (state === 'e' || state === 'exponent_sign' || state === 'exponent') {\n        state = 'exponent';\n        value += c;\n        continue;\n      }\n    }\n    if (c === '.') {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'decimal_point';\n        value += c;\n        continue;\n      }\n    }\n    if (c === 'E' || c == 'e') {\n      if (\n        state === 'whole' ||\n        state === 'decimal_point' ||\n        state === 'decimal'\n      ) {\n        state = 'e';\n        value += c;\n        continue;\n      }\n    }\n    break;\n  }\n  const number = Number.parseFloat(value);\n  if (Number.isNaN(number)) {\n    return [cursor, null];\n  } else {\n    // step back to delegate iteration to parent loop\n    return [i - 1, number];\n  }\n};\n\n/**\n * @type {(string: string) => Array<PathDataItem>}\n */\nconst parsePathData = (string) => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const pathData = [];\n  /**\n   * @type {?PathDataCommand}\n   */\n  let command = null;\n  let args = /** @type {number[]} */ ([]);\n  let argsCount = 0;\n  let canHaveComma = false;\n  let hadComma = false;\n  for (let i = 0; i < string.length; i += 1) {\n    const c = string.charAt(i);\n    if (isWsp(c)) {\n      continue;\n    }\n    // allow comma only between arguments\n    if (canHaveComma && c === ',') {\n      if (hadComma) {\n        break;\n      }\n      hadComma = true;\n      continue;\n    }\n    if (isCommand(c)) {\n      if (hadComma) {\n        return pathData;\n      }\n      if (command == null) {\n        // moveto should be leading command\n        if (c !== 'M' && c !== 'm') {\n          return pathData;\n        }\n      } else {\n        // stop if previous command arguments are not flushed\n        if (args.length !== 0) {\n          return pathData;\n        }\n      }\n      command = c;\n      args = [];\n      argsCount = argsCountPerCommand[command];\n      canHaveComma = false;\n      // flush command without arguments\n      if (argsCount === 0) {\n        pathData.push({ command, args });\n      }\n      continue;\n    }\n    // avoid parsing arguments if no command detected\n    if (command == null) {\n      return pathData;\n    }\n    // read next argument\n    let newCursor = i;\n    let number = null;\n    if (command === 'A' || command === 'a') {\n      const position = args.length;\n      if (position === 0 || position === 1) {\n        // allow only positive number without sign as first two arguments\n        if (c !== '+' && c !== '-') {\n          [newCursor, number] = readNumber(string, i);\n        }\n      }\n      if (position === 2 || position === 5 || position === 6) {\n        [newCursor, number] = readNumber(string, i);\n      }\n      if (position === 3 || position === 4) {\n        // read flags\n        if (c === '0') {\n          number = 0;\n        }\n        if (c === '1') {\n          number = 1;\n        }\n      }\n    } else {\n      [newCursor, number] = readNumber(string, i);\n    }\n    if (number == null) {\n      return pathData;\n    }\n    args.push(number);\n    canHaveComma = true;\n    hadComma = false;\n    i = newCursor;\n    // flush arguments when necessary count is reached\n    if (args.length === argsCount) {\n      pathData.push({ command, args });\n      // subsequent moveto coordinates are threated as implicit lineto commands\n      if (command === 'M') {\n        command = 'L';\n      }\n      if (command === 'm') {\n        command = 'l';\n      }\n      args = [];\n    }\n  }\n  return pathData;\n};\nexports.parsePathData = parsePathData;\n\n/**\n * @type {(number: number, precision?: number) => string}\n */\nconst stringifyNumber = (number, precision) => {\n  if (precision != null) {\n    const ratio = 10 ** precision;\n    number = Math.round(number * ratio) / ratio;\n  }\n  // remove zero whole from decimal number\n  return removeLeadingZero(number);\n};\n\n/**\n * Elliptical arc large-arc and sweep flags are rendered with spaces\n * because many non-browser environments are not able to parse such paths\n *\n * @type {(\n *   command: string,\n *   args: number[],\n *   precision?: number,\n *   disableSpaceAfterFlags?: boolean\n * ) => string}\n */\nconst stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {\n  let result = '';\n  let prev = '';\n  for (let i = 0; i < args.length; i += 1) {\n    const number = args[i];\n    const numberString = stringifyNumber(number, precision);\n    if (\n      disableSpaceAfterFlags &&\n      (command === 'A' || command === 'a') &&\n      // consider combined arcs\n      (i % 7 === 4 || i % 7 === 5)\n    ) {\n      result += numberString;\n    } else if (i === 0 || numberString.startsWith('-')) {\n      // avoid space before first and negative numbers\n      result += numberString;\n    } else if (prev.includes('.') && numberString.startsWith('.')) {\n      // remove space before decimal with zero whole\n      // only when previous number is also decimal\n      result += numberString;\n    } else {\n      result += ` ${numberString}`;\n    }\n    prev = numberString;\n  }\n  return result;\n};\n\n/**\n * @typedef {{\n *   pathData: Array<PathDataItem>;\n *   precision?: number;\n *   disableSpaceAfterFlags?: boolean;\n * }} StringifyPathDataOptions\n */\n\n/**\n * @type {(options: StringifyPathDataOptions) => string}\n */\nconst stringifyPathData = ({ pathData, precision, disableSpaceAfterFlags }) => {\n  // combine sequence of the same commands\n  let combined = [];\n  for (let i = 0; i < pathData.length; i += 1) {\n    const { command, args } = pathData[i];\n    if (i === 0) {\n      combined.push({ command, args });\n    } else {\n      /**\n       * @type {PathDataItem}\n       */\n      const last = combined[combined.length - 1];\n      // match leading moveto with following lineto\n      if (i === 1) {\n        if (command === 'L') {\n          last.command = 'M';\n        }\n        if (command === 'l') {\n          last.command = 'm';\n        }\n      }\n      if (\n        (last.command === command &&\n          last.command !== 'M' &&\n          last.command !== 'm') ||\n        // combine matching moveto and lineto sequences\n        (last.command === 'M' && command === 'L') ||\n        (last.command === 'm' && command === 'l')\n      ) {\n        last.args = [...last.args, ...args];\n      } else {\n        combined.push({ command, args });\n      }\n    }\n  }\n  let result = '';\n  for (const { command, args } of combined) {\n    result +=\n      command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);\n  }\n  return result;\n};\nexports.stringifyPathData = stringifyPathData;\n"]}}