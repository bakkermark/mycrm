{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{collectStylesheet,computeStyle}=require(\"../lib/style.js\");const{transformsMultiply,transform2js,transformArc}=require(\"./_transforms.js\");const{path2js}=require(\"./_path.js\");const{removeLeadingZero}=require(\"../lib/svgo/tools.js\");const{referencesProps,attrsGroupsDefaults}=require(\"./_collections.js\");const regNumericValues=/[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;const applyTransforms=__name((root,params)=>{const stylesheet=collectStylesheet(root);return{element:{enter:node=>{const computedStyle=computeStyle(stylesheet,node);if(node.attributes.d==null){return}if(node.attributes.id!=null){return}if(node.attributes.transform==null||node.attributes.transform===\"\"||node.attributes.style!=null||Object.entries(node.attributes).some(([name,value])=>referencesProps.includes(name)&&value.includes(\"url(\"))){return}const matrix=transformsMultiply(transform2js(node.attributes.transform));const stroke=computedStyle.stroke!=null&&computedStyle.stroke.type===\"static\"?computedStyle.stroke.value:null;const strokeWidth=computedStyle[\"stroke-width\"]!=null&&computedStyle[\"stroke-width\"].type===\"static\"?computedStyle[\"stroke-width\"].value:null;const transformPrecision=params.transformPrecision;if(computedStyle.stroke!=null&&computedStyle.stroke.type===\"dynamic\"||computedStyle.strokeWidth!=null&&computedStyle[\"stroke-width\"].type===\"dynamic\"){return}const scale=Number(Math.sqrt(matrix.data[0]*matrix.data[0]+matrix.data[1]*matrix.data[1]).toFixed(transformPrecision));if(stroke&&stroke!=\"none\"){if(params.applyTransformsStroked===false){return}if((matrix.data[0]!==matrix.data[3]||matrix.data[1]!==-matrix.data[2])&&(matrix.data[0]!==-matrix.data[3]||matrix.data[1]!==matrix.data[2])){return}if(scale!==1){if(node.attributes[\"vector-effect\"]!==\"non-scaling-stroke\"){node.attributes[\"stroke-width\"]=(strokeWidth||attrsGroupsDefaults.presentation[\"stroke-width\"]).trim().replace(regNumericValues,num=>removeLeadingZero(Number(num)*scale));if(node.attributes[\"stroke-dashoffset\"]!=null){node.attributes[\"stroke-dashoffset\"]=node.attributes[\"stroke-dashoffset\"].trim().replace(regNumericValues,num=>removeLeadingZero(Number(num)*scale))}if(node.attributes[\"stroke-dasharray\"]!=null){node.attributes[\"stroke-dasharray\"]=node.attributes[\"stroke-dasharray\"].trim().replace(regNumericValues,num=>removeLeadingZero(Number(num)*scale))}}}}const pathData=path2js(node);applyMatrixToPathData(pathData,matrix.data);delete node.attributes.transform}}}},\"applyTransforms\");exports.applyTransforms=applyTransforms;const transformAbsolutePoint=__name((matrix,x,y)=>{const newX=matrix[0]*x+matrix[2]*y+matrix[4];const newY=matrix[1]*x+matrix[3]*y+matrix[5];return[newX,newY]},\"transformAbsolutePoint\");const transformRelativePoint=__name((matrix,x,y)=>{const newX=matrix[0]*x+matrix[2]*y;const newY=matrix[1]*x+matrix[3]*y;return[newX,newY]},\"transformRelativePoint\");const applyMatrixToPathData=__name((pathData,matrix)=>{const start=[0,0];const cursor=[0,0];for(const pathItem of pathData){let{command,args}=pathItem;if(command===\"M\"){cursor[0]=args[0];cursor[1]=args[1];start[0]=cursor[0];start[1]=cursor[1];const[x,y]=transformAbsolutePoint(matrix,args[0],args[1]);args[0]=x;args[1]=y}if(command===\"m\"){cursor[0]+=args[0];cursor[1]+=args[1];start[0]=cursor[0];start[1]=cursor[1];const[x,y]=transformRelativePoint(matrix,args[0],args[1]);args[0]=x;args[1]=y}if(command===\"H\"){command=\"L\";args=[args[0],cursor[1]]}if(command===\"h\"){command=\"l\";args=[args[0],0]}if(command===\"V\"){command=\"L\";args=[cursor[0],args[0]]}if(command===\"v\"){command=\"l\";args=[0,args[0]]}if(command===\"L\"){cursor[0]=args[0];cursor[1]=args[1];const[x,y]=transformAbsolutePoint(matrix,args[0],args[1]);args[0]=x;args[1]=y}if(command===\"l\"){cursor[0]+=args[0];cursor[1]+=args[1];const[x,y]=transformRelativePoint(matrix,args[0],args[1]);args[0]=x;args[1]=y}if(command===\"C\"){cursor[0]=args[4];cursor[1]=args[5];const[x1,y1]=transformAbsolutePoint(matrix,args[0],args[1]);const[x2,y2]=transformAbsolutePoint(matrix,args[2],args[3]);const[x,y]=transformAbsolutePoint(matrix,args[4],args[5]);args[0]=x1;args[1]=y1;args[2]=x2;args[3]=y2;args[4]=x;args[5]=y}if(command===\"c\"){cursor[0]+=args[4];cursor[1]+=args[5];const[x1,y1]=transformRelativePoint(matrix,args[0],args[1]);const[x2,y2]=transformRelativePoint(matrix,args[2],args[3]);const[x,y]=transformRelativePoint(matrix,args[4],args[5]);args[0]=x1;args[1]=y1;args[2]=x2;args[3]=y2;args[4]=x;args[5]=y}if(command===\"S\"){cursor[0]=args[2];cursor[1]=args[3];const[x2,y2]=transformAbsolutePoint(matrix,args[0],args[1]);const[x,y]=transformAbsolutePoint(matrix,args[2],args[3]);args[0]=x2;args[1]=y2;args[2]=x;args[3]=y}if(command===\"s\"){cursor[0]+=args[2];cursor[1]+=args[3];const[x2,y2]=transformRelativePoint(matrix,args[0],args[1]);const[x,y]=transformRelativePoint(matrix,args[2],args[3]);args[0]=x2;args[1]=y2;args[2]=x;args[3]=y}if(command===\"Q\"){cursor[0]=args[2];cursor[1]=args[3];const[x1,y1]=transformAbsolutePoint(matrix,args[0],args[1]);const[x,y]=transformAbsolutePoint(matrix,args[2],args[3]);args[0]=x1;args[1]=y1;args[2]=x;args[3]=y}if(command===\"q\"){cursor[0]+=args[2];cursor[1]+=args[3];const[x1,y1]=transformRelativePoint(matrix,args[0],args[1]);const[x,y]=transformRelativePoint(matrix,args[2],args[3]);args[0]=x1;args[1]=y1;args[2]=x;args[3]=y}if(command===\"T\"){cursor[0]=args[0];cursor[1]=args[1];const[x,y]=transformAbsolutePoint(matrix,args[0],args[1]);args[0]=x;args[1]=y}if(command===\"t\"){cursor[0]+=args[0];cursor[1]+=args[1];const[x,y]=transformRelativePoint(matrix,args[0],args[1]);args[0]=x;args[1]=y}if(command===\"A\"){transformArc(cursor,args,matrix);cursor[0]=args[5];cursor[1]=args[6];if(Math.abs(args[2])>80){const a=args[0];const rotation=args[2];args[0]=args[1];args[1]=a;args[2]=rotation+(rotation>0?-90:90)}const[x,y]=transformAbsolutePoint(matrix,args[5],args[6]);args[5]=x;args[6]=y}if(command===\"a\"){transformArc([0,0],args,matrix);cursor[0]+=args[5];cursor[1]+=args[6];if(Math.abs(args[2])>80){const a=args[0];const rotation=args[2];args[0]=args[1];args[1]=a;args[2]=rotation+(rotation>0?-90:90)}const[x,y]=transformRelativePoint(matrix,args[5],args[6]);args[5]=x;args[6]=y}if(command===\"z\"||command===\"Z\"){cursor[0]=start[0];cursor[1]=start[1]}pathItem.command=command;pathItem.args=args}},\"applyMatrixToPathData\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/applyTransforms.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst { collectStylesheet, computeStyle } = require('../lib/style.js');\nconst {\n  transformsMultiply,\n  transform2js,\n  transformArc,\n} = require('./_transforms.js');\nconst { path2js } = require('./_path.js');\nconst { removeLeadingZero } = require('../lib/svgo/tools.js');\nconst { referencesProps, attrsGroupsDefaults } = require('./_collections.js');\n\n/**\n * @typedef {Array<PathDataItem>} PathData\n * @typedef {Array<number>} Matrix\n */\n\nconst regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * Apply transformation(s) to the Path data.\n *\n * @type {import('../lib/types').Plugin<{\n *   transformPrecision: number,\n *   applyTransformsStroked: boolean,\n * }>}\n */\nconst applyTransforms = (root, params) => {\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: (node) => {\n        const computedStyle = computeStyle(stylesheet, node);\n\n        // used only for paths for now\n        if (node.attributes.d == null) {\n          return;\n        }\n\n        // stroke and stroke-width can be redefined with <use>\n        if (node.attributes.id != null) {\n          return;\n        }\n\n        // if there are no 'stroke' attr and references to other objects such as\n        // gradiends or clip-path which are also subjects to transform.\n        if (\n          node.attributes.transform == null ||\n          node.attributes.transform === '' ||\n          // styles are not considered when applying transform\n          // can be fixed properly with new style engine\n          node.attributes.style != null ||\n          Object.entries(node.attributes).some(\n            ([name, value]) =>\n              referencesProps.includes(name) && value.includes('url(')\n          )\n        ) {\n          return;\n        }\n\n        const matrix = transformsMultiply(\n          transform2js(node.attributes.transform)\n        );\n        const stroke =\n          computedStyle.stroke != null && computedStyle.stroke.type === 'static'\n            ? computedStyle.stroke.value\n            : null;\n\n        const strokeWidth =\n          computedStyle['stroke-width'] != null &&\n          computedStyle['stroke-width'].type === 'static'\n            ? computedStyle['stroke-width'].value\n            : null;\n        const transformPrecision = params.transformPrecision;\n\n        if (\n          (computedStyle.stroke != null &&\n            computedStyle.stroke.type === 'dynamic') ||\n          (computedStyle.strokeWidth != null &&\n            computedStyle['stroke-width'].type === 'dynamic')\n        ) {\n          return;\n        }\n\n        const scale = Number(\n          Math.sqrt(\n            matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]\n          ).toFixed(transformPrecision)\n        );\n\n        if (stroke && stroke != 'none') {\n          if (params.applyTransformsStroked === false) {\n            return;\n          }\n\n          // stroke cannot be transformed with different vertical and horizontal scale or skew\n          if (\n            (matrix.data[0] !== matrix.data[3] ||\n              matrix.data[1] !== -matrix.data[2]) &&\n            (matrix.data[0] !== -matrix.data[3] ||\n              matrix.data[1] !== matrix.data[2])\n          ) {\n            return;\n          }\n\n          // apply transform to stroke-width, stroke-dashoffset and stroke-dasharray\n          if (scale !== 1) {\n            if (node.attributes['vector-effect'] !== 'non-scaling-stroke') {\n              node.attributes['stroke-width'] = (\n                strokeWidth || attrsGroupsDefaults.presentation['stroke-width']\n              )\n                .trim()\n                .replace(regNumericValues, (num) =>\n                  removeLeadingZero(Number(num) * scale)\n                );\n\n              if (node.attributes['stroke-dashoffset'] != null) {\n                node.attributes['stroke-dashoffset'] = node.attributes[\n                  'stroke-dashoffset'\n                ]\n                  .trim()\n                  .replace(regNumericValues, (num) =>\n                    removeLeadingZero(Number(num) * scale)\n                  );\n              }\n\n              if (node.attributes['stroke-dasharray'] != null) {\n                node.attributes['stroke-dasharray'] = node.attributes[\n                  'stroke-dasharray'\n                ]\n                  .trim()\n                  .replace(regNumericValues, (num) =>\n                    removeLeadingZero(Number(num) * scale)\n                  );\n              }\n            }\n          }\n        }\n\n        const pathData = path2js(node);\n        applyMatrixToPathData(pathData, matrix.data);\n\n        // remove transform attr\n        delete node.attributes.transform;\n      },\n    },\n  };\n};\nexports.applyTransforms = applyTransforms;\n\n/**\n * @type {(matrix: Matrix, x: number, y: number) => [number, number]}\n */\nconst transformAbsolutePoint = (matrix, x, y) => {\n  const newX = matrix[0] * x + matrix[2] * y + matrix[4];\n  const newY = matrix[1] * x + matrix[3] * y + matrix[5];\n  return [newX, newY];\n};\n\n/**\n * @type {(matrix: Matrix, x: number, y: number) => [number, number]}\n */\nconst transformRelativePoint = (matrix, x, y) => {\n  const newX = matrix[0] * x + matrix[2] * y;\n  const newY = matrix[1] * x + matrix[3] * y;\n  return [newX, newY];\n};\n\n/**\n * @type {(pathData: PathData, matrix: Matrix) => void}\n */\nconst applyMatrixToPathData = (pathData, matrix) => {\n  /**\n   * @type {[number, number]}\n   */\n  const start = [0, 0];\n  /**\n   * @type {[number, number]}\n   */\n  const cursor = [0, 0];\n\n  for (const pathItem of pathData) {\n    let { command, args } = pathItem;\n\n    // moveto (x y)\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 'm') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // horizontal lineto (x)\n    // convert to lineto to handle two-dimentional transforms\n    if (command === 'H') {\n      command = 'L';\n      args = [args[0], cursor[1]];\n    }\n    if (command === 'h') {\n      command = 'l';\n      args = [args[0], 0];\n    }\n\n    // vertical lineto (y)\n    // convert to lineto to handle two-dimentional transforms\n    if (command === 'V') {\n      command = 'L';\n      args = [cursor[0], args[0]];\n    }\n    if (command === 'v') {\n      command = 'l';\n      args = [0, args[0]];\n    }\n\n    // lineto (x y)\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 'l') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);\n      const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x2;\n      args[3] = y2;\n      args[4] = x;\n      args[5] = y;\n    }\n    if (command === 'c') {\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);\n      const [x, y] = transformRelativePoint(matrix, args[4], args[5]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x2;\n      args[3] = y2;\n      args[4] = x;\n      args[5] = y;\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n      const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);\n      args[0] = x2;\n      args[1] = y2;\n      args[2] = x;\n      args[3] = y;\n    }\n    if (command === 's') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n      const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);\n      args[0] = x2;\n      args[1] = y2;\n      args[2] = x;\n      args[3] = y;\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x;\n      args[3] = y;\n    }\n    if (command === 'q') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x;\n      args[3] = y;\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 't') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'A') {\n      transformArc(cursor, args, matrix);\n      cursor[0] = args[5];\n      cursor[1] = args[6];\n      // reduce number of digits in rotation angle\n      if (Math.abs(args[2]) > 80) {\n        const a = args[0];\n        const rotation = args[2];\n        args[0] = args[1];\n        args[1] = a;\n        args[2] = rotation + (rotation > 0 ? -90 : 90);\n      }\n      const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);\n      args[5] = x;\n      args[6] = y;\n    }\n    if (command === 'a') {\n      transformArc([0, 0], args, matrix);\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n      // reduce number of digits in rotation angle\n      if (Math.abs(args[2]) > 80) {\n        const a = args[0];\n        const rotation = args[2];\n        args[0] = args[1];\n        args[1] = a;\n        args[2] = rotation + (rotation > 0 ? -90 : 90);\n      }\n      const [x, y] = transformRelativePoint(matrix, args[5], args[6]);\n      args[5] = x;\n      args[6] = y;\n    }\n\n    // closepath\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n    }\n\n    pathItem.command = command;\n    pathItem.args = args;\n  }\n};\n"]}}