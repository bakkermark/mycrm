{"code":"(()=>{\n\"use strict\";const{stringifyPathData}=require(\"../lib/path.js\");const{detachNodeFromParent}=require(\"../lib/xast.js\");exports.name=\"convertShapeToPath\";exports.description=\"converts basic shapes to more compact path form\";const regNumber=/[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;exports.fn=(root,params)=>{const{convertArcs=false,floatPrecision:precision}=params;return{element:{enter:(node,parentNode)=>{if(node.name===\"rect\"&&node.attributes.width!=null&&node.attributes.height!=null&&node.attributes.rx==null&&node.attributes.ry==null){const x=Number(node.attributes.x||\"0\");const y=Number(node.attributes.y||\"0\");const width=Number(node.attributes.width);const height=Number(node.attributes.height);if(Number.isNaN(x-y+width-height))return;const pathData=[{command:\"M\",args:[x,y]},{command:\"H\",args:[x+width]},{command:\"V\",args:[y+height]},{command:\"H\",args:[x]},{command:\"z\",args:[]}];node.name=\"path\";node.attributes.d=stringifyPathData({pathData,precision});delete node.attributes.x;delete node.attributes.y;delete node.attributes.width;delete node.attributes.height}if(node.name===\"line\"){const x1=Number(node.attributes.x1||\"0\");const y1=Number(node.attributes.y1||\"0\");const x2=Number(node.attributes.x2||\"0\");const y2=Number(node.attributes.y2||\"0\");if(Number.isNaN(x1-y1+x2-y2))return;const pathData=[{command:\"M\",args:[x1,y1]},{command:\"L\",args:[x2,y2]}];node.name=\"path\";node.attributes.d=stringifyPathData({pathData,precision});delete node.attributes.x1;delete node.attributes.y1;delete node.attributes.x2;delete node.attributes.y2}if((node.name===\"polyline\"||node.name===\"polygon\")&&node.attributes.points!=null){const coords=(node.attributes.points.match(regNumber)||[]).map(Number);if(coords.length<4){detachNodeFromParent(node,parentNode);return}const pathData=[];for(let i=0;i<coords.length;i+=2){pathData.push({command:i===0?\"M\":\"L\",args:coords.slice(i,i+2)})}if(node.name===\"polygon\"){pathData.push({command:\"z\",args:[]})}node.name=\"path\";node.attributes.d=stringifyPathData({pathData,precision});delete node.attributes.points}if(node.name===\"circle\"&&convertArcs){const cx=Number(node.attributes.cx||\"0\");const cy=Number(node.attributes.cy||\"0\");const r=Number(node.attributes.r||\"0\");if(Number.isNaN(cx-cy+r)){return}const pathData=[{command:\"M\",args:[cx,cy-r]},{command:\"A\",args:[r,r,0,1,0,cx,cy+r]},{command:\"A\",args:[r,r,0,1,0,cx,cy-r]},{command:\"z\",args:[]}];node.name=\"path\";node.attributes.d=stringifyPathData({pathData,precision});delete node.attributes.cx;delete node.attributes.cy;delete node.attributes.r}if(node.name===\"ellipse\"&&convertArcs){const ecx=Number(node.attributes.cx||\"0\");const ecy=Number(node.attributes.cy||\"0\");const rx=Number(node.attributes.rx||\"0\");const ry=Number(node.attributes.ry||\"0\");if(Number.isNaN(ecx-ecy+rx-ry)){return}const pathData=[{command:\"M\",args:[ecx,ecy-ry]},{command:\"A\",args:[rx,ry,0,1,0,ecx,ecy+ry]},{command:\"A\",args:[rx,ry,0,1,0,ecx,ecy-ry]},{command:\"z\",args:[]}];node.name=\"path\";node.attributes.d=stringifyPathData({pathData,precision});delete node.attributes.cx;delete node.attributes.cy;delete node.attributes.rx;delete node.attributes.ry}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/convertShapeToPath.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { stringifyPathData } = require('../lib/path.js');\nconst { detachNodeFromParent } = require('../lib/xast.js');\n\nexports.name = 'convertShapeToPath';\nexports.description = 'converts basic shapes to more compact path form';\n\nconst regNumber = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * Converts basic shape to more compact path.\n * It also allows further optimizations like\n * combining paths with similar attributes.\n *\n * @see https://www.w3.org/TR/SVG11/shapes.html\n *\n * @author Lev Solntsev\n *\n * @type {import('./plugins-types').Plugin<'convertShapeToPath'>}\n */\nexports.fn = (root, params) => {\n  const { convertArcs = false, floatPrecision: precision } = params;\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // convert rect to path\n        if (\n          node.name === 'rect' &&\n          node.attributes.width != null &&\n          node.attributes.height != null &&\n          node.attributes.rx == null &&\n          node.attributes.ry == null\n        ) {\n          const x = Number(node.attributes.x || '0');\n          const y = Number(node.attributes.y || '0');\n          const width = Number(node.attributes.width);\n          const height = Number(node.attributes.height);\n          // Values like '100%' compute to NaN, thus running after\n          // cleanupNumericValues when 'px' units has already been removed.\n          // TODO: Calculate sizes from % and non-px units if possible.\n          if (Number.isNaN(x - y + width - height)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [x, y] },\n            { command: 'H', args: [x + width] },\n            { command: 'V', args: [y + height] },\n            { command: 'H', args: [x] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.x;\n          delete node.attributes.y;\n          delete node.attributes.width;\n          delete node.attributes.height;\n        }\n\n        // convert line to path\n        if (node.name === 'line') {\n          const x1 = Number(node.attributes.x1 || '0');\n          const y1 = Number(node.attributes.y1 || '0');\n          const x2 = Number(node.attributes.x2 || '0');\n          const y2 = Number(node.attributes.y2 || '0');\n          if (Number.isNaN(x1 - y1 + x2 - y2)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [x1, y1] },\n            { command: 'L', args: [x2, y2] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.x1;\n          delete node.attributes.y1;\n          delete node.attributes.x2;\n          delete node.attributes.y2;\n        }\n\n        // convert polyline and polygon to path\n        if (\n          (node.name === 'polyline' || node.name === 'polygon') &&\n          node.attributes.points != null\n        ) {\n          const coords = (node.attributes.points.match(regNumber) || []).map(\n            Number\n          );\n          if (coords.length < 4) {\n            detachNodeFromParent(node, parentNode);\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [];\n          for (let i = 0; i < coords.length; i += 2) {\n            pathData.push({\n              command: i === 0 ? 'M' : 'L',\n              args: coords.slice(i, i + 2),\n            });\n          }\n          if (node.name === 'polygon') {\n            pathData.push({ command: 'z', args: [] });\n          }\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.points;\n        }\n\n        //  optionally convert circle\n        if (node.name === 'circle' && convertArcs) {\n          const cx = Number(node.attributes.cx || '0');\n          const cy = Number(node.attributes.cy || '0');\n          const r = Number(node.attributes.r || '0');\n          if (Number.isNaN(cx - cy + r)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [cx, cy - r] },\n            { command: 'A', args: [r, r, 0, 1, 0, cx, cy + r] },\n            { command: 'A', args: [r, r, 0, 1, 0, cx, cy - r] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.r;\n        }\n\n        // optionally covert ellipse\n        if (node.name === 'ellipse' && convertArcs) {\n          const ecx = Number(node.attributes.cx || '0');\n          const ecy = Number(node.attributes.cy || '0');\n          const rx = Number(node.attributes.rx || '0');\n          const ry = Number(node.attributes.ry || '0');\n          if (Number.isNaN(ecx - ecy + rx - ry)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [ecx, ecy - ry] },\n            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },\n            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.rx;\n          delete node.attributes.ry;\n        }\n      },\n    },\n  };\n};\n"]}}