{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const hlo=require(\"./high-level-opt.js\");const Pack=require(\"./pack.js\");const fsm=require(\"fs-minipass\");const t=require(\"./list.js\");const path=require(\"path\");module.exports=(opt_,files,cb)=>{if(typeof files===\"function\"){cb=files}if(Array.isArray(opt_)){files=opt_,opt_={}}if(!files||!Array.isArray(files)||!files.length){throw new TypeError(\"no files or directories specified\")}files=Array.from(files);const opt=hlo(opt_);if(opt.sync&&typeof cb===\"function\"){throw new TypeError(\"callback not supported for sync tar functions\")}if(!opt.file&&typeof cb===\"function\"){throw new TypeError(\"callback only supported with file option\")}return opt.file&&opt.sync?createFileSync(opt,files):opt.file?createFile(opt,files,cb):opt.sync?createSync(opt,files):create(opt,files)};const createFileSync=__name((opt,files)=>{const p=new Pack.Sync(opt);const stream=new fsm.WriteStreamSync(opt.file,{mode:opt.mode||438});p.pipe(stream);addFilesSync(p,files)},\"createFileSync\");const createFile=__name((opt,files,cb)=>{const p=new Pack(opt);const stream=new fsm.WriteStream(opt.file,{mode:opt.mode||438});p.pipe(stream);const promise=new Promise((res,rej)=>{stream.on(\"error\",rej);stream.on(\"close\",res);p.on(\"error\",rej)});addFilesAsync(p,files);return cb?promise.then(cb,cb):promise},\"createFile\");const addFilesSync=__name((p,files)=>{files.forEach(file=>{if(file.charAt(0)===\"@\"){t({file:path.resolve(p.cwd,file.slice(1)),sync:true,noResume:true,onentry:entry=>p.add(entry)})}else{p.add(file)}});p.end()},\"addFilesSync\");const addFilesAsync=__name((p,files)=>{while(files.length){const file=files.shift();if(file.charAt(0)===\"@\"){return t({file:path.resolve(p.cwd,file.slice(1)),noResume:true,onentry:entry=>p.add(entry)}).then(_=>addFilesAsync(p,files))}else{p.add(file)}}p.end()},\"addFilesAsync\");const createSync=__name((opt,files)=>{const p=new Pack.Sync(opt);addFilesSync(p,files);return p},\"createSync\");const create=__name((opt,files)=>{const p=new Pack(opt);addFilesAsync(p,files);return p},\"create\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/create.js"],"sourcesContent":["'use strict'\n\n// tar -c\nconst hlo = require('./high-level-opt.js')\n\nconst Pack = require('./pack.js')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof files === 'function') {\n    cb = files\n  }\n\n  if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  return opt.file && opt.sync ? createFileSync(opt, files)\n    : opt.file ? createFile(opt, files, cb)\n    : opt.sync ? createSync(opt, files)\n    : create(opt, files)\n}\n\nconst createFileSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt, files, cb) => {\n  const p = new Pack(opt)\n  const stream = new fsm.WriteStream(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n\n  const promise = new Promise((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n\nconst createSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst create = (opt, files) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n"]}}