{"code":"(()=>{\n\"use strict\";const{attrsGroupsDefaults,colorsProps}=require(\"./_collections\");const{detachNodeFromParent,querySelectorAll,querySelector}=require(\"../lib/xast\");const{computeStyle,collectStylesheet}=require(\"../lib/style\");exports.name=\"convertOneStopGradients\";exports.description=\"converts one-stop (single color) gradients to a plain color\";exports.fn=root=>{const stylesheet=collectStylesheet(root);const effectedDefs=new Set;const allDefs=new Map;const gradientsToDetach=new Map;let xlinkHrefCount=0;return{element:{enter:(node,parentNode)=>{if(node.attributes[\"xlink:href\"]!=null){xlinkHrefCount++}if(node.name===\"defs\"){allDefs.set(node,parentNode);return}if(node.name!==\"linearGradient\"&&node.name!==\"radialGradient\"){return}const stops=node.children.filter(child=>{return child.type===\"element\"&&child.name===\"stop\"});const href=node.attributes[\"xlink:href\"]||node.attributes[\"href\"];let effectiveNode=stops.length===0&&href!=null&&href.startsWith(\"#\")?querySelector(root,href):node;if(effectiveNode==null||effectiveNode.type!==\"element\"){gradientsToDetach.set(node,parentNode);return}const effectiveStops=effectiveNode.children.filter(child=>{return child.type===\"element\"&&child.name===\"stop\"});if(effectiveStops.length!==1||effectiveStops[0].type!==\"element\"){return}if(parentNode.type===\"element\"&&parentNode.name===\"defs\"){effectedDefs.add(parentNode)}gradientsToDetach.set(node,parentNode);let color;const style=computeStyle(stylesheet,effectiveStops[0])[\"stop-color\"];if(style!=null&&style.type===\"static\"){color=style.value}const selectorVal=`url(#${node.attributes.id})`;const selector=colorsProps.map(attr=>`[${attr}=\"${selectorVal}\"]`).join(\",\");const elements=querySelectorAll(root,selector);for(const element of elements){if(element.type!==\"element\"){continue}for(const attr of colorsProps){if(element.attributes[attr]!==selectorVal){continue}if(color!=null){element.attributes[attr]=color}else{delete element.attributes[attr]}}}const styledElements=querySelectorAll(root,`[style*=${selectorVal}]`);for(const element of styledElements){if(element.type!==\"element\"){continue}element.attributes.style=element.attributes.style.replace(selectorVal,color||attrsGroupsDefaults.presentation[\"stop-color\"])}},exit:node=>{if(node.name===\"svg\"){for(const[gradient,parent]of gradientsToDetach.entries()){if(gradient.attributes[\"xlink:href\"]!=null){xlinkHrefCount--}detachNodeFromParent(gradient,parent)}if(xlinkHrefCount===0){delete node.attributes[\"xmlns:xlink\"]}for(const[defs,parent]of allDefs.entries()){if(effectedDefs.has(defs)&&defs.children.length===0){detachNodeFromParent(defs,parent)}}}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/convertOneStopGradients.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n */\n\nconst { attrsGroupsDefaults, colorsProps } = require('./_collections');\nconst {\n  detachNodeFromParent,\n  querySelectorAll,\n  querySelector,\n} = require('../lib/xast');\nconst { computeStyle, collectStylesheet } = require('../lib/style');\n\nexports.name = 'convertOneStopGradients';\nexports.description =\n  'converts one-stop (single color) gradients to a plain color';\n\n/**\n * Converts one-stop (single color) gradients to a plain color.\n *\n * @author Seth Falco <seth@falco.fun>\n * @type {import('./plugins-types').Plugin<'convertOneStopGradients'>}\n * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient\n * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/radialGradient\n */\nexports.fn = (root) => {\n  const stylesheet = collectStylesheet(root);\n\n  /**\n   * Parent defs that had gradients elements removed from them.\n   *\n   * @type {Set<XastElement>}\n   */\n  const effectedDefs = new Set();\n\n  /**\n   * @type {Map<XastElement, XastParent>}\n   */\n  const allDefs = new Map();\n\n  /**\n   * @type {Map<XastElement, XastParent>}\n   */\n  const gradientsToDetach = new Map();\n\n  /** Number of references to the xlink:href attribute. */\n  let xlinkHrefCount = 0;\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.attributes['xlink:href'] != null) {\n          xlinkHrefCount++;\n        }\n\n        if (node.name === 'defs') {\n          allDefs.set(node, parentNode);\n          return;\n        }\n\n        if (node.name !== 'linearGradient' && node.name !== 'radialGradient') {\n          return;\n        }\n\n        const stops = node.children.filter((child) => {\n          return child.type === 'element' && child.name === 'stop';\n        });\n\n        const href = node.attributes['xlink:href'] || node.attributes['href'];\n        let effectiveNode =\n          stops.length === 0 && href != null && href.startsWith('#')\n            ? querySelector(root, href)\n            : node;\n\n        if (effectiveNode == null || effectiveNode.type !== 'element') {\n          gradientsToDetach.set(node, parentNode);\n          return;\n        }\n\n        const effectiveStops = effectiveNode.children.filter((child) => {\n          return child.type === 'element' && child.name === 'stop';\n        });\n\n        if (\n          effectiveStops.length !== 1 ||\n          effectiveStops[0].type !== 'element'\n        ) {\n          return;\n        }\n\n        if (parentNode.type === 'element' && parentNode.name === 'defs') {\n          effectedDefs.add(parentNode);\n        }\n\n        gradientsToDetach.set(node, parentNode);\n\n        let color;\n        const style = computeStyle(stylesheet, effectiveStops[0])['stop-color'];\n        if (style != null && style.type === 'static') {\n          color = style.value;\n        }\n\n        const selectorVal = `url(#${node.attributes.id})`;\n\n        const selector = colorsProps\n          .map((attr) => `[${attr}=\"${selectorVal}\"]`)\n          .join(',');\n        const elements = querySelectorAll(root, selector);\n        for (const element of elements) {\n          if (element.type !== 'element') {\n            continue;\n          }\n\n          for (const attr of colorsProps) {\n            if (element.attributes[attr] !== selectorVal) {\n              continue;\n            }\n\n            if (color != null) {\n              element.attributes[attr] = color;\n            } else {\n              delete element.attributes[attr];\n            }\n          }\n        }\n\n        const styledElements = querySelectorAll(\n          root,\n          `[style*=${selectorVal}]`\n        );\n        for (const element of styledElements) {\n          if (element.type !== 'element') {\n            continue;\n          }\n\n          element.attributes.style = element.attributes.style.replace(\n            selectorVal,\n            color || attrsGroupsDefaults.presentation['stop-color']\n          );\n        }\n      },\n\n      exit: (node) => {\n        if (node.name === 'svg') {\n          for (const [gradient, parent] of gradientsToDetach.entries()) {\n            if (gradient.attributes['xlink:href'] != null) {\n              xlinkHrefCount--;\n            }\n\n            detachNodeFromParent(gradient, parent);\n          }\n\n          if (xlinkHrefCount === 0) {\n            delete node.attributes['xmlns:xlink'];\n          }\n\n          for (const [defs, parent] of allDefs.entries()) {\n            if (effectedDefs.has(defs) && defs.children.length === 0) {\n              detachNodeFromParent(defs, parent);\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"]}}