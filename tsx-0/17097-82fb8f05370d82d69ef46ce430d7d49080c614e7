{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"assert\");const Buffer2=require(\"buffer\").Buffer;const realZlib=require(\"zlib\");const constants=exports.constants=require(\"./constants.js\");const Minipass=require(\"minipass\");const OriginalBufferConcat=Buffer2.concat;const _superWrite=Symbol(\"_superWrite\");class ZlibError extends Error{static{__name(this,\"ZlibError\")}constructor(err){super(\"zlib: \"+err.message);this.code=err.code;this.errno=err.errno;if(!this.code)this.code=\"ZLIB_ERROR\";this.message=\"zlib: \"+err.message;Error.captureStackTrace(this,this.constructor)}get name(){return\"ZlibError\"}}const _opts=Symbol(\"opts\");const _flushFlag=Symbol(\"flushFlag\");const _finishFlushFlag=Symbol(\"finishFlushFlag\");const _fullFlushFlag=Symbol(\"fullFlushFlag\");const _handle=Symbol(\"handle\");const _onError=Symbol(\"onError\");const _sawError=Symbol(\"sawError\");const _level=Symbol(\"level\");const _strategy=Symbol(\"strategy\");const _ended=Symbol(\"ended\");const _defaultFullFlush=Symbol(\"_defaultFullFlush\");class ZlibBase extends Minipass{static{__name(this,\"ZlibBase\")}constructor(opts,mode){if(!opts||typeof opts!==\"object\")throw new TypeError(\"invalid options for ZlibBase constructor\");super(opts);this[_sawError]=false;this[_ended]=false;this[_opts]=opts;this[_flushFlag]=opts.flush;this[_finishFlushFlag]=opts.finishFlush;try{this[_handle]=new realZlib[mode](opts)}catch(er){throw new ZlibError(er)}this[_onError]=err=>{if(this[_sawError])return;this[_sawError]=true;this.close();this.emit(\"error\",err)};this[_handle].on(\"error\",er=>this[_onError](new ZlibError(er)));this.once(\"end\",()=>this.close)}close(){if(this[_handle]){this[_handle].close();this[_handle]=null;this.emit(\"close\")}}reset(){if(!this[_sawError]){assert(this[_handle],\"zlib binding closed\");return this[_handle].reset()}}flush(flushFlag){if(this.ended)return;if(typeof flushFlag!==\"number\")flushFlag=this[_fullFlushFlag];this.write(Object.assign(Buffer2.alloc(0),{[_flushFlag]:flushFlag}))}end(chunk,encoding,cb){if(chunk)this.write(chunk,encoding);this.flush(this[_finishFlushFlag]);this[_ended]=true;return super.end(null,null,cb)}get ended(){return this[_ended]}write(chunk,encoding,cb){if(typeof encoding===\"function\")cb=encoding,encoding=\"utf8\";if(typeof chunk===\"string\")chunk=Buffer2.from(chunk,encoding);if(this[_sawError])return;assert(this[_handle],\"zlib binding closed\");const nativeHandle=this[_handle]._handle;const originalNativeClose=nativeHandle.close;nativeHandle.close=()=>{};const originalClose=this[_handle].close;this[_handle].close=()=>{};Buffer2.concat=args=>args;let result;try{const flushFlag=typeof chunk[_flushFlag]===\"number\"?chunk[_flushFlag]:this[_flushFlag];result=this[_handle]._processChunk(chunk,flushFlag);Buffer2.concat=OriginalBufferConcat}catch(err){Buffer2.concat=OriginalBufferConcat;this[_onError](new ZlibError(err))}finally{if(this[_handle]){this[_handle]._handle=nativeHandle;nativeHandle.close=originalNativeClose;this[_handle].close=originalClose;this[_handle].removeAllListeners(\"error\")}}if(this[_handle])this[_handle].on(\"error\",er=>this[_onError](new ZlibError(er)));let writeReturn;if(result){if(Array.isArray(result)&&result.length>0){writeReturn=this[_superWrite](Buffer2.from(result[0]));for(let i=1;i<result.length;i++){writeReturn=this[_superWrite](result[i])}}else{writeReturn=this[_superWrite](Buffer2.from(result))}}if(cb)cb();return writeReturn}[_superWrite](data){return super.write(data)}}class Zlib extends ZlibBase{static{__name(this,\"Zlib\")}constructor(opts,mode){opts=opts||{};opts.flush=opts.flush||constants.Z_NO_FLUSH;opts.finishFlush=opts.finishFlush||constants.Z_FINISH;super(opts,mode);this[_fullFlushFlag]=constants.Z_FULL_FLUSH;this[_level]=opts.level;this[_strategy]=opts.strategy}params(level,strategy){if(this[_sawError])return;if(!this[_handle])throw new Error(\"cannot switch params when binding is closed\");if(!this[_handle].params)throw new Error(\"not supported in this implementation\");if(this[_level]!==level||this[_strategy]!==strategy){this.flush(constants.Z_SYNC_FLUSH);assert(this[_handle],\"zlib binding closed\");const origFlush=this[_handle].flush;this[_handle].flush=(flushFlag,cb)=>{this.flush(flushFlag);cb()};try{this[_handle].params(level,strategy)}finally{this[_handle].flush=origFlush}if(this[_handle]){this[_level]=level;this[_strategy]=strategy}}}}class Deflate extends Zlib{static{__name(this,\"Deflate\")}constructor(opts){super(opts,\"Deflate\")}}class Inflate extends Zlib{static{__name(this,\"Inflate\")}constructor(opts){super(opts,\"Inflate\")}}const _portable=Symbol(\"_portable\");class Gzip extends Zlib{static{__name(this,\"Gzip\")}constructor(opts){super(opts,\"Gzip\");this[_portable]=opts&&!!opts.portable}[_superWrite](data){if(!this[_portable])return super[_superWrite](data);this[_portable]=false;data[9]=255;return super[_superWrite](data)}}class Gunzip extends Zlib{static{__name(this,\"Gunzip\")}constructor(opts){super(opts,\"Gunzip\")}}class DeflateRaw extends Zlib{static{__name(this,\"DeflateRaw\")}constructor(opts){super(opts,\"DeflateRaw\")}}class InflateRaw extends Zlib{static{__name(this,\"InflateRaw\")}constructor(opts){super(opts,\"InflateRaw\")}}class Unzip extends Zlib{static{__name(this,\"Unzip\")}constructor(opts){super(opts,\"Unzip\")}}class Brotli extends ZlibBase{static{__name(this,\"Brotli\")}constructor(opts,mode){opts=opts||{};opts.flush=opts.flush||constants.BROTLI_OPERATION_PROCESS;opts.finishFlush=opts.finishFlush||constants.BROTLI_OPERATION_FINISH;super(opts,mode);this[_fullFlushFlag]=constants.BROTLI_OPERATION_FLUSH}}class BrotliCompress extends Brotli{static{__name(this,\"BrotliCompress\")}constructor(opts){super(opts,\"BrotliCompress\")}}class BrotliDecompress extends Brotli{static{__name(this,\"BrotliDecompress\")}constructor(opts){super(opts,\"BrotliDecompress\")}}exports.Deflate=Deflate;exports.Inflate=Inflate;exports.Gzip=Gzip;exports.Gunzip=Gunzip;exports.DeflateRaw=DeflateRaw;exports.InflateRaw=InflateRaw;exports.Unzip=Unzip;if(typeof realZlib.BrotliCompress===\"function\"){exports.BrotliCompress=BrotliCompress;exports.BrotliDecompress=BrotliDecompress}else{exports.BrotliCompress=exports.BrotliDecompress=class{constructor(){throw new Error(\"Brotli is not supported in this version of Node.js\")}}}\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["Buffer"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/minizlib@2.1.2/node_modules/minizlib/index.js"],"sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst Buffer = require('buffer').Buffer\nconst realZlib = require('zlib')\n\nconst constants = exports.constants = require('./constants.js')\nconst Minipass = require('minipass')\n\nconst OriginalBufferConcat = Buffer.concat\n\nconst _superWrite = Symbol('_superWrite')\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_sawError] = false\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this[_sawError])\n        return\n\n      this[_sawError] = true\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n        // make sure OUR error listener is still attached tho\n      }\n    }\n\n    if (this[_handle])\n      this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i])\n        }\n      } else {\n        writeReturn = this[_superWrite](Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n\n  [_superWrite] (data) {\n    return super.write(data)\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nconst _portable = Symbol('_portable')\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n    this[_portable] = opts && !!opts.portable\n  }\n\n  [_superWrite] (data) {\n    if (!this[_portable])\n      return super[_superWrite](data)\n\n    // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n    this[_portable] = false\n    data[9] = 255\n    return super[_superWrite](data)\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n"]}}