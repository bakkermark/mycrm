{"code":"(()=>{\n\"use strict\";const{visitSkip,detachNodeFromParent}=require(\"../lib/xast.js\");exports.name=\"mergeStyles\";exports.description=\"merge multiple style elements into one\";exports.fn=()=>{let firstStyleElement=null;let collectedStyles=\"\";let styleContentType=\"text\";return{element:{enter:(node,parentNode)=>{if(node.name===\"foreignObject\"){return visitSkip}if(node.name!==\"style\"){return}if(node.attributes.type!=null&&node.attributes.type!==\"\"&&node.attributes.type!==\"text/css\"){return}let css=\"\";for(const child of node.children){if(child.type===\"text\"){css+=child.value}if(child.type===\"cdata\"){styleContentType=\"cdata\";css+=child.value}}if(css.trim().length===0){detachNodeFromParent(node,parentNode);return}if(node.attributes.media==null){collectedStyles+=css}else{collectedStyles+=`@media ${node.attributes.media}{${css}}`;delete node.attributes.media}if(firstStyleElement==null){firstStyleElement=node}else{detachNodeFromParent(node,parentNode);const child={type:styleContentType,value:collectedStyles};Object.defineProperty(child,\"parentNode\",{writable:true,value:firstStyleElement});firstStyleElement.children=[child]}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":";aAOA,KAAM,CAAE,UAAW,oBAAqB,EAAI,QAAQ,gBAAgB,EAEpE,QAAQ,KAAO,cACf,QAAQ,YAAc,yCAStB,QAAQ,GAAK,IAAM,CAIjB,IAAI,kBAAoB,KACxB,IAAI,gBAAkB,GAItB,IAAI,iBAAmB,OAEvB,MAAO,CACL,QAAS,CACP,MAAO,CAAC,KAAM,aAAe,CAE3B,GAAI,KAAK,OAAS,gBAAiB,CACjC,OAAO,SACT,CAGA,GAAI,KAAK,OAAS,QAAS,CACzB,MACF,CAGA,GACE,KAAK,WAAW,MAAQ,MACxB,KAAK,WAAW,OAAS,IACzB,KAAK,WAAW,OAAS,WACzB,CACA,MACF,CAGA,IAAI,IAAM,GACV,UAAW,SAAS,KAAK,SAAU,CACjC,GAAI,MAAM,OAAS,OAAQ,CACzB,KAAO,MAAM,KACf,CACA,GAAI,MAAM,OAAS,QAAS,CAC1B,iBAAmB,QACnB,KAAO,MAAM,KACf,CACF,CAGA,GAAI,IAAI,KAAK,EAAE,SAAW,EAAG,CAC3B,qBAAqB,KAAM,UAAU,EACrC,MACF,CAGA,GAAI,KAAK,WAAW,OAAS,KAAM,CACjC,iBAAmB,GACrB,KAAO,CACL,iBAAmB,UAAU,KAAK,WAAW,KAAK,IAAI,GAAG,IACzD,OAAO,KAAK,WAAW,KACzB,CAGA,GAAI,mBAAqB,KAAM,CAC7B,kBAAoB,IACtB,KAAO,CACL,qBAAqB,KAAM,UAAU,EAIrC,MAAM,MAAQ,CAAE,KAAM,iBAAkB,MAAO,eAAgB,EAE/D,OAAO,eAAe,MAAO,aAAc,CACzC,SAAU,KACV,MAAO,iBACT,CAAC,EACD,kBAAkB,SAAW,CAAC,KAAK,CACrC,CACF,CACF,CACF,CACF","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/mergeStyles.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastChild} XastChild\n */\n\nconst { visitSkip, detachNodeFromParent } = require('../lib/xast.js');\n\nexports.name = 'mergeStyles';\nexports.description = 'merge multiple style elements into one';\n\n/**\n * Merge multiple style elements into one.\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('./plugins-types').Plugin<'mergeStyles'>}\n */\nexports.fn = () => {\n  /**\n   * @type {?XastElement}\n   */\n  let firstStyleElement = null;\n  let collectedStyles = '';\n  /**\n   * @type {'text' | 'cdata'}\n   */\n  let styleContentType = 'text';\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip <foreignObject> content\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n\n        // collect style elements\n        if (node.name !== 'style') {\n          return;\n        }\n\n        // skip <style> with invalid type attribute\n        if (\n          node.attributes.type != null &&\n          node.attributes.type !== '' &&\n          node.attributes.type !== 'text/css'\n        ) {\n          return;\n        }\n\n        // extract style element content\n        let css = '';\n        for (const child of node.children) {\n          if (child.type === 'text') {\n            css += child.value;\n          }\n          if (child.type === 'cdata') {\n            styleContentType = 'cdata';\n            css += child.value;\n          }\n        }\n\n        // remove empty style elements\n        if (css.trim().length === 0) {\n          detachNodeFromParent(node, parentNode);\n          return;\n        }\n\n        // collect css and wrap with media query if present in attribute\n        if (node.attributes.media == null) {\n          collectedStyles += css;\n        } else {\n          collectedStyles += `@media ${node.attributes.media}{${css}}`;\n          delete node.attributes.media;\n        }\n\n        // combine collected styles in the first style element\n        if (firstStyleElement == null) {\n          firstStyleElement = node;\n        } else {\n          detachNodeFromParent(node, parentNode);\n          /**\n           * @type {XastChild}\n           */\n          const child = { type: styleContentType, value: collectedStyles };\n          // TODO remove legacy parentNode in v4\n          Object.defineProperty(child, 'parentNode', {\n            writable: true,\n            value: firstStyleElement,\n          });\n          firstStyleElement.children = [child];\n        }\n      },\n    },\n  };\n};\n"]}}