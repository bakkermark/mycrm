{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"assert\");const normalize=require(\"./normalize-unicode.js\");const stripSlashes=require(\"./strip-trailing-slashes.js\");const{join}=require(\"path\");const platform=process.env.TESTING_TAR_FAKE_PLATFORM||process.platform;const isWindows=platform===\"win32\";module.exports=()=>{const queues=new Map;const reservations=new Map;const getDirs=__name(path=>{const dirs=path.split(\"/\").slice(0,-1).reduce((set,path2)=>{if(set.length){path2=join(set[set.length-1],path2)}set.push(path2||\"/\");return set},[]);return dirs},\"getDirs\");const running=new Set;const getQueues=__name(fn=>{const res=reservations.get(fn);if(!res){throw new Error(\"function does not have any path reservations\")}return{paths:res.paths.map(path=>queues.get(path)),dirs:[...res.dirs].map(path=>queues.get(path))}},\"getQueues\");const check=__name(fn=>{const{paths,dirs}=getQueues(fn);return paths.every(q=>q[0]===fn)&&dirs.every(q=>q[0]instanceof Set&&q[0].has(fn))},\"check\");const run=__name(fn=>{if(running.has(fn)||!check(fn)){return false}running.add(fn);fn(()=>clear(fn));return true},\"run\");const clear=__name(fn=>{if(!running.has(fn)){return false}const{paths,dirs}=reservations.get(fn);const next=new Set;paths.forEach(path=>{const q=queues.get(path);assert.equal(q[0],fn);if(q.length===1){queues.delete(path)}else{q.shift();if(typeof q[0]===\"function\"){next.add(q[0])}else{q[0].forEach(fn2=>next.add(fn2))}}});dirs.forEach(dir=>{const q=queues.get(dir);assert(q[0]instanceof Set);if(q[0].size===1&&q.length===1){queues.delete(dir)}else if(q[0].size===1){q.shift();next.add(q[0])}else{q[0].delete(fn)}});running.delete(fn);next.forEach(fn2=>run(fn2));return true},\"clear\");const reserve=__name((paths,fn)=>{paths=isWindows?[\"win32 parallelization disabled\"]:paths.map(p=>{return stripSlashes(join(normalize(p))).toLowerCase()});const dirs=new Set(paths.map(path=>getDirs(path)).reduce((a,b)=>a.concat(b)));reservations.set(fn,{dirs,paths});paths.forEach(path=>{const q=queues.get(path);if(!q){queues.set(path,[fn])}else{q.push(fn)}});dirs.forEach(dir=>{const q=queues.get(dir);if(!q){queues.set(dir,[new Set([fn])])}else if(q[q.length-1]instanceof Set){q[q.length-1].add(fn)}else{q.push(new Set([fn]))}});return run(fn)},\"reserve\");return{check,reserve}};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["path","fn"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/path-reservations.js"],"sourcesContent":["// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = require('assert')\nconst normalize = require('./normalize-unicode.js')\nconst stripSlashes = require('./strip-trailing-slashes.js')\nconst { join } = require('path')\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  const getDirs = path => {\n    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {\n      if (set.length) {\n        path = join(set[set.length - 1], path)\n      }\n      set.push(path || '/')\n      return set\n    }, [])\n    return dirs\n  }\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res) {\n      throw new Error('function does not have any path reservations')\n    }\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const { paths, dirs } = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn)) {\n      return false\n    }\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn)) {\n      return false\n    }\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1) {\n        queues.delete(path)\n      } else {\n        q.shift()\n        if (typeof q[0] === 'function') {\n          next.add(q[0])\n        } else {\n          q[0].forEach(fn => next.add(fn))\n        }\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir)\n      } else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else {\n        q[0].delete(fn)\n      }\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {\n      // don't need normPath, because we skip this entirely for windows\n      return stripSlashes(join(normalize(p))).toLowerCase()\n    })\n\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, { dirs, paths })\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q) {\n        queues.set(path, [fn])\n      } else {\n        q.push(fn)\n      }\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q) {\n        queues.set(dir, [new Set([fn])])\n      } else if (q[q.length - 1] instanceof Set) {\n        q[q.length - 1].add(fn)\n      } else {\n        q.push(new Set([fn]))\n      }\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n"]}}