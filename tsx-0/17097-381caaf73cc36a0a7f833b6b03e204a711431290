{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const MiniPass=require(\"minipass\");const EE=require(\"events\").EventEmitter;const fs=require(\"fs\");let writev=fs.writev;if(!writev){const binding=process.binding(\"fs\");const FSReqWrap=binding.FSReqWrap||binding.FSReqCallback;writev=__name((fd,iovec,pos,cb)=>{const done=__name((er,bw)=>cb(er,bw,iovec),\"done\");const req=new FSReqWrap;req.oncomplete=done;binding.writeBuffers(fd,iovec,pos,req)},\"writev\")}const _autoClose=Symbol(\"_autoClose\");const _close=Symbol(\"_close\");const _ended=Symbol(\"_ended\");const _fd=Symbol(\"_fd\");const _finished=Symbol(\"_finished\");const _flags=Symbol(\"_flags\");const _flush=Symbol(\"_flush\");const _handleChunk=Symbol(\"_handleChunk\");const _makeBuf=Symbol(\"_makeBuf\");const _mode=Symbol(\"_mode\");const _needDrain=Symbol(\"_needDrain\");const _onerror=Symbol(\"_onerror\");const _onopen=Symbol(\"_onopen\");const _onread=Symbol(\"_onread\");const _onwrite=Symbol(\"_onwrite\");const _open=Symbol(\"_open\");const _path=Symbol(\"_path\");const _pos=Symbol(\"_pos\");const _queue=Symbol(\"_queue\");const _read=Symbol(\"_read\");const _readSize=Symbol(\"_readSize\");const _reading=Symbol(\"_reading\");const _remain=Symbol(\"_remain\");const _size=Symbol(\"_size\");const _write=Symbol(\"_write\");const _writing=Symbol(\"_writing\");const _defaultFlag=Symbol(\"_defaultFlag\");const _errored=Symbol(\"_errored\");class ReadStream extends MiniPass{static{__name(this,\"ReadStream\")}constructor(path,opt){opt=opt||{};super(opt);this.readable=true;this.writable=false;if(typeof path!==\"string\")throw new TypeError(\"path must be a string\");this[_errored]=false;this[_fd]=typeof opt.fd===\"number\"?opt.fd:null;this[_path]=path;this[_readSize]=opt.readSize||16*1024*1024;this[_reading]=false;this[_size]=typeof opt.size===\"number\"?opt.size:Infinity;this[_remain]=this[_size];this[_autoClose]=typeof opt.autoClose===\"boolean\"?opt.autoClose:true;if(typeof this[_fd]===\"number\")this[_read]();else this[_open]()}get fd(){return this[_fd]}get path(){return this[_path]}write(){throw new TypeError(\"this is a readable stream\")}end(){throw new TypeError(\"this is a readable stream\")}[_open](){fs.open(this[_path],\"r\",(er,fd)=>this[_onopen](er,fd))}[_onopen](er,fd){if(er)this[_onerror](er);else{this[_fd]=fd;this.emit(\"open\",fd);this[_read]()}}[_makeBuf](){return Buffer.allocUnsafe(Math.min(this[_readSize],this[_remain]))}[_read](){if(!this[_reading]){this[_reading]=true;const buf=this[_makeBuf]();if(buf.length===0)return process.nextTick(()=>this[_onread](null,0,buf));fs.read(this[_fd],buf,0,buf.length,null,(er,br,buf2)=>this[_onread](er,br,buf2))}}[_onread](er,br,buf){this[_reading]=false;if(er)this[_onerror](er);else if(this[_handleChunk](br,buf))this[_read]()}[_close](){if(this[_autoClose]&&typeof this[_fd]===\"number\"){const fd=this[_fd];this[_fd]=null;fs.close(fd,er=>er?this.emit(\"error\",er):this.emit(\"close\"))}}[_onerror](er){this[_reading]=true;this[_close]();this.emit(\"error\",er)}[_handleChunk](br,buf){let ret=false;this[_remain]-=br;if(br>0)ret=super.write(br<buf.length?buf.slice(0,br):buf);if(br===0||this[_remain]<=0){ret=false;this[_close]();super.end()}return ret}emit(ev,data){switch(ev){case\"prefinish\":case\"finish\":break;case\"drain\":if(typeof this[_fd]===\"number\")this[_read]();break;case\"error\":if(this[_errored])return;this[_errored]=true;return super.emit(ev,data);default:return super.emit(ev,data)}}}class ReadStreamSync extends ReadStream{static{__name(this,\"ReadStreamSync\")}[_open](){let threw=true;try{this[_onopen](null,fs.openSync(this[_path],\"r\"));threw=false}finally{if(threw)this[_close]()}}[_read](){let threw=true;try{if(!this[_reading]){this[_reading]=true;do{const buf=this[_makeBuf]();const br=buf.length===0?0:fs.readSync(this[_fd],buf,0,buf.length,null);if(!this[_handleChunk](br,buf))break}while(true);this[_reading]=false}threw=false}finally{if(threw)this[_close]()}}[_close](){if(this[_autoClose]&&typeof this[_fd]===\"number\"){const fd=this[_fd];this[_fd]=null;fs.closeSync(fd);this.emit(\"close\")}}}class WriteStream extends EE{static{__name(this,\"WriteStream\")}constructor(path,opt){opt=opt||{};super(opt);this.readable=false;this.writable=true;this[_errored]=false;this[_writing]=false;this[_ended]=false;this[_needDrain]=false;this[_queue]=[];this[_path]=path;this[_fd]=typeof opt.fd===\"number\"?opt.fd:null;this[_mode]=opt.mode===void 0?438:opt.mode;this[_pos]=typeof opt.start===\"number\"?opt.start:null;this[_autoClose]=typeof opt.autoClose===\"boolean\"?opt.autoClose:true;const defaultFlag=this[_pos]!==null?\"r+\":\"w\";this[_defaultFlag]=opt.flags===void 0;this[_flags]=this[_defaultFlag]?defaultFlag:opt.flags;if(this[_fd]===null)this[_open]()}emit(ev,data){if(ev===\"error\"){if(this[_errored])return;this[_errored]=true}return super.emit(ev,data)}get fd(){return this[_fd]}get path(){return this[_path]}[_onerror](er){this[_close]();this[_writing]=true;this.emit(\"error\",er)}[_open](){fs.open(this[_path],this[_flags],this[_mode],(er,fd)=>this[_onopen](er,fd))}[_onopen](er,fd){if(this[_defaultFlag]&&this[_flags]===\"r+\"&&er&&er.code===\"ENOENT\"){this[_flags]=\"w\";this[_open]()}else if(er)this[_onerror](er);else{this[_fd]=fd;this.emit(\"open\",fd);this[_flush]()}}end(buf,enc){if(buf)this.write(buf,enc);this[_ended]=true;if(!this[_writing]&&!this[_queue].length&&typeof this[_fd]===\"number\")this[_onwrite](null,0);return this}write(buf,enc){if(typeof buf===\"string\")buf=Buffer.from(buf,enc);if(this[_ended]){this.emit(\"error\",new Error(\"write() after end()\"));return false}if(this[_fd]===null||this[_writing]||this[_queue].length){this[_queue].push(buf);this[_needDrain]=true;return false}this[_writing]=true;this[_write](buf);return true}[_write](buf){fs.write(this[_fd],buf,0,buf.length,this[_pos],(er,bw)=>this[_onwrite](er,bw))}[_onwrite](er,bw){if(er)this[_onerror](er);else{if(this[_pos]!==null)this[_pos]+=bw;if(this[_queue].length)this[_flush]();else{this[_writing]=false;if(this[_ended]&&!this[_finished]){this[_finished]=true;this[_close]();this.emit(\"finish\")}else if(this[_needDrain]){this[_needDrain]=false;this.emit(\"drain\")}}}}[_flush](){if(this[_queue].length===0){if(this[_ended])this[_onwrite](null,0)}else if(this[_queue].length===1)this[_write](this[_queue].pop());else{const iovec=this[_queue];this[_queue]=[];writev(this[_fd],iovec,this[_pos],(er,bw)=>this[_onwrite](er,bw))}}[_close](){if(this[_autoClose]&&typeof this[_fd]===\"number\"){const fd=this[_fd];this[_fd]=null;fs.close(fd,er=>er?this.emit(\"error\",er):this.emit(\"close\"))}}}class WriteStreamSync extends WriteStream{static{__name(this,\"WriteStreamSync\")}[_open](){let fd;if(this[_defaultFlag]&&this[_flags]===\"r+\"){try{fd=fs.openSync(this[_path],this[_flags],this[_mode])}catch(er){if(er.code===\"ENOENT\"){this[_flags]=\"w\";return this[_open]()}else throw er}}else fd=fs.openSync(this[_path],this[_flags],this[_mode]);this[_onopen](null,fd)}[_close](){if(this[_autoClose]&&typeof this[_fd]===\"number\"){const fd=this[_fd];this[_fd]=null;fs.closeSync(fd);this.emit(\"close\")}}[_write](buf){let threw=true;try{this[_onwrite](null,fs.writeSync(this[_fd],buf,0,buf.length,this[_pos]));threw=false}finally{if(threw)try{this[_close]()}catch(_){}}}}exports.ReadStream=ReadStream;exports.ReadStreamSync=ReadStreamSync;exports.WriteStream=WriteStream;exports.WriteStreamSync=WriteStreamSync;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,MAAM,SAAW,QAAQ,UAAU,EACnC,MAAM,GAAK,QAAQ,QAAQ,EAAE,aAC7B,MAAM,GAAK,QAAQ,IAAI,EAEvB,IAAI,OAAS,GAAG,OAEhB,GAAI,CAAC,OAAQ,CAGX,MAAM,QAAU,QAAQ,QAAQ,IAAI,EACpC,MAAM,UAAY,QAAQ,WAAa,QAAQ,cAE/C,OAAS,QAAC,GAAI,MAAO,IAAK,KAAO,CAC/B,MAAM,KAAO,QAAC,GAAI,KAAO,GAAG,GAAI,GAAI,KAAK,EAA5B,QACb,MAAM,IAAM,IAAI,UAChB,IAAI,WAAa,KACjB,QAAQ,aAAa,GAAI,MAAO,IAAK,GAAG,CAC1C,EALS,SAMX,CAEA,MAAM,WAAa,OAAO,YAAY,EACtC,MAAM,OAAS,OAAO,QAAQ,EAC9B,MAAM,OAAS,OAAO,QAAQ,EAC9B,MAAM,IAAM,OAAO,KAAK,EACxB,MAAM,UAAY,OAAO,WAAW,EACpC,MAAM,OAAS,OAAO,QAAQ,EAC9B,MAAM,OAAS,OAAO,QAAQ,EAC9B,MAAM,aAAe,OAAO,cAAc,EAC1C,MAAM,SAAW,OAAO,UAAU,EAClC,MAAM,MAAQ,OAAO,OAAO,EAC5B,MAAM,WAAa,OAAO,YAAY,EACtC,MAAM,SAAW,OAAO,UAAU,EAClC,MAAM,QAAU,OAAO,SAAS,EAChC,MAAM,QAAU,OAAO,SAAS,EAChC,MAAM,SAAW,OAAO,UAAU,EAClC,MAAM,MAAQ,OAAO,OAAO,EAC5B,MAAM,MAAQ,OAAO,OAAO,EAC5B,MAAM,KAAO,OAAO,MAAM,EAC1B,MAAM,OAAS,OAAO,QAAQ,EAC9B,MAAM,MAAQ,OAAO,OAAO,EAC5B,MAAM,UAAY,OAAO,WAAW,EACpC,MAAM,SAAW,OAAO,UAAU,EAClC,MAAM,QAAU,OAAO,SAAS,EAChC,MAAM,MAAQ,OAAO,OAAO,EAC5B,MAAM,OAAS,OAAO,QAAQ,EAC9B,MAAM,SAAW,OAAO,UAAU,EAClC,MAAM,aAAe,OAAO,cAAc,EAC1C,MAAM,SAAW,OAAO,UAAU,EAElC,MAAM,mBAAmB,QAAS,CAlDlC,MAkDkC,2BAChC,YAAa,KAAM,IAAK,CACtB,IAAM,KAAO,CAAC,EACd,MAAM,GAAG,EAET,KAAK,SAAW,KAChB,KAAK,SAAW,MAEhB,GAAI,OAAO,OAAS,SAClB,MAAM,IAAI,UAAU,uBAAuB,EAE7C,KAAK,QAAQ,EAAI,MACjB,KAAK,GAAG,EAAI,OAAO,IAAI,KAAO,SAAW,IAAI,GAAK,KAClD,KAAK,KAAK,EAAI,KACd,KAAK,SAAS,EAAI,IAAI,UAAY,GAAG,KAAK,KAC1C,KAAK,QAAQ,EAAI,MACjB,KAAK,KAAK,EAAI,OAAO,IAAI,OAAS,SAAW,IAAI,KAAO,SACxD,KAAK,OAAO,EAAI,KAAK,KAAK,EAC1B,KAAK,UAAU,EAAI,OAAO,IAAI,YAAc,UAC1C,IAAI,UAAY,KAElB,GAAI,OAAO,KAAK,GAAG,IAAM,SACvB,KAAK,KAAK,EAAE,OAEZ,KAAK,KAAK,EAAE,CAChB,CAEA,IAAI,IAAM,CAAE,OAAO,KAAK,GAAG,CAAE,CAC7B,IAAI,MAAQ,CAAE,OAAO,KAAK,KAAK,CAAE,CAEjC,OAAS,CACP,MAAM,IAAI,UAAU,2BAA2B,CACjD,CAEA,KAAO,CACL,MAAM,IAAI,UAAU,2BAA2B,CACjD,CAEA,CAAC,KAAK,GAAK,CACT,GAAG,KAAK,KAAK,KAAK,EAAG,IAAK,CAAC,GAAI,KAAO,KAAK,OAAO,EAAE,GAAI,EAAE,CAAC,CAC7D,CAEA,CAAC,OAAO,EAAG,GAAI,GAAI,CACjB,GAAI,GACF,KAAK,QAAQ,EAAE,EAAE,MACd,CACH,KAAK,GAAG,EAAI,GACZ,KAAK,KAAK,OAAQ,EAAE,EACpB,KAAK,KAAK,EAAE,CACd,CACF,CAEA,CAAC,QAAQ,GAAK,CACZ,OAAO,OAAO,YAAY,KAAK,IAAI,KAAK,SAAS,EAAG,KAAK,OAAO,CAAC,CAAC,CACpE,CAEA,CAAC,KAAK,GAAK,CACT,GAAI,CAAC,KAAK,QAAQ,EAAG,CACnB,KAAK,QAAQ,EAAI,KACjB,MAAM,IAAM,KAAK,QAAQ,EAAE,EAE3B,GAAI,IAAI,SAAW,EACjB,OAAO,QAAQ,SAAS,IAAM,KAAK,OAAO,EAAE,KAAM,EAAG,GAAG,CAAC,EAC3D,GAAG,KAAK,KAAK,GAAG,EAAG,IAAK,EAAG,IAAI,OAAQ,KAAM,CAAC,GAAI,GAAIA,OACpD,KAAK,OAAO,EAAE,GAAI,GAAIA,IAAG,CAAC,CAC9B,CACF,CAEA,CAAC,OAAO,EAAG,GAAI,GAAI,IAAK,CACtB,KAAK,QAAQ,EAAI,MACjB,GAAI,GACF,KAAK,QAAQ,EAAE,EAAE,UACV,KAAK,YAAY,EAAE,GAAI,GAAG,EACjC,KAAK,KAAK,EAAE,CAChB,CAEA,CAAC,MAAM,GAAK,CACV,GAAI,KAAK,UAAU,GAAK,OAAO,KAAK,GAAG,IAAM,SAAU,CACrD,MAAM,GAAK,KAAK,GAAG,EACnB,KAAK,GAAG,EAAI,KACZ,GAAG,MAAM,GAAI,IAAM,GAAK,KAAK,KAAK,QAAS,EAAE,EAAI,KAAK,KAAK,OAAO,CAAC,CACrE,CACF,CAEA,CAAC,QAAQ,EAAG,GAAI,CACd,KAAK,QAAQ,EAAI,KACjB,KAAK,MAAM,EAAE,EACb,KAAK,KAAK,QAAS,EAAE,CACvB,CAEA,CAAC,YAAY,EAAG,GAAI,IAAK,CACvB,IAAI,IAAM,MAEV,KAAK,OAAO,GAAK,GACjB,GAAI,GAAK,EACP,IAAM,MAAM,MAAM,GAAK,IAAI,OAAS,IAAI,MAAM,EAAG,EAAE,EAAI,GAAG,EAE5D,GAAI,KAAO,GAAK,KAAK,OAAO,GAAK,EAAG,CAClC,IAAM,MACN,KAAK,MAAM,EAAE,EACb,MAAM,IAAI,CACZ,CAEA,OAAO,GACT,CAEA,KAAM,GAAI,KAAM,CACd,OAAQ,GAAI,CACV,IAAK,YACL,IAAK,SACH,MAEF,IAAK,QACH,GAAI,OAAO,KAAK,GAAG,IAAM,SACvB,KAAK,KAAK,EAAE,EACd,MAEF,IAAK,QACH,GAAI,KAAK,QAAQ,EACf,OACF,KAAK,QAAQ,EAAI,KACjB,OAAO,MAAM,KAAK,GAAI,IAAI,EAE5B,QACE,OAAO,MAAM,KAAK,GAAI,IAAI,CAC9B,CACF,CACF,CAEA,MAAM,uBAAuB,UAAW,CAnLxC,MAmLwC,+BACtC,CAAC,KAAK,GAAK,CACT,IAAI,MAAQ,KACZ,GAAI,CACF,KAAK,OAAO,EAAE,KAAM,GAAG,SAAS,KAAK,KAAK,EAAG,GAAG,CAAC,EACjD,MAAQ,KACV,QAAE,CACA,GAAI,MACF,KAAK,MAAM,EAAE,CACjB,CACF,CAEA,CAAC,KAAK,GAAK,CACT,IAAI,MAAQ,KACZ,GAAI,CACF,GAAI,CAAC,KAAK,QAAQ,EAAG,CACnB,KAAK,QAAQ,EAAI,KACjB,EAAG,CACD,MAAM,IAAM,KAAK,QAAQ,EAAE,EAE3B,MAAM,GAAK,IAAI,SAAW,EAAI,EAC1B,GAAG,SAAS,KAAK,GAAG,EAAG,IAAK,EAAG,IAAI,OAAQ,IAAI,EACnD,GAAI,CAAC,KAAK,YAAY,EAAE,GAAI,GAAG,EAC7B,KACJ,OAAS,MACT,KAAK,QAAQ,EAAI,KACnB,CACA,MAAQ,KACV,QAAE,CACA,GAAI,MACF,KAAK,MAAM,EAAE,CACjB,CACF,CAEA,CAAC,MAAM,GAAK,CACV,GAAI,KAAK,UAAU,GAAK,OAAO,KAAK,GAAG,IAAM,SAAU,CACrD,MAAM,GAAK,KAAK,GAAG,EACnB,KAAK,GAAG,EAAI,KACZ,GAAG,UAAU,EAAE,EACf,KAAK,KAAK,OAAO,CACnB,CACF,CACF,CAEA,MAAM,oBAAoB,EAAG,CA/N7B,MA+N6B,4BAC3B,YAAa,KAAM,IAAK,CACtB,IAAM,KAAO,CAAC,EACd,MAAM,GAAG,EACT,KAAK,SAAW,MAChB,KAAK,SAAW,KAChB,KAAK,QAAQ,EAAI,MACjB,KAAK,QAAQ,EAAI,MACjB,KAAK,MAAM,EAAI,MACf,KAAK,UAAU,EAAI,MACnB,KAAK,MAAM,EAAI,CAAC,EAChB,KAAK,KAAK,EAAI,KACd,KAAK,GAAG,EAAI,OAAO,IAAI,KAAO,SAAW,IAAI,GAAK,KAClD,KAAK,KAAK,EAAI,IAAI,OAAS,OAAY,IAAQ,IAAI,KACnD,KAAK,IAAI,EAAI,OAAO,IAAI,QAAU,SAAW,IAAI,MAAQ,KACzD,KAAK,UAAU,EAAI,OAAO,IAAI,YAAc,UAC1C,IAAI,UAAY,KAGlB,MAAM,YAAc,KAAK,IAAI,IAAM,KAAO,KAAO,IACjD,KAAK,YAAY,EAAI,IAAI,QAAU,OACnC,KAAK,MAAM,EAAI,KAAK,YAAY,EAAI,YAAc,IAAI,MAEtD,GAAI,KAAK,GAAG,IAAM,KAChB,KAAK,KAAK,EAAE,CAChB,CAEA,KAAM,GAAI,KAAM,CACd,GAAI,KAAO,QAAS,CAClB,GAAI,KAAK,QAAQ,EACf,OACF,KAAK,QAAQ,EAAI,IACnB,CACA,OAAO,MAAM,KAAK,GAAI,IAAI,CAC5B,CAGA,IAAI,IAAM,CAAE,OAAO,KAAK,GAAG,CAAE,CAC7B,IAAI,MAAQ,CAAE,OAAO,KAAK,KAAK,CAAE,CAEjC,CAAC,QAAQ,EAAG,GAAI,CACd,KAAK,MAAM,EAAE,EACb,KAAK,QAAQ,EAAI,KACjB,KAAK,KAAK,QAAS,EAAE,CACvB,CAEA,CAAC,KAAK,GAAK,CACT,GAAG,KAAK,KAAK,KAAK,EAAG,KAAK,MAAM,EAAG,KAAK,KAAK,EAC3C,CAAC,GAAI,KAAO,KAAK,OAAO,EAAE,GAAI,EAAE,CAAC,CACrC,CAEA,CAAC,OAAO,EAAG,GAAI,GAAI,CACjB,GAAI,KAAK,YAAY,GACjB,KAAK,MAAM,IAAM,MACjB,IAAM,GAAG,OAAS,SAAU,CAC9B,KAAK,MAAM,EAAI,IACf,KAAK,KAAK,EAAE,CACd,SAAW,GACT,KAAK,QAAQ,EAAE,EAAE,MACd,CACH,KAAK,GAAG,EAAI,GACZ,KAAK,KAAK,OAAQ,EAAE,EACpB,KAAK,MAAM,EAAE,CACf,CACF,CAEA,IAAK,IAAK,IAAK,CACb,GAAI,IACF,KAAK,MAAM,IAAK,GAAG,EAErB,KAAK,MAAM,EAAI,KAGf,GAAI,CAAC,KAAK,QAAQ,GAAK,CAAC,KAAK,MAAM,EAAE,QACjC,OAAO,KAAK,GAAG,IAAM,SACvB,KAAK,QAAQ,EAAE,KAAM,CAAC,EACxB,OAAO,IACT,CAEA,MAAO,IAAK,IAAK,CACf,GAAI,OAAO,MAAQ,SACjB,IAAM,OAAO,KAAK,IAAK,GAAG,EAE5B,GAAI,KAAK,MAAM,EAAG,CAChB,KAAK,KAAK,QAAS,IAAI,MAAM,qBAAqB,CAAC,EACnD,MAAO,MACT,CAEA,GAAI,KAAK,GAAG,IAAM,MAAQ,KAAK,QAAQ,GAAK,KAAK,MAAM,EAAE,OAAQ,CAC/D,KAAK,MAAM,EAAE,KAAK,GAAG,EACrB,KAAK,UAAU,EAAI,KACnB,MAAO,MACT,CAEA,KAAK,QAAQ,EAAI,KACjB,KAAK,MAAM,EAAE,GAAG,EAChB,MAAO,KACT,CAEA,CAAC,MAAM,EAAG,IAAK,CACb,GAAG,MAAM,KAAK,GAAG,EAAG,IAAK,EAAG,IAAI,OAAQ,KAAK,IAAI,EAAG,CAAC,GAAI,KACvD,KAAK,QAAQ,EAAE,GAAI,EAAE,CAAC,CAC1B,CAEA,CAAC,QAAQ,EAAG,GAAI,GAAI,CAClB,GAAI,GACF,KAAK,QAAQ,EAAE,EAAE,MACd,CACH,GAAI,KAAK,IAAI,IAAM,KACjB,KAAK,IAAI,GAAK,GAChB,GAAI,KAAK,MAAM,EAAE,OACf,KAAK,MAAM,EAAE,MACV,CACH,KAAK,QAAQ,EAAI,MAEjB,GAAI,KAAK,MAAM,GAAK,CAAC,KAAK,SAAS,EAAG,CACpC,KAAK,SAAS,EAAI,KAClB,KAAK,MAAM,EAAE,EACb,KAAK,KAAK,QAAQ,CACpB,SAAW,KAAK,UAAU,EAAG,CAC3B,KAAK,UAAU,EAAI,MACnB,KAAK,KAAK,OAAO,CACnB,CACF,CACF,CACF,CAEA,CAAC,MAAM,GAAK,CACV,GAAI,KAAK,MAAM,EAAE,SAAW,EAAG,CAC7B,GAAI,KAAK,MAAM,EACb,KAAK,QAAQ,EAAE,KAAM,CAAC,CAC1B,SAAW,KAAK,MAAM,EAAE,SAAW,EACjC,KAAK,MAAM,EAAE,KAAK,MAAM,EAAE,IAAI,CAAC,MAC5B,CACH,MAAM,MAAQ,KAAK,MAAM,EACzB,KAAK,MAAM,EAAI,CAAC,EAChB,OAAO,KAAK,GAAG,EAAG,MAAO,KAAK,IAAI,EAChC,CAAC,GAAI,KAAO,KAAK,QAAQ,EAAE,GAAI,EAAE,CAAC,CACtC,CACF,CAEA,CAAC,MAAM,GAAK,CACV,GAAI,KAAK,UAAU,GAAK,OAAO,KAAK,GAAG,IAAM,SAAU,CACrD,MAAM,GAAK,KAAK,GAAG,EACnB,KAAK,GAAG,EAAI,KACZ,GAAG,MAAM,GAAI,IAAM,GAAK,KAAK,KAAK,QAAS,EAAE,EAAI,KAAK,KAAK,OAAO,CAAC,CACrE,CACF,CACF,CAEA,MAAM,wBAAwB,WAAY,CArX1C,MAqX0C,gCACxC,CAAC,KAAK,GAAK,CACT,IAAI,GAGJ,GAAI,KAAK,YAAY,GAAK,KAAK,MAAM,IAAM,KAAM,CAC/C,GAAI,CACF,GAAK,GAAG,SAAS,KAAK,KAAK,EAAG,KAAK,MAAM,EAAG,KAAK,KAAK,CAAC,CACzD,OAAS,GAAI,CACX,GAAI,GAAG,OAAS,SAAU,CACxB,KAAK,MAAM,EAAI,IACf,OAAO,KAAK,KAAK,EAAE,CACrB,KACE,OAAM,EACV,CACF,MACE,GAAK,GAAG,SAAS,KAAK,KAAK,EAAG,KAAK,MAAM,EAAG,KAAK,KAAK,CAAC,EAEzD,KAAK,OAAO,EAAE,KAAM,EAAE,CACxB,CAEA,CAAC,MAAM,GAAK,CACV,GAAI,KAAK,UAAU,GAAK,OAAO,KAAK,GAAG,IAAM,SAAU,CACrD,MAAM,GAAK,KAAK,GAAG,EACnB,KAAK,GAAG,EAAI,KACZ,GAAG,UAAU,EAAE,EACf,KAAK,KAAK,OAAO,CACnB,CACF,CAEA,CAAC,MAAM,EAAG,IAAK,CAEb,IAAI,MAAQ,KACZ,GAAI,CACF,KAAK,QAAQ,EAAE,KACb,GAAG,UAAU,KAAK,GAAG,EAAG,IAAK,EAAG,IAAI,OAAQ,KAAK,IAAI,CAAC,CAAC,EACzD,MAAQ,KACV,QAAE,CACA,GAAI,MACF,GAAI,CAAE,KAAK,MAAM,EAAE,CAAE,OAAS,EAAG,CAAC,CACtC,CACF,CACF,CAEA,QAAQ,WAAa,WACrB,QAAQ,eAAiB,eAEzB,QAAQ,YAAc,YACtB,QAAQ,gBAAkB","names":["buf"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/fs-minipass@2.1.0/node_modules/fs-minipass/index.js"],"sourcesContent":["'use strict'\nconst MiniPass = require('minipass')\nconst EE = require('events').EventEmitter\nconst fs = require('fs')\n\nlet writev = fs.writev\n/* istanbul ignore next */\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  const binding = process.binding('fs')\n  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\n  writev = (fd, iovec, pos, cb) => {\n    const done = (er, bw) => cb(er, bw, iovec)\n    const req = new FSReqWrap()\n    req.oncomplete = done\n    binding.writeBuffers(fd, iovec, pos, req)\n  }\n}\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\nconst _errored = Symbol('_errored')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.readable = true\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_errored] = false\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0)\n        return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      case 'error':\n        if (this[_errored])\n          return\n        this[_errored] = true\n        return super.emit(ev, data)\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0\n            : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this.writable = true\n    this[_errored] = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  emit (ev, data) {\n    if (ev === 'error') {\n      if (this[_errored])\n        return\n      this[_errored] = true\n    }\n    return super.emit(ev, data)\n  }\n\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n    return this\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = Buffer.from(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    // only wrap in a try{} block if we know we'll retry, to avoid\n    // the rethrow obscuring the error's source frame in most cases.\n    if (this[_defaultFlag] && this[_flags] === 'r+') {\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode])\n      } catch (er) {\n        if (er.code === 'ENOENT') {\n          this[_flags] = 'w'\n          return this[_open]()\n        } else\n          throw er\n      }\n    } else\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    // throw the original, but try to close if it fails\n    let threw = true\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n      threw = false\n    } finally {\n      if (threw)\n        try { this[_close]() } catch (_) {}\n    }\n  }\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n"]}}