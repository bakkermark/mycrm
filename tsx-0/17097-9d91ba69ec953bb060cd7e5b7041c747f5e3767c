{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const hlo=require(\"./high-level-opt.js\");const Parser=require(\"./parse.js\");const fs=require(\"fs\");const fsm=require(\"fs-minipass\");const path=require(\"path\");const stripSlash=require(\"./strip-trailing-slashes.js\");module.exports=(opt_,files,cb)=>{if(typeof opt_===\"function\"){cb=opt_,files=null,opt_={}}else if(Array.isArray(opt_)){files=opt_,opt_={}}if(typeof files===\"function\"){cb=files,files=null}if(!files){files=[]}else{files=Array.from(files)}const opt=hlo(opt_);if(opt.sync&&typeof cb===\"function\"){throw new TypeError(\"callback not supported for sync tar functions\")}if(!opt.file&&typeof cb===\"function\"){throw new TypeError(\"callback only supported with file option\")}if(files.length){filesFilter(opt,files)}if(!opt.noResume){onentryFunction(opt)}return opt.file&&opt.sync?listFileSync(opt):opt.file?listFile(opt,cb):list(opt)};const onentryFunction=__name(opt=>{const onentry=opt.onentry;opt.onentry=onentry?e=>{onentry(e);e.resume()}:e=>e.resume()},\"onentryFunction\");const filesFilter=__name((opt,files)=>{const map=new Map(files.map(f=>[stripSlash(f),true]));const filter=opt.filter;const mapHas=__name((file,r)=>{const root=r||path.parse(file).root||\".\";const ret=file===root?false:map.has(file)?map.get(file):mapHas(path.dirname(file),root);map.set(file,ret);return ret},\"mapHas\");opt.filter=filter?(file,entry)=>filter(file,entry)&&mapHas(stripSlash(file)):file=>mapHas(stripSlash(file))},\"filesFilter\");const listFileSync=__name(opt=>{const p=list(opt);const file=opt.file;let threw=true;let fd;try{const stat=fs.statSync(file);const readSize=opt.maxReadSize||16*1024*1024;if(stat.size<readSize){p.end(fs.readFileSync(file))}else{let pos=0;const buf=Buffer.allocUnsafe(readSize);fd=fs.openSync(file,\"r\");while(pos<stat.size){const bytesRead=fs.readSync(fd,buf,0,readSize,pos);pos+=bytesRead;p.write(buf.slice(0,bytesRead))}p.end()}threw=false}finally{if(threw&&fd){try{fs.closeSync(fd)}catch(er){}}}},\"listFileSync\");const listFile=__name((opt,cb)=>{const parse=new Parser(opt);const readSize=opt.maxReadSize||16*1024*1024;const file=opt.file;const p=new Promise((resolve,reject)=>{parse.on(\"error\",reject);parse.on(\"end\",resolve);fs.stat(file,(er,stat)=>{if(er){reject(er)}else{const stream=new fsm.ReadStream(file,{readSize,size:stat.size});stream.on(\"error\",reject);stream.pipe(parse)}})});return cb?p.then(cb,cb):p},\"listFile\");const list=__name(opt=>new Parser(opt),\"list\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/list.js"],"sourcesContent":["'use strict'\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = require('./high-level-opt.js')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {}\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null\n  }\n\n  if (!files) {\n    files = []\n  } else {\n    files = Array.from(files)\n  }\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  if (files.length) {\n    filesFilter(opt, files)\n  }\n\n  if (!opt.noResume) {\n    onentryFunction(opt)\n  }\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n"]}}