{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{selectAll,selectOne,is}=require(\"css-select\");const xastAdaptor=require(\"./svgo/css-select-adapter.js\");const cssSelectOptions={xmlMode:true,adapter:xastAdaptor};const querySelectorAll=__name((node,selector)=>{return selectAll(selector,node,cssSelectOptions)},\"querySelectorAll\");exports.querySelectorAll=querySelectorAll;const querySelector=__name((node,selector)=>{return selectOne(selector,node,cssSelectOptions)},\"querySelector\");exports.querySelector=querySelector;const matches=__name((node,selector)=>{return is(node,selector,cssSelectOptions)},\"matches\");exports.matches=matches;const visitSkip=Symbol();exports.visitSkip=visitSkip;const visit=__name((node,visitor,parentNode)=>{const callbacks=visitor[node.type];if(callbacks&&callbacks.enter){const symbol=callbacks.enter(node,parentNode);if(symbol===visitSkip){return}}if(node.type===\"root\"){for(const child of node.children){visit(child,visitor,node)}}if(node.type===\"element\"){if(parentNode.children.includes(node)){for(const child of node.children){visit(child,visitor,node)}}}if(callbacks&&callbacks.exit){callbacks.exit(node,parentNode)}},\"visit\");exports.visit=visit;const detachNodeFromParent=__name((node,parentNode)=>{parentNode.children=parentNode.children.filter(child=>child!==node)},\"detachNodeFromParent\");exports.detachNodeFromParent=detachNodeFromParent;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HASA,KAAM,CAAE,UAAW,UAAW,EAAG,EAAI,QAAQ,YAAY,EACzD,MAAM,YAAc,QAAQ,8BAA8B,EAE1D,MAAM,iBAAmB,CACvB,QAAS,KACT,QAAS,WACX,EAKA,MAAM,iBAAmB,QAAC,KAAM,WAAa,CAC3C,OAAO,UAAU,SAAU,KAAM,gBAAgB,CACnD,EAFyB,oBAGzB,QAAQ,iBAAmB,iBAK3B,MAAM,cAAgB,QAAC,KAAM,WAAa,CACxC,OAAO,UAAU,SAAU,KAAM,gBAAgB,CACnD,EAFsB,iBAGtB,QAAQ,cAAgB,cAKxB,MAAM,QAAU,QAAC,KAAM,WAAa,CAClC,OAAO,GAAG,KAAM,SAAU,gBAAgB,CAC5C,EAFgB,WAGhB,QAAQ,QAAU,QAElB,MAAM,UAAY,OAAO,EACzB,QAAQ,UAAY,UAKpB,MAAM,MAAQ,QAAC,KAAM,QAAS,aAAe,CAC3C,MAAM,UAAY,QAAQ,KAAK,IAAI,EACnC,GAAI,WAAa,UAAU,MAAO,CAEhC,MAAM,OAAS,UAAU,MAAM,KAAM,UAAU,EAC/C,GAAI,SAAW,UAAW,CACxB,MACF,CACF,CAEA,GAAI,KAAK,OAAS,OAAQ,CAExB,UAAW,SAAS,KAAK,SAAU,CACjC,MAAM,MAAO,QAAS,IAAI,CAC5B,CACF,CAEA,GAAI,KAAK,OAAS,UAAW,CAC3B,GAAI,WAAW,SAAS,SAAS,IAAI,EAAG,CACtC,UAAW,SAAS,KAAK,SAAU,CACjC,MAAM,MAAO,QAAS,IAAI,CAC5B,CACF,CACF,CACA,GAAI,WAAa,UAAU,KAAM,CAE/B,UAAU,KAAK,KAAM,UAAU,CACjC,CACF,EA5Bc,SA6Bd,QAAQ,MAAQ,MAKhB,MAAM,qBAAuB,QAAC,KAAM,aAAe,CAEjD,WAAW,SAAW,WAAW,SAAS,OAAQ,OAAU,QAAU,IAAI,CAC5E,EAH6B,wBAI7B,QAAQ,qBAAuB","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/lib/xast.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('./types').XastNode} XastNode\n * @typedef {import('./types').XastChild} XastChild\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').Visitor} Visitor\n */\n\nconst { selectAll, selectOne, is } = require('css-select');\nconst xastAdaptor = require('./svgo/css-select-adapter.js');\n\nconst cssSelectOptions = {\n  xmlMode: true,\n  adapter: xastAdaptor,\n};\n\n/**\n * @type {(node: XastNode, selector: string) => Array<XastChild>}\n */\nconst querySelectorAll = (node, selector) => {\n  return selectAll(selector, node, cssSelectOptions);\n};\nexports.querySelectorAll = querySelectorAll;\n\n/**\n * @type {(node: XastNode, selector: string) => ?XastChild}\n */\nconst querySelector = (node, selector) => {\n  return selectOne(selector, node, cssSelectOptions);\n};\nexports.querySelector = querySelector;\n\n/**\n * @type {(node: XastChild, selector: string) => boolean}\n */\nconst matches = (node, selector) => {\n  return is(node, selector, cssSelectOptions);\n};\nexports.matches = matches;\n\nconst visitSkip = Symbol();\nexports.visitSkip = visitSkip;\n\n/**\n * @type {(node: XastNode, visitor: Visitor, parentNode?: any) => void}\n */\nconst visit = (node, visitor, parentNode) => {\n  const callbacks = visitor[node.type];\n  if (callbacks && callbacks.enter) {\n    // @ts-ignore hard to infer\n    const symbol = callbacks.enter(node, parentNode);\n    if (symbol === visitSkip) {\n      return;\n    }\n  }\n  // visit root children\n  if (node.type === 'root') {\n    // copy children array to not loose cursor when children is spliced\n    for (const child of node.children) {\n      visit(child, visitor, node);\n    }\n  }\n  // visit element children if still attached to parent\n  if (node.type === 'element') {\n    if (parentNode.children.includes(node)) {\n      for (const child of node.children) {\n        visit(child, visitor, node);\n      }\n    }\n  }\n  if (callbacks && callbacks.exit) {\n    // @ts-ignore hard to infer\n    callbacks.exit(node, parentNode);\n  }\n};\nexports.visit = visit;\n\n/**\n * @type {(node: XastChild, parentNode: XastParent) => void}\n */\nconst detachNodeFromParent = (node, parentNode) => {\n  // avoid splice to not break for loops\n  parentNode.children = parentNode.children.filter((child) => child !== node);\n};\nexports.detachNodeFromParent = detachNodeFromParent;\n"]}}