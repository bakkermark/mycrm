{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});exports.findAll=exports.existsOne=exports.findOne=exports.findOneChild=exports.find=exports.filter=void 0;var domhandler_1=require(\"domhandler\");function filter(test,node,recurse,limit){if(recurse===void 0){recurse=true}if(limit===void 0){limit=Infinity}return find(test,Array.isArray(node)?node:[node],recurse,limit)}__name(filter,\"filter\");exports.filter=filter;function find(test,nodes,recurse,limit){var result=[];var nodeStack=[nodes];var indexStack=[0];for(;;){if(indexStack[0]>=nodeStack[0].length){if(indexStack.length===1){return result}nodeStack.shift();indexStack.shift();continue}var elem=nodeStack[0][indexStack[0]++];if(test(elem)){result.push(elem);if(--limit<=0)return result}if(recurse&&(0,domhandler_1.hasChildren)(elem)&&elem.children.length>0){indexStack.unshift(0);nodeStack.unshift(elem.children)}}}__name(find,\"find\");exports.find=find;function findOneChild(test,nodes){return nodes.find(test)}__name(findOneChild,\"findOneChild\");exports.findOneChild=findOneChild;function findOne(test,nodes,recurse){if(recurse===void 0){recurse=true}var elem=null;for(var i=0;i<nodes.length&&!elem;i++){var node=nodes[i];if(!(0,domhandler_1.isTag)(node)){continue}else if(test(node)){elem=node}else if(recurse&&node.children.length>0){elem=findOne(test,node.children,true)}}return elem}__name(findOne,\"findOne\");exports.findOne=findOne;function existsOne(test,nodes){return nodes.some(function(checked){return(0,domhandler_1.isTag)(checked)&&(test(checked)||existsOne(test,checked.children))})}__name(existsOne,\"existsOne\");exports.existsOne=existsOne;function findAll(test,nodes){var result=[];var nodeStack=[nodes];var indexStack=[0];for(;;){if(indexStack[0]>=nodeStack[0].length){if(nodeStack.length===1){return result}nodeStack.shift();indexStack.shift();continue}var elem=nodeStack[0][indexStack[0]++];if(!(0,domhandler_1.isTag)(elem))continue;if(test(elem))result.push(elem);if(elem.children.length>0){indexStack.unshift(0);nodeStack.unshift(elem.children)}}}__name(findAll,\"findAll\");exports.findAll=findAll;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CAAE,MAAO,IAAK,CAAC,EAC5D,QAAQ,QAAU,QAAQ,UAAY,QAAQ,QAAU,QAAQ,aAAe,QAAQ,KAAO,QAAQ,OAAS,OAC/G,IAAI,aAAe,QAAQ,YAAY,EAWvC,SAAS,OAAO,KAAM,KAAM,QAAS,MAAO,CACxC,GAAI,UAAY,OAAQ,CAAE,QAAU,IAAM,CAC1C,GAAI,QAAU,OAAQ,CAAE,MAAQ,QAAU,CAC1C,OAAO,KAAK,KAAM,MAAM,QAAQ,IAAI,EAAI,KAAO,CAAC,IAAI,EAAG,QAAS,KAAK,CACzE,CAJS,wBAKT,QAAQ,OAAS,OAWjB,SAAS,KAAK,KAAM,MAAO,QAAS,MAAO,CACvC,IAAI,OAAS,CAAC,EAEd,IAAI,UAAY,CAAC,KAAK,EAEtB,IAAI,WAAa,CAAC,CAAC,EACnB,OAAS,CAEL,GAAI,WAAW,CAAC,GAAK,UAAU,CAAC,EAAE,OAAQ,CAEtC,GAAI,WAAW,SAAW,EAAG,CACzB,OAAO,MACX,CAEA,UAAU,MAAM,EAChB,WAAW,MAAM,EAEjB,QACJ,CACA,IAAI,KAAO,UAAU,CAAC,EAAE,WAAW,CAAC,GAAG,EACvC,GAAI,KAAK,IAAI,EAAG,CACZ,OAAO,KAAK,IAAI,EAChB,GAAI,EAAE,OAAS,EACX,OAAO,MACf,CACA,GAAI,UAAY,EAAG,aAAa,aAAa,IAAI,GAAK,KAAK,SAAS,OAAS,EAAG,CAK5E,WAAW,QAAQ,CAAC,EACpB,UAAU,QAAQ,KAAK,QAAQ,CACnC,CACJ,CACJ,CAlCS,oBAmCT,QAAQ,KAAO,KAUf,SAAS,aAAa,KAAM,MAAO,CAC/B,OAAO,MAAM,KAAK,IAAI,CAC1B,CAFS,oCAGT,QAAQ,aAAe,aAUvB,SAAS,QAAQ,KAAM,MAAO,QAAS,CACnC,GAAI,UAAY,OAAQ,CAAE,QAAU,IAAM,CAC1C,IAAI,KAAO,KACX,QAAS,EAAI,EAAG,EAAI,MAAM,QAAU,CAAC,KAAM,IAAK,CAC5C,IAAI,KAAO,MAAM,CAAC,EAClB,GAAI,EAAE,EAAG,aAAa,OAAO,IAAI,EAAG,CAChC,QACJ,SACS,KAAK,IAAI,EAAG,CACjB,KAAO,IACX,SACS,SAAW,KAAK,SAAS,OAAS,EAAG,CAC1C,KAAO,QAAQ,KAAM,KAAK,SAAU,IAAI,CAC5C,CACJ,CACA,OAAO,IACX,CAhBS,0BAiBT,QAAQ,QAAU,QASlB,SAAS,UAAU,KAAM,MAAO,CAC5B,OAAO,MAAM,KAAK,SAAU,QAAS,CACjC,OAAQ,EAAG,aAAa,OAAO,OAAO,IACjC,KAAK,OAAO,GAAK,UAAU,KAAM,QAAQ,QAAQ,EAC1D,CAAC,CACL,CALS,8BAMT,QAAQ,UAAY,UAWpB,SAAS,QAAQ,KAAM,MAAO,CAC1B,IAAI,OAAS,CAAC,EACd,IAAI,UAAY,CAAC,KAAK,EACtB,IAAI,WAAa,CAAC,CAAC,EACnB,OAAS,CACL,GAAI,WAAW,CAAC,GAAK,UAAU,CAAC,EAAE,OAAQ,CACtC,GAAI,UAAU,SAAW,EAAG,CACxB,OAAO,MACX,CAEA,UAAU,MAAM,EAChB,WAAW,MAAM,EAEjB,QACJ,CACA,IAAI,KAAO,UAAU,CAAC,EAAE,WAAW,CAAC,GAAG,EACvC,GAAI,EAAE,EAAG,aAAa,OAAO,IAAI,EAC7B,SACJ,GAAI,KAAK,IAAI,EACT,OAAO,KAAK,IAAI,EACpB,GAAI,KAAK,SAAS,OAAS,EAAG,CAC1B,WAAW,QAAQ,CAAC,EACpB,UAAU,QAAQ,KAAK,QAAQ,CACnC,CACJ,CACJ,CAzBS,0BA0BT,QAAQ,QAAU","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/querying.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;\nvar domhandler_1 = require(\"domhandler\");\n/**\n * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param node Node to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction filter(test, node, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    return find(test, Array.isArray(node) ? node : [node], recurse, limit);\n}\nexports.filter = filter;\n/**\n * Search an array of nodes and their children for nodes passing a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction find(test, nodes, recurse, limit) {\n    var result = [];\n    /** Stack of the arrays we are looking at. */\n    var nodeStack = [nodes];\n    /** Stack of the indices within the arrays. */\n    var indexStack = [0];\n    for (;;) {\n        // First, check if the current array has any more elements to look at.\n        if (indexStack[0] >= nodeStack[0].length) {\n            // If we have no more arrays to look at, we are done.\n            if (indexStack.length === 1) {\n                return result;\n            }\n            // Otherwise, remove the current array from the stack.\n            nodeStack.shift();\n            indexStack.shift();\n            // Loop back to the start to continue with the next array.\n            continue;\n        }\n        var elem = nodeStack[0][indexStack[0]++];\n        if (test(elem)) {\n            result.push(elem);\n            if (--limit <= 0)\n                return result;\n        }\n        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {\n            /*\n             * Add the children to the stack. We are depth-first, so this is\n             * the next array we look at.\n             */\n            indexStack.unshift(0);\n            nodeStack.unshift(elem.children);\n        }\n    }\n}\nexports.find = find;\n/**\n * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns The first node in the array that passes `test`.\n * @deprecated Use `Array.prototype.find` directly.\n */\nfunction findOneChild(test, nodes) {\n    return nodes.find(test);\n}\nexports.findOneChild = findOneChild;\n/**\n * Finds one element in a tree that passes a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Node or array of nodes to search.\n * @param recurse Also consider child nodes.\n * @returns The first node that passes `test`.\n */\nfunction findOne(test, nodes, recurse) {\n    if (recurse === void 0) { recurse = true; }\n    var elem = null;\n    for (var i = 0; i < nodes.length && !elem; i++) {\n        var node = nodes[i];\n        if (!(0, domhandler_1.isTag)(node)) {\n            continue;\n        }\n        else if (test(node)) {\n            elem = node;\n        }\n        else if (recurse && node.children.length > 0) {\n            elem = findOne(test, node.children, true);\n        }\n    }\n    return elem;\n}\nexports.findOne = findOne;\n/**\n * Checks if a tree of nodes contains at least one node passing a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns Whether a tree of nodes contains at least one node passing the test.\n */\nfunction existsOne(test, nodes) {\n    return nodes.some(function (checked) {\n        return (0, domhandler_1.isTag)(checked) &&\n            (test(checked) || existsOne(test, checked.children));\n    });\n}\nexports.existsOne = existsOne;\n/**\n * Search an array of nodes and their children for elements passing a test function.\n *\n * Same as `find`, but limited to elements and with less options, leading to reduced complexity.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns All nodes passing `test`.\n */\nfunction findAll(test, nodes) {\n    var result = [];\n    var nodeStack = [nodes];\n    var indexStack = [0];\n    for (;;) {\n        if (indexStack[0] >= nodeStack[0].length) {\n            if (nodeStack.length === 1) {\n                return result;\n            }\n            // Otherwise, remove the current array from the stack.\n            nodeStack.shift();\n            indexStack.shift();\n            // Loop back to the start to continue with the next array.\n            continue;\n        }\n        var elem = nodeStack[0][indexStack[0]++];\n        if (!(0, domhandler_1.isTag)(elem))\n            continue;\n        if (test(elem))\n            result.push(elem);\n        if (elem.children.length > 0) {\n            indexStack.unshift(0);\n            nodeStack.unshift(elem.children);\n        }\n    }\n}\nexports.findAll = findAll;\n//# sourceMappingURL=querying.js.map"]}}