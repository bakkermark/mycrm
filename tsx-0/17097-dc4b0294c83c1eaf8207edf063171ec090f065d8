{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});var __importDefault=exports&&exports.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod}};Object.defineProperty(exports,\"__esModule\",{value:true});exports.generate=exports.compile=void 0;var boolbase_1=__importDefault(require(\"boolbase\"));function compile(parsed){var a=parsed[0];var b=parsed[1]-1;if(b<0&&a<=0)return boolbase_1.default.falseFunc;if(a===-1)return function(index){return index<=b};if(a===0)return function(index){return index===b};if(a===1)return b<0?boolbase_1.default.trueFunc:function(index){return index>=b};var absA=Math.abs(a);var bMod=(b%absA+absA)%absA;return a>1?function(index){return index>=b&&index%absA===bMod}:function(index){return index<=b&&index%absA===bMod}}__name(compile,\"compile\");exports.compile=compile;function generate(parsed){var a=parsed[0];var b=parsed[1]-1;var n=0;if(a<0){var aPos_1=-a;var minValue_1=(b%aPos_1+aPos_1)%aPos_1;return function(){var val=minValue_1+aPos_1*n++;return val>b?null:val}}if(a===0)return b<0?function(){return null}:function(){return n++===0?b:null};if(b<0){b+=a*Math.ceil(-b/a)}return function(){return a*n+++b}}__name(generate,\"generate\");exports.generate=generate;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,IAAI,gBAAmB,SAAQ,QAAK,iBAAoB,SAAU,IAAK,CACnE,OAAQ,KAAO,IAAI,WAAc,IAAM,CAAE,UAAW,GAAI,CAC5D,EACA,OAAO,eAAe,QAAS,aAAc,CAAE,MAAO,IAAK,CAAC,EAC5D,QAAQ,SAAW,QAAQ,QAAU,OACrC,IAAI,WAAa,gBAAgB,QAAQ,UAAU,CAAC,EAqBpD,SAAS,QAAQ,OAAQ,CACrB,IAAI,EAAI,OAAO,CAAC,EAEhB,IAAI,EAAI,OAAO,CAAC,EAAI,EAQpB,GAAI,EAAI,GAAK,GAAK,EACd,OAAO,WAAW,QAAQ,UAE9B,GAAI,IAAM,GACN,OAAO,SAAU,MAAO,CAAE,OAAO,OAAS,CAAG,EACjD,GAAI,IAAM,EACN,OAAO,SAAU,MAAO,CAAE,OAAO,QAAU,CAAG,EAElD,GAAI,IAAM,EACN,OAAO,EAAI,EAAI,WAAW,QAAQ,SAAW,SAAU,MAAO,CAAE,OAAO,OAAS,CAAG,EAMvF,IAAI,KAAO,KAAK,IAAI,CAAC,EAErB,IAAI,MAAS,EAAI,KAAQ,MAAQ,KACjC,OAAO,EAAI,EACL,SAAU,MAAO,CAAE,OAAO,OAAS,GAAK,MAAQ,OAAS,IAAM,EAC/D,SAAU,MAAO,CAAE,OAAO,OAAS,GAAK,MAAQ,OAAS,IAAM,CACzE,CAhCS,0BAiCT,QAAQ,QAAU,QAiClB,SAAS,SAAS,OAAQ,CACtB,IAAI,EAAI,OAAO,CAAC,EAEhB,IAAI,EAAI,OAAO,CAAC,EAAI,EACpB,IAAI,EAAI,EAER,GAAI,EAAI,EAAG,CACP,IAAI,OAAS,CAAC,EAEd,IAAI,YAAe,EAAI,OAAU,QAAU,OAC3C,OAAO,UAAY,CACf,IAAI,IAAM,WAAa,OAAS,IAChC,OAAO,IAAM,EAAI,KAAO,GAC5B,CACJ,CACA,GAAI,IAAM,EACN,OAAO,EAAI,EAEH,UAAY,CAAE,OAAO,IAAM,EAE3B,UAAY,CAAE,OAAQ,MAAQ,EAAI,EAAI,IAAO,EACzD,GAAI,EAAI,EAAG,CACP,GAAK,EAAI,KAAK,KAAK,CAAC,EAAI,CAAC,CAC7B,CACA,OAAO,UAAY,CAAE,OAAO,EAAI,IAAM,CAAG,CAC7C,CAzBS,4BA0BT,QAAQ,SAAW","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/compile.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generate = exports.compile = void 0;\nvar boolbase_1 = __importDefault(require(\"boolbase\"));\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n *\n * ```js\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n * ```\n */\nfunction compile(parsed) {\n    var a = parsed[0];\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\n    var b = parsed[1] - 1;\n    /*\n     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n     * Besides, the specification states that no elements are\n     * matched when `a` and `b` are 0.\n     *\n     * `b < 0` here as we subtracted 1 from `b` above.\n     */\n    if (b < 0 && a <= 0)\n        return boolbase_1.default.falseFunc;\n    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n    if (a === -1)\n        return function (index) { return index <= b; };\n    if (a === 0)\n        return function (index) { return index === b; };\n    // When `b <= 0` and `a === 1`, they match any element.\n    if (a === 1)\n        return b < 0 ? boolbase_1.default.trueFunc : function (index) { return index >= b; };\n    /*\n     * Otherwise, modulo can be used to check if there is a match.\n     *\n     * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n     */\n    var absA = Math.abs(a);\n    // Get `b mod a`, + a if this is negative.\n    var bMod = ((b % absA) + absA) % absA;\n    return a > 1\n        ? function (index) { return index >= b && index % absA === bMod; }\n        : function (index) { return index <= b && index % absA === bMod; };\n}\nexports.compile = compile;\n/**\n * Returns a function that produces a monotonously increasing sequence of indices.\n *\n * If the sequence has an end, the returned function will return `null` after\n * the last index in the sequence.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A function that produces a sequence of indices.\n * @example <caption>Always increasing (2n+3)</caption>\n *\n * ```js\n * const gen = nthCheck.generate([2, 3])\n *\n * gen() // `1`\n * gen() // `3`\n * gen() // `5`\n * gen() // `8`\n * gen() // `11`\n * ```\n *\n * @example <caption>With end value (-2n+10)</caption>\n *\n * ```js\n *\n * const gen = nthCheck.generate([-2, 5]);\n *\n * gen() // 0\n * gen() // 2\n * gen() // 4\n * gen() // null\n * ```\n */\nfunction generate(parsed) {\n    var a = parsed[0];\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\n    var b = parsed[1] - 1;\n    var n = 0;\n    // Make sure to always return an increasing sequence\n    if (a < 0) {\n        var aPos_1 = -a;\n        // Get `b mod a`\n        var minValue_1 = ((b % aPos_1) + aPos_1) % aPos_1;\n        return function () {\n            var val = minValue_1 + aPos_1 * n++;\n            return val > b ? null : val;\n        };\n    }\n    if (a === 0)\n        return b < 0\n            ? // There are no result â€” always return `null`\n                function () { return null; }\n            : // Return `b` exactly once\n                function () { return (n++ === 0 ? b : null); };\n    if (b < 0) {\n        b += a * Math.ceil(-b / a);\n    }\n    return function () { return a * n++ + b; };\n}\nexports.generate = generate;\n//# sourceMappingURL=compile.js.map"]}}