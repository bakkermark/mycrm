{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"assert\");const Parser=require(\"./parse.js\");const fs=require(\"fs\");const fsm=require(\"fs-minipass\");const path=require(\"path\");const mkdir=require(\"./mkdir.js\");const wc=require(\"./winchars.js\");const pathReservations=require(\"./path-reservations.js\");const stripAbsolutePath=require(\"./strip-absolute-path.js\");const normPath=require(\"./normalize-windows-path.js\");const stripSlash=require(\"./strip-trailing-slashes.js\");const normalize=require(\"./normalize-unicode.js\");const ONENTRY=Symbol(\"onEntry\");const CHECKFS=Symbol(\"checkFs\");const CHECKFS2=Symbol(\"checkFs2\");const PRUNECACHE=Symbol(\"pruneCache\");const ISREUSABLE=Symbol(\"isReusable\");const MAKEFS=Symbol(\"makeFs\");const FILE=Symbol(\"file\");const DIRECTORY=Symbol(\"directory\");const LINK=Symbol(\"link\");const SYMLINK=Symbol(\"symlink\");const HARDLINK=Symbol(\"hardlink\");const UNSUPPORTED=Symbol(\"unsupported\");const CHECKPATH=Symbol(\"checkPath\");const MKDIR=Symbol(\"mkdir\");const ONERROR=Symbol(\"onError\");const PENDING=Symbol(\"pending\");const PEND=Symbol(\"pend\");const UNPEND=Symbol(\"unpend\");const ENDED=Symbol(\"ended\");const MAYBECLOSE=Symbol(\"maybeClose\");const SKIP=Symbol(\"skip\");const DOCHOWN=Symbol(\"doChown\");const UID=Symbol(\"uid\");const GID=Symbol(\"gid\");const CHECKED_CWD=Symbol(\"checkedCwd\");const crypto=require(\"crypto\");const getFlag=require(\"./get-write-flag.js\");const platform=process.env.TESTING_TAR_FAKE_PLATFORM||process.platform;const isWindows=platform===\"win32\";const unlinkFile=__name((path2,cb)=>{if(!isWindows){return fs.unlink(path2,cb)}const name=path2+\".DELETE.\"+crypto.randomBytes(16).toString(\"hex\");fs.rename(path2,name,er=>{if(er){return cb(er)}fs.unlink(name,cb)})},\"unlinkFile\");const unlinkFileSync=__name(path2=>{if(!isWindows){return fs.unlinkSync(path2)}const name=path2+\".DELETE.\"+crypto.randomBytes(16).toString(\"hex\");fs.renameSync(path2,name);fs.unlinkSync(name)},\"unlinkFileSync\");const uint32=__name((a,b,c)=>a===a>>>0?a:b===b>>>0?b:c,\"uint32\");const cacheKeyNormalize=__name(path2=>stripSlash(normPath(normalize(path2))).toLowerCase(),\"cacheKeyNormalize\");const pruneCache=__name((cache,abs)=>{abs=cacheKeyNormalize(abs);for(const path2 of cache.keys()){const pnorm=cacheKeyNormalize(path2);if(pnorm===abs||pnorm.indexOf(abs+\"/\")===0){cache.delete(path2)}}},\"pruneCache\");const dropCache=__name(cache=>{for(const key of cache.keys()){cache.delete(key)}},\"dropCache\");class Unpack extends Parser{static{__name(this,\"Unpack\")}constructor(opt){if(!opt){opt={}}opt.ondone=_=>{this[ENDED]=true;this[MAYBECLOSE]()};super(opt);this[CHECKED_CWD]=false;this.reservations=pathReservations();this.transform=typeof opt.transform===\"function\"?opt.transform:null;this.writable=true;this.readable=false;this[PENDING]=0;this[ENDED]=false;this.dirCache=opt.dirCache||new Map;if(typeof opt.uid===\"number\"||typeof opt.gid===\"number\"){if(typeof opt.uid!==\"number\"||typeof opt.gid!==\"number\"){throw new TypeError(\"cannot set owner without number uid and gid\")}if(opt.preserveOwner){throw new TypeError(\"cannot preserve owner in archive and also set owner explicitly\")}this.uid=opt.uid;this.gid=opt.gid;this.setOwner=true}else{this.uid=null;this.gid=null;this.setOwner=false}if(opt.preserveOwner===void 0&&typeof opt.uid!==\"number\"){this.preserveOwner=process.getuid&&process.getuid()===0}else{this.preserveOwner=!!opt.preserveOwner}this.processUid=(this.preserveOwner||this.setOwner)&&process.getuid?process.getuid():null;this.processGid=(this.preserveOwner||this.setOwner)&&process.getgid?process.getgid():null;this.forceChown=opt.forceChown===true;this.win32=!!opt.win32||isWindows;this.newer=!!opt.newer;this.keep=!!opt.keep;this.noMtime=!!opt.noMtime;this.preservePaths=!!opt.preservePaths;this.unlink=!!opt.unlink;this.cwd=normPath(path.resolve(opt.cwd||process.cwd()));this.strip=+opt.strip||0;this.processUmask=opt.noChmod?0:process.umask();this.umask=typeof opt.umask===\"number\"?opt.umask:this.processUmask;this.dmode=opt.dmode||511&~this.umask;this.fmode=opt.fmode||438&~this.umask;this.on(\"entry\",entry=>this[ONENTRY](entry))}warn(code,msg,data={}){if(code===\"TAR_BAD_ARCHIVE\"||code===\"TAR_ABORT\"){data.recoverable=false}return super.warn(code,msg,data)}[MAYBECLOSE](){if(this[ENDED]&&this[PENDING]===0){this.emit(\"prefinish\");this.emit(\"finish\");this.emit(\"end\")}}[CHECKPATH](entry){if(this.strip){const parts=normPath(entry.path).split(\"/\");if(parts.length<this.strip){return false}entry.path=parts.slice(this.strip).join(\"/\");if(entry.type===\"Link\"){const linkparts=normPath(entry.linkpath).split(\"/\");if(linkparts.length>=this.strip){entry.linkpath=linkparts.slice(this.strip).join(\"/\")}else{return false}}}if(!this.preservePaths){const p=normPath(entry.path);const parts=p.split(\"/\");if(parts.includes(\"..\")||isWindows&&/^[a-z]:\\.\\.$/i.test(parts[0])){this.warn(\"TAR_ENTRY_ERROR\",`path contains '..'`,{entry,path:p});return false}const[root,stripped]=stripAbsolutePath(p);if(root){entry.path=stripped;this.warn(\"TAR_ENTRY_INFO\",`stripping ${root} from absolute path`,{entry,path:p})}}if(path.isAbsolute(entry.path)){entry.absolute=normPath(path.resolve(entry.path))}else{entry.absolute=normPath(path.resolve(this.cwd,entry.path))}if(!this.preservePaths&&entry.absolute.indexOf(this.cwd+\"/\")!==0&&entry.absolute!==this.cwd){this.warn(\"TAR_ENTRY_ERROR\",\"path escaped extraction target\",{entry,path:normPath(entry.path),resolvedPath:entry.absolute,cwd:this.cwd});return false}if(entry.absolute===this.cwd&&entry.type!==\"Directory\"&&entry.type!==\"GNUDumpDir\"){return false}if(this.win32){const{root:aRoot}=path.win32.parse(entry.absolute);entry.absolute=aRoot+wc.encode(entry.absolute.slice(aRoot.length));const{root:pRoot}=path.win32.parse(entry.path);entry.path=pRoot+wc.encode(entry.path.slice(pRoot.length))}return true}[ONENTRY](entry){if(!this[CHECKPATH](entry)){return entry.resume()}assert.equal(typeof entry.absolute,\"string\");switch(entry.type){case\"Directory\":case\"GNUDumpDir\":if(entry.mode){entry.mode=entry.mode|448}case\"File\":case\"OldFile\":case\"ContiguousFile\":case\"Link\":case\"SymbolicLink\":return this[CHECKFS](entry);case\"CharacterDevice\":case\"BlockDevice\":case\"FIFO\":default:return this[UNSUPPORTED](entry)}}[ONERROR](er,entry){if(er.name===\"CwdError\"){this.emit(\"error\",er)}else{this.warn(\"TAR_ENTRY_ERROR\",er,{entry});this[UNPEND]();entry.resume()}}[MKDIR](dir,mode,cb){mkdir(normPath(dir),{uid:this.uid,gid:this.gid,processUid:this.processUid,processGid:this.processGid,umask:this.processUmask,preserve:this.preservePaths,unlink:this.unlink,cache:this.dirCache,cwd:this.cwd,mode,noChmod:this.noChmod},cb)}[DOCHOWN](entry){return this.forceChown||this.preserveOwner&&(typeof entry.uid===\"number\"&&entry.uid!==this.processUid||typeof entry.gid===\"number\"&&entry.gid!==this.processGid)||(typeof this.uid===\"number\"&&this.uid!==this.processUid||typeof this.gid===\"number\"&&this.gid!==this.processGid)}[UID](entry){return uint32(this.uid,entry.uid,this.processUid)}[GID](entry){return uint32(this.gid,entry.gid,this.processGid)}[FILE](entry,fullyDone){const mode=entry.mode&4095||this.fmode;const stream=new fsm.WriteStream(entry.absolute,{flags:getFlag(entry.size),mode,autoClose:false});stream.on(\"error\",er=>{if(stream.fd){fs.close(stream.fd,()=>{})}stream.write=()=>true;this[ONERROR](er,entry);fullyDone()});let actions=1;const done=__name(er=>{if(er){if(stream.fd){fs.close(stream.fd,()=>{})}this[ONERROR](er,entry);fullyDone();return}if(--actions===0){fs.close(stream.fd,er2=>{if(er2){this[ONERROR](er2,entry)}else{this[UNPEND]()}fullyDone()})}},\"done\");stream.on(\"finish\",_=>{const abs=entry.absolute;const fd=stream.fd;if(entry.mtime&&!this.noMtime){actions++;const atime=entry.atime||new Date;const mtime=entry.mtime;fs.futimes(fd,atime,mtime,er=>er?fs.utimes(abs,atime,mtime,er2=>done(er2&&er)):done())}if(this[DOCHOWN](entry)){actions++;const uid=this[UID](entry);const gid=this[GID](entry);fs.fchown(fd,uid,gid,er=>er?fs.chown(abs,uid,gid,er2=>done(er2&&er)):done())}done()});const tx=this.transform?this.transform(entry)||entry:entry;if(tx!==entry){tx.on(\"error\",er=>{this[ONERROR](er,entry);fullyDone()});entry.pipe(tx)}tx.pipe(stream)}[DIRECTORY](entry,fullyDone){const mode=entry.mode&4095||this.dmode;this[MKDIR](entry.absolute,mode,er=>{if(er){this[ONERROR](er,entry);fullyDone();return}let actions=1;const done=__name(_=>{if(--actions===0){fullyDone();this[UNPEND]();entry.resume()}},\"done\");if(entry.mtime&&!this.noMtime){actions++;fs.utimes(entry.absolute,entry.atime||new Date,entry.mtime,done)}if(this[DOCHOWN](entry)){actions++;fs.chown(entry.absolute,this[UID](entry),this[GID](entry),done)}done()})}[UNSUPPORTED](entry){entry.unsupported=true;this.warn(\"TAR_ENTRY_UNSUPPORTED\",`unsupported entry type: ${entry.type}`,{entry});entry.resume()}[SYMLINK](entry,done){this[LINK](entry,entry.linkpath,\"symlink\",done)}[HARDLINK](entry,done){const linkpath=normPath(path.resolve(this.cwd,entry.linkpath));this[LINK](entry,linkpath,\"link\",done)}[PEND](){this[PENDING]++}[UNPEND](){this[PENDING]--;this[MAYBECLOSE]()}[SKIP](entry){this[UNPEND]();entry.resume()}[ISREUSABLE](entry,st){return entry.type===\"File\"&&!this.unlink&&st.isFile()&&st.nlink<=1&&!isWindows}[CHECKFS](entry){this[PEND]();const paths=[entry.path];if(entry.linkpath){paths.push(entry.linkpath)}this.reservations.reserve(paths,done=>this[CHECKFS2](entry,done))}[PRUNECACHE](entry){if(entry.type===\"SymbolicLink\"){dropCache(this.dirCache)}else if(entry.type!==\"Directory\"){pruneCache(this.dirCache,entry.absolute)}}[CHECKFS2](entry,fullyDone){this[PRUNECACHE](entry);const done=__name(er=>{this[PRUNECACHE](entry);fullyDone(er)},\"done\");const checkCwd=__name(()=>{this[MKDIR](this.cwd,this.dmode,er=>{if(er){this[ONERROR](er,entry);done();return}this[CHECKED_CWD]=true;start()})},\"checkCwd\");const start=__name(()=>{if(entry.absolute!==this.cwd){const parent=normPath(path.dirname(entry.absolute));if(parent!==this.cwd){return this[MKDIR](parent,this.dmode,er=>{if(er){this[ONERROR](er,entry);done();return}afterMakeParent()})}}afterMakeParent()},\"start\");const afterMakeParent=__name(()=>{fs.lstat(entry.absolute,(lstatEr,st)=>{if(st&&(this.keep||this.newer&&st.mtime>entry.mtime)){this[SKIP](entry);done();return}if(lstatEr||this[ISREUSABLE](entry,st)){return this[MAKEFS](null,entry,done)}if(st.isDirectory()){if(entry.type===\"Directory\"){const needChmod=!this.noChmod&&entry.mode&&(st.mode&4095)!==entry.mode;const afterChmod=__name(er=>this[MAKEFS](er,entry,done),\"afterChmod\");if(!needChmod){return afterChmod()}return fs.chmod(entry.absolute,entry.mode,afterChmod)}if(entry.absolute!==this.cwd){return fs.rmdir(entry.absolute,er=>this[MAKEFS](er,entry,done))}}if(entry.absolute===this.cwd){return this[MAKEFS](null,entry,done)}unlinkFile(entry.absolute,er=>this[MAKEFS](er,entry,done))})},\"afterMakeParent\");if(this[CHECKED_CWD]){start()}else{checkCwd()}}[MAKEFS](er,entry,done){if(er){this[ONERROR](er,entry);done();return}switch(entry.type){case\"File\":case\"OldFile\":case\"ContiguousFile\":return this[FILE](entry,done);case\"Link\":return this[HARDLINK](entry,done);case\"SymbolicLink\":return this[SYMLINK](entry,done);case\"Directory\":case\"GNUDumpDir\":return this[DIRECTORY](entry,done)}}[LINK](entry,linkpath,link,done){fs[link](linkpath,entry.absolute,er=>{if(er){this[ONERROR](er,entry)}else{this[UNPEND]();entry.resume()}done()})}}const callSync=__name(fn=>{try{return[null,fn()]}catch(er){return[er,null]}},\"callSync\");class UnpackSync extends Unpack{static{__name(this,\"UnpackSync\")}[MAKEFS](er,entry){return super[MAKEFS](er,entry,()=>{})}[CHECKFS](entry){this[PRUNECACHE](entry);if(!this[CHECKED_CWD]){const er2=this[MKDIR](this.cwd,this.dmode);if(er2){return this[ONERROR](er2,entry)}this[CHECKED_CWD]=true}if(entry.absolute!==this.cwd){const parent=normPath(path.dirname(entry.absolute));if(parent!==this.cwd){const mkParent=this[MKDIR](parent,this.dmode);if(mkParent){return this[ONERROR](mkParent,entry)}}}const[lstatEr,st]=callSync(()=>fs.lstatSync(entry.absolute));if(st&&(this.keep||this.newer&&st.mtime>entry.mtime)){return this[SKIP](entry)}if(lstatEr||this[ISREUSABLE](entry,st)){return this[MAKEFS](null,entry)}if(st.isDirectory()){if(entry.type===\"Directory\"){const needChmod=!this.noChmod&&entry.mode&&(st.mode&4095)!==entry.mode;const[er3]=needChmod?callSync(()=>{fs.chmodSync(entry.absolute,entry.mode)}):[];return this[MAKEFS](er3,entry)}const[er2]=callSync(()=>fs.rmdirSync(entry.absolute));this[MAKEFS](er2,entry)}const[er]=entry.absolute===this.cwd?[]:callSync(()=>unlinkFileSync(entry.absolute));this[MAKEFS](er,entry)}[FILE](entry,done){const mode=entry.mode&4095||this.fmode;const oner=__name(er=>{let closeError;try{fs.closeSync(fd)}catch(e){closeError=e}if(er||closeError){this[ONERROR](er||closeError,entry)}done()},\"oner\");let fd;try{fd=fs.openSync(entry.absolute,getFlag(entry.size),mode)}catch(er){return oner(er)}const tx=this.transform?this.transform(entry)||entry:entry;if(tx!==entry){tx.on(\"error\",er=>this[ONERROR](er,entry));entry.pipe(tx)}tx.on(\"data\",chunk=>{try{fs.writeSync(fd,chunk,0,chunk.length)}catch(er){oner(er)}});tx.on(\"end\",_=>{let er=null;if(entry.mtime&&!this.noMtime){const atime=entry.atime||new Date;const mtime=entry.mtime;try{fs.futimesSync(fd,atime,mtime)}catch(futimeser){try{fs.utimesSync(entry.absolute,atime,mtime)}catch(utimeser){er=futimeser}}}if(this[DOCHOWN](entry)){const uid=this[UID](entry);const gid=this[GID](entry);try{fs.fchownSync(fd,uid,gid)}catch(fchowner){try{fs.chownSync(entry.absolute,uid,gid)}catch(chowner){er=er||fchowner}}}oner(er)})}[DIRECTORY](entry,done){const mode=entry.mode&4095||this.dmode;const er=this[MKDIR](entry.absolute,mode);if(er){this[ONERROR](er,entry);done();return}if(entry.mtime&&!this.noMtime){try{fs.utimesSync(entry.absolute,entry.atime||new Date,entry.mtime)}catch(er2){}}if(this[DOCHOWN](entry)){try{fs.chownSync(entry.absolute,this[UID](entry),this[GID](entry))}catch(er2){}}done();entry.resume()}[MKDIR](dir,mode){try{return mkdir.sync(normPath(dir),{uid:this.uid,gid:this.gid,processUid:this.processUid,processGid:this.processGid,umask:this.processUmask,preserve:this.preservePaths,unlink:this.unlink,cache:this.dirCache,cwd:this.cwd,mode})}catch(er){return er}}[LINK](entry,linkpath,link,done){try{fs[link+\"Sync\"](linkpath,entry.absolute);done();entry.resume()}catch(er){return this[ONERROR](er,entry)}}}Unpack.Sync=UnpackSync;module.exports=Unpack;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["path","er"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/unpack.js"],"sourcesContent":["'use strict'\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst mkdir = require('./mkdir.js')\nconst wc = require('./winchars.js')\nconst pathReservations = require('./path-reservations.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\nconst normalize = require('./normalize-unicode.js')\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst PRUNECACHE = Symbol('pruneCache')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst crypto = require('crypto')\nconst getFlag = require('./get-write-flag.js')\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows) {\n    return fs.unlink(path, cb)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er) {\n      return cb(er)\n    }\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows) {\n    return fs.unlinkSync(path)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => stripSlash(normPath(normalize(path)))\n  .toLowerCase()\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs)\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path)\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n      cache.delete(path)\n    }\n  }\n}\n\nconst dropCache = cache => {\n  for (const key of cache.keys()) {\n    cache.delete(key)\n  }\n}\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt) {\n      opt = {}\n    }\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this[CHECKED_CWD] = false\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\n        throw new TypeError('cannot set owner without number uid and gid')\n      }\n      if (opt.preserveOwner) {\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      }\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    } else {\n      this.preserveOwner = !!opt.preserveOwner\n    }\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\n    this.strip = +opt.strip || 0\n    // if we're not chmodding, then we don't need the process umask\n    this.processUmask = opt.noChmod ? 0 : process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn (code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n      data.recoverable = false\n    }\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = normPath(entry.path).split('/')\n      if (parts.length < this.strip) {\n        return false\n      }\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/')\n        if (linkparts.length >= this.strip) {\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        } else {\n          return false\n        }\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = normPath(entry.path)\n      const parts = p.split('/')\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p,\n        })\n        return false\n      }\n\n      // strip off the root\n      const [root, stripped] = stripAbsolutePath(p)\n      if (root) {\n        entry.path = stripped\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n          entry,\n          path: p,\n        })\n      }\n    }\n\n    if (path.isAbsolute(entry.path)) {\n      entry.absolute = normPath(path.resolve(entry.path))\n    } else {\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\n    }\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths &&\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n        entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd &&\n        entry.type !== 'Directory' &&\n        entry.type !== 'GNUDumpDir') {\n      return false\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(entry.absolute)\n      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry)) {\n      return entry.resume()\n    }\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) {\n          entry.mode = entry.mode | 0o700\n        }\n\n      // eslint-disable-next-line no-fallthrough\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') {\n      this.emit('error', er)\n    } else {\n      this.warn('TAR_ENTRY_ERROR', er, { entry })\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod,\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      (typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid)\n      ||\n      (typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid)\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false,\n    })\n    stream.on('error', er => {\n      if (stream.fd) {\n        fs.close(stream.fd, () => {})\n      }\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd) {\n          fs.close(stream.fd, () => {})\n        }\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          if (er) {\n            this[ONERROR](er, entry)\n          } else {\n            this[UNPEND]()\n          }\n          fullyDone()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => {\n        this[ONERROR](er, entry)\n        fullyDone()\n      })\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    entry.unsupported = true\n    this.warn('TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`, { entry })\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\n    this[LINK](entry, linkpath, 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath) {\n      paths.push(entry.linkpath)\n    }\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [PRUNECACHE] (entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink') {\n      dropCache(this.dirCache)\n    } else if (entry.type !== 'Directory') {\n      pruneCache(this.dirCache, entry.absolute)\n    }\n  }\n\n  [CHECKFS2] (entry, fullyDone) {\n    this[PRUNECACHE](entry)\n\n    const done = er => {\n      this[PRUNECACHE](entry)\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute))\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = er => this[MAKEFS](er, entry, done)\n            if (!needChmod) {\n              return afterChmod()\n            }\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er =>\n              this[MAKEFS](er, entry, done))\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        unlinkFile(entry.absolute, er =>\n          this[MAKEFS](er, entry, done))\n      })\n    }\n\n    if (this[CHECKED_CWD]) {\n      start()\n    } else {\n      checkCwd()\n    }\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n      } else {\n        this[UNPEND]()\n        entry.resume()\n      }\n      done()\n    })\n  }\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er, null]\n  }\n}\nclass UnpackSync extends Unpack {\n  [MAKEFS] (er, entry) {\n    return super[MAKEFS](er, entry, () => {})\n  }\n\n  [CHECKFS] (entry) {\n    this[PRUNECACHE](entry)\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er) {\n        return this[ONERROR](er, entry)\n      }\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute))\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent) {\n          return this[ONERROR](mkParent, entry)\n        }\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n      return this[SKIP](entry)\n    }\n\n    if (lstatEr || this[ISREUSABLE](entry, st)) {\n      return this[MAKEFS](null, entry)\n    }\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode)\n        }) : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? []\n      : callSync(() => unlinkFileSync(entry.absolute))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError) {\n        this[ONERROR](er || closeError, entry)\n      }\n      done()\n    }\n\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n"]}}