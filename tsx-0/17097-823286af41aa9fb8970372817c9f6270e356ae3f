{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const csstree=require(\"css-tree\");const{syntax:{specificity}}=require(\"csso\");const{visit,matches}=require(\"./xast.js\");const{attrsGroups,inheritableAttrs,presentationNonInheritableGroupAttrs}=require(\"../plugins/_collections.js\");const csstreeWalkSkip=csstree.walk.skip;const parseRule=__name((ruleNode,dynamic)=>{const declarations=[];ruleNode.block.children.forEach(cssNode=>{if(cssNode.type===\"Declaration\"){declarations.push({name:cssNode.property,value:csstree.generate(cssNode.value),important:cssNode.important===true})}});const rules=[];csstree.walk(ruleNode.prelude,node=>{if(node.type===\"Selector\"){const newNode=csstree.clone(node);let hasPseudoClasses=false;csstree.walk(newNode,(pseudoClassNode,item,list)=>{if(pseudoClassNode.type===\"PseudoClassSelector\"){hasPseudoClasses=true;list.remove(item)}});rules.push({specificity:specificity(node),dynamic:hasPseudoClasses||dynamic,selector:csstree.generate(newNode),declarations})}});return rules},\"parseRule\");const parseStylesheet=__name((css,dynamic)=>{const rules=[];const ast=csstree.parse(css,{parseValue:false,parseAtrulePrelude:false});csstree.walk(ast,cssNode=>{if(cssNode.type===\"Rule\"){rules.push(...parseRule(cssNode,dynamic||false));return csstreeWalkSkip}if(cssNode.type===\"Atrule\"){if(cssNode.name===\"keyframes\"){return csstreeWalkSkip}csstree.walk(cssNode,ruleNode=>{if(ruleNode.type===\"Rule\"){rules.push(...parseRule(ruleNode,dynamic||true));return csstreeWalkSkip}});return csstreeWalkSkip}});return rules},\"parseStylesheet\");const parseStyleDeclarations=__name(css=>{const declarations=[];const ast=csstree.parse(css,{context:\"declarationList\",parseValue:false});csstree.walk(ast,cssNode=>{if(cssNode.type===\"Declaration\"){declarations.push({name:cssNode.property,value:csstree.generate(cssNode.value),important:cssNode.important===true})}});return declarations},\"parseStyleDeclarations\");const computeOwnStyle=__name((stylesheet,node)=>{const computedStyle={};const importantStyles=new Map;for(const[name,value]of Object.entries(node.attributes)){if(attrsGroups.presentation.includes(name)){computedStyle[name]={type:\"static\",inherited:false,value};importantStyles.set(name,false)}}for(const{selector,declarations,dynamic}of stylesheet.rules){if(matches(node,selector)){for(const{name,value,important}of declarations){const computed=computedStyle[name];if(computed&&computed.type===\"dynamic\"){continue}if(dynamic){computedStyle[name]={type:\"dynamic\",inherited:false};continue}if(computed==null||important===true||importantStyles.get(name)===false){computedStyle[name]={type:\"static\",inherited:false,value};importantStyles.set(name,important)}}}}const styleDeclarations=node.attributes.style==null?[]:parseStyleDeclarations(node.attributes.style);for(const{name,value,important}of styleDeclarations){const computed=computedStyle[name];if(computed&&computed.type===\"dynamic\"){continue}if(computed==null||important===true||importantStyles.get(name)===false){computedStyle[name]={type:\"static\",inherited:false,value};importantStyles.set(name,important)}}return computedStyle},\"computeOwnStyle\");const compareSpecificity=__name((a,b)=>{for(let i=0;i<4;i+=1){if(a[i]<b[i]){return-1}else if(a[i]>b[i]){return 1}}return 0},\"compareSpecificity\");exports.compareSpecificity=compareSpecificity;const collectStylesheet=__name(root=>{const rules=[];const parents=new Map;visit(root,{element:{enter:(node,parentNode)=>{parents.set(node,parentNode);if(node.name===\"style\"){const dynamic=node.attributes.media!=null&&node.attributes.media!==\"all\";if(node.attributes.type==null||node.attributes.type===\"\"||node.attributes.type===\"text/css\"){const children=node.children;for(const child of children){if(child.type===\"text\"||child.type===\"cdata\"){rules.push(...parseStylesheet(child.value,dynamic))}}}}}}});rules.sort((a,b)=>compareSpecificity(a.specificity,b.specificity));return{rules,parents}},\"collectStylesheet\");exports.collectStylesheet=collectStylesheet;const computeStyle=__name((stylesheet,node)=>{const{parents}=stylesheet;const computedStyles=computeOwnStyle(stylesheet,node);let parent=parents.get(node);while(parent!=null&&parent.type!==\"root\"){const inheritedStyles=computeOwnStyle(stylesheet,parent);for(const[name,computed]of Object.entries(inheritedStyles)){if(computedStyles[name]==null&&inheritableAttrs.includes(name)===true&&presentationNonInheritableGroupAttrs.includes(name)===false){computedStyles[name]={...computed,inherited:true}}}parent=parents.get(parent)}return computedStyles},\"computeStyle\");exports.computeStyle=computeStyle;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/lib/style.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('css-tree').Rule} CsstreeRule\n * @typedef {import('./types').Specificity} Specificity\n * @typedef {import('./types').Stylesheet} Stylesheet\n * @typedef {import('./types').StylesheetRule} StylesheetRule\n * @typedef {import('./types').StylesheetDeclaration} StylesheetDeclaration\n * @typedef {import('./types').ComputedStyles} ComputedStyles\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\n\nconst csstree = require('css-tree');\nconst {\n  // @ts-ignore internal api\n  syntax: { specificity },\n} = require('csso');\nconst { visit, matches } = require('./xast.js');\nconst {\n  attrsGroups,\n  inheritableAttrs,\n  presentationNonInheritableGroupAttrs,\n} = require('../plugins/_collections.js');\n\n// @ts-ignore not defined in @types/csstree\nconst csstreeWalkSkip = csstree.walk.skip;\n\n/**\n * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule[]}\n */\nconst parseRule = (ruleNode, dynamic) => {\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n  const declarations = [];\n  // collect declarations\n  ruleNode.block.children.forEach((cssNode) => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true,\n      });\n    }\n  });\n\n  /** @type {StylesheetRule[]} */\n  const rules = [];\n  csstree.walk(ruleNode.prelude, (node) => {\n    if (node.type === 'Selector') {\n      const newNode = csstree.clone(node);\n      let hasPseudoClasses = false;\n      csstree.walk(newNode, (pseudoClassNode, item, list) => {\n        if (pseudoClassNode.type === 'PseudoClassSelector') {\n          hasPseudoClasses = true;\n          list.remove(item);\n        }\n      });\n      rules.push({\n        specificity: specificity(node),\n        dynamic: hasPseudoClasses || dynamic,\n        // compute specificity from original node to consider pseudo classes\n        selector: csstree.generate(newNode),\n        declarations,\n      });\n    }\n  });\n\n  return rules;\n};\n\n/**\n * @type {(css: string, dynamic: boolean) => Array<StylesheetRule>}\n */\nconst parseStylesheet = (css, dynamic) => {\n  /** @type {Array<StylesheetRule>} */\n  const rules = [];\n  const ast = csstree.parse(css, {\n    parseValue: false,\n    parseAtrulePrelude: false,\n  });\n  csstree.walk(ast, (cssNode) => {\n    if (cssNode.type === 'Rule') {\n      rules.push(...parseRule(cssNode, dynamic || false));\n      return csstreeWalkSkip;\n    }\n    if (cssNode.type === 'Atrule') {\n      if (cssNode.name === 'keyframes') {\n        return csstreeWalkSkip;\n      }\n      csstree.walk(cssNode, (ruleNode) => {\n        if (ruleNode.type === 'Rule') {\n          rules.push(...parseRule(ruleNode, dynamic || true));\n          return csstreeWalkSkip;\n        }\n      });\n      return csstreeWalkSkip;\n    }\n  });\n  return rules;\n};\n\n/**\n * @type {(css: string) => Array<StylesheetDeclaration>}\n */\nconst parseStyleDeclarations = (css) => {\n  /** @type {Array<StylesheetDeclaration>} */\n  const declarations = [];\n  const ast = csstree.parse(css, {\n    context: 'declarationList',\n    parseValue: false,\n  });\n  csstree.walk(ast, (cssNode) => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true,\n      });\n    }\n  });\n  return declarations;\n};\n\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\nconst computeOwnStyle = (stylesheet, node) => {\n  /** @type {ComputedStyles} */\n  const computedStyle = {};\n  const importantStyles = new Map();\n\n  // collect attributes\n  for (const [name, value] of Object.entries(node.attributes)) {\n    if (attrsGroups.presentation.includes(name)) {\n      computedStyle[name] = { type: 'static', inherited: false, value };\n      importantStyles.set(name, false);\n    }\n  }\n\n  // collect matching rules\n  for (const { selector, declarations, dynamic } of stylesheet.rules) {\n    if (matches(node, selector)) {\n      for (const { name, value, important } of declarations) {\n        const computed = computedStyle[name];\n        if (computed && computed.type === 'dynamic') {\n          continue;\n        }\n        if (dynamic) {\n          computedStyle[name] = { type: 'dynamic', inherited: false };\n          continue;\n        }\n        if (\n          computed == null ||\n          important === true ||\n          importantStyles.get(name) === false\n        ) {\n          computedStyle[name] = { type: 'static', inherited: false, value };\n          importantStyles.set(name, important);\n        }\n      }\n    }\n  }\n\n  // collect inline styles\n  const styleDeclarations =\n    node.attributes.style == null\n      ? []\n      : parseStyleDeclarations(node.attributes.style);\n  for (const { name, value, important } of styleDeclarations) {\n    const computed = computedStyle[name];\n    if (computed && computed.type === 'dynamic') {\n      continue;\n    }\n    if (\n      computed == null ||\n      important === true ||\n      importantStyles.get(name) === false\n    ) {\n      computedStyle[name] = { type: 'static', inherited: false, value };\n      importantStyles.set(name, important);\n    }\n  }\n\n  return computedStyle;\n};\n\n/**\n * Compares selector specificities.\n * Derived from https://github.com/keeganstreet/specificity/blob/8757133ddd2ed0163f120900047ff0f92760b536/specificity.js#L207\n *\n * @param {Specificity} a\n * @param {Specificity} b\n * @returns {number}\n */\nconst compareSpecificity = (a, b) => {\n  for (let i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n\n  return 0;\n};\nexports.compareSpecificity = compareSpecificity;\n\n/**\n * @type {(root: XastRoot) => Stylesheet}\n */\nconst collectStylesheet = (root) => {\n  /** @type {Array<StylesheetRule>} */\n  const rules = [];\n  /** @type {Map<XastElement, XastParent>} */\n  const parents = new Map();\n  visit(root, {\n    element: {\n      enter: (node, parentNode) => {\n        // store parents\n        parents.set(node, parentNode);\n        // find and parse all styles\n        if (node.name === 'style') {\n          const dynamic =\n            node.attributes.media != null && node.attributes.media !== 'all';\n          if (\n            node.attributes.type == null ||\n            node.attributes.type === '' ||\n            node.attributes.type === 'text/css'\n          ) {\n            const children = node.children;\n            for (const child of children) {\n              if (child.type === 'text' || child.type === 'cdata') {\n                rules.push(...parseStylesheet(child.value, dynamic));\n              }\n            }\n          }\n        }\n      },\n    },\n  });\n  // sort by selectors specificity\n  rules.sort((a, b) => compareSpecificity(a.specificity, b.specificity));\n  return { rules, parents };\n};\nexports.collectStylesheet = collectStylesheet;\n\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\nconst computeStyle = (stylesheet, node) => {\n  const { parents } = stylesheet;\n  // collect inherited styles\n  const computedStyles = computeOwnStyle(stylesheet, node);\n  let parent = parents.get(node);\n  while (parent != null && parent.type !== 'root') {\n    const inheritedStyles = computeOwnStyle(stylesheet, parent);\n    for (const [name, computed] of Object.entries(inheritedStyles)) {\n      if (\n        computedStyles[name] == null &&\n        // ignore not inheritable styles\n        inheritableAttrs.includes(name) === true &&\n        presentationNonInheritableGroupAttrs.includes(name) === false\n      ) {\n        computedStyles[name] = { ...computed, inherited: true };\n      }\n    }\n    parent = parents.get(parent);\n  }\n  return computedStyles;\n};\nexports.computeStyle = computeStyle;\n"]}}