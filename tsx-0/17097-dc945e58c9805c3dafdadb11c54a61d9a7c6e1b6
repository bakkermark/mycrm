{"code":"(()=>{\nconst{isAbsolute,parse}=require(\"path\").win32;module.exports=path=>{let r=\"\";let parsed=parse(path);while(isAbsolute(path)||parsed.root){const root=path.charAt(0)===\"/\"&&path.slice(0,4)!==\"//?/\"?\"/\":parsed.root;path=path.slice(root.length);r+=root;parsed=parse(path)}return[r,path]};\n})()\n","warnings":[],"map":{"version":3,"mappings":";AACA,KAAM,CAAE,WAAY,KAAM,EAAI,QAAQ,MAAM,EAAE,MAQ9C,OAAO,QAAU,MAAQ,CACvB,IAAI,EAAI,GAER,IAAI,OAAS,MAAM,IAAI,EACvB,MAAO,WAAW,IAAI,GAAK,OAAO,KAAM,CAGtC,MAAM,KAAO,KAAK,OAAO,CAAC,IAAM,KAAO,KAAK,MAAM,EAAG,CAAC,IAAM,OAAS,IACjE,OAAO,KACX,KAAO,KAAK,MAAM,KAAK,MAAM,EAC7B,GAAK,KACL,OAAS,MAAM,IAAI,CACrB,CACA,MAAO,CAAC,EAAG,IAAI,CACjB","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/strip-absolute-path.js"],"sourcesContent":["// unix absolute paths are also absolute on win32, so we use this for both\nconst { isAbsolute, parse } = require('path').win32\n\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nmodule.exports = path => {\n  let r = ''\n\n  let parsed = parse(path)\n  while (isAbsolute(path) || parsed.root) {\n    // windows will think that //x/y/z has a \"root\" of //x/y/\n    // but strip the //?/C:/ off of //?/C:/path\n    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'\n      : parsed.root\n    path = path.slice(root.length)\n    r += root\n    parsed = parse(path)\n  }\n  return [r, path]\n}\n"]}}