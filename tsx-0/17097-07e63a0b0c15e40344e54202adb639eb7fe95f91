{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const types=require(\"./types.js\");const pathModule=require(\"path\").posix;const large=require(\"./large-numbers.js\");const SLURP=Symbol(\"slurp\");const TYPE=Symbol(\"type\");class Header{static{__name(this,\"Header\")}constructor(data,off,ex,gex){this.cksumValid=false;this.needPax=false;this.nullBlock=false;this.block=null;this.path=null;this.mode=null;this.uid=null;this.gid=null;this.size=null;this.mtime=null;this.cksum=null;this[TYPE]=\"0\";this.linkpath=null;this.uname=null;this.gname=null;this.devmaj=0;this.devmin=0;this.atime=null;this.ctime=null;if(Buffer.isBuffer(data)){this.decode(data,off||0,ex,gex)}else if(data){this.set(data)}}decode(buf,off,ex,gex){if(!off){off=0}if(!buf||!(buf.length>=off+512)){throw new Error(\"need 512 bytes for header\")}this.path=decString(buf,off,100);this.mode=decNumber(buf,off+100,8);this.uid=decNumber(buf,off+108,8);this.gid=decNumber(buf,off+116,8);this.size=decNumber(buf,off+124,12);this.mtime=decDate(buf,off+136,12);this.cksum=decNumber(buf,off+148,12);this[SLURP](ex);this[SLURP](gex,true);this[TYPE]=decString(buf,off+156,1);if(this[TYPE]===\"\"){this[TYPE]=\"0\"}if(this[TYPE]===\"0\"&&this.path.slice(-1)===\"/\"){this[TYPE]=\"5\"}if(this[TYPE]===\"5\"){this.size=0}this.linkpath=decString(buf,off+157,100);if(buf.slice(off+257,off+265).toString()===\"ustar\\x0000\"){this.uname=decString(buf,off+265,32);this.gname=decString(buf,off+297,32);this.devmaj=decNumber(buf,off+329,8);this.devmin=decNumber(buf,off+337,8);if(buf[off+475]!==0){const prefix=decString(buf,off+345,155);this.path=prefix+\"/\"+this.path}else{const prefix=decString(buf,off+345,130);if(prefix){this.path=prefix+\"/\"+this.path}this.atime=decDate(buf,off+476,12);this.ctime=decDate(buf,off+488,12)}}let sum=8*32;for(let i=off;i<off+148;i++){sum+=buf[i]}for(let i=off+156;i<off+512;i++){sum+=buf[i]}this.cksumValid=sum===this.cksum;if(this.cksum===null&&sum===8*32){this.nullBlock=true}}[SLURP](ex,global){for(const k in ex){if(ex[k]!==null&&ex[k]!==void 0&&!(global&&k===\"path\")){this[k]=ex[k]}}}encode(buf,off){if(!buf){buf=this.block=Buffer.alloc(512);off=0}if(!off){off=0}if(!(buf.length>=off+512)){throw new Error(\"need 512 bytes for header\")}const prefixSize=this.ctime||this.atime?130:155;const split=splitPrefix(this.path||\"\",prefixSize);const path=split[0];const prefix=split[1];this.needPax=split[2];this.needPax=encString(buf,off,100,path)||this.needPax;this.needPax=encNumber(buf,off+100,8,this.mode)||this.needPax;this.needPax=encNumber(buf,off+108,8,this.uid)||this.needPax;this.needPax=encNumber(buf,off+116,8,this.gid)||this.needPax;this.needPax=encNumber(buf,off+124,12,this.size)||this.needPax;this.needPax=encDate(buf,off+136,12,this.mtime)||this.needPax;buf[off+156]=this[TYPE].charCodeAt(0);this.needPax=encString(buf,off+157,100,this.linkpath)||this.needPax;buf.write(\"ustar\\x0000\",off+257,8);this.needPax=encString(buf,off+265,32,this.uname)||this.needPax;this.needPax=encString(buf,off+297,32,this.gname)||this.needPax;this.needPax=encNumber(buf,off+329,8,this.devmaj)||this.needPax;this.needPax=encNumber(buf,off+337,8,this.devmin)||this.needPax;this.needPax=encString(buf,off+345,prefixSize,prefix)||this.needPax;if(buf[off+475]!==0){this.needPax=encString(buf,off+345,155,prefix)||this.needPax}else{this.needPax=encString(buf,off+345,130,prefix)||this.needPax;this.needPax=encDate(buf,off+476,12,this.atime)||this.needPax;this.needPax=encDate(buf,off+488,12,this.ctime)||this.needPax}let sum=8*32;for(let i=off;i<off+148;i++){sum+=buf[i]}for(let i=off+156;i<off+512;i++){sum+=buf[i]}this.cksum=sum;encNumber(buf,off+148,8,this.cksum);this.cksumValid=true;return this.needPax}set(data){for(const i in data){if(data[i]!==null&&data[i]!==void 0){this[i]=data[i]}}}get type(){return types.name.get(this[TYPE])||this[TYPE]}get typeKey(){return this[TYPE]}set type(type){if(types.code.has(type)){this[TYPE]=types.code.get(type)}else{this[TYPE]=type}}}const splitPrefix=__name((p,prefixSize)=>{const pathSize=100;let pp=p;let prefix=\"\";let ret;const root=pathModule.parse(p).root||\".\";if(Buffer.byteLength(pp)<pathSize){ret=[pp,prefix,false]}else{prefix=pathModule.dirname(pp);pp=pathModule.basename(pp);do{if(Buffer.byteLength(pp)<=pathSize&&Buffer.byteLength(prefix)<=prefixSize){ret=[pp,prefix,false]}else if(Buffer.byteLength(pp)>pathSize&&Buffer.byteLength(prefix)<=prefixSize){ret=[pp.slice(0,pathSize-1),prefix,true]}else{pp=pathModule.join(pathModule.basename(prefix),pp);prefix=pathModule.dirname(prefix)}}while(prefix!==root&&!ret);if(!ret){ret=[p.slice(0,pathSize-1),\"\",true]}}return ret},\"splitPrefix\");const decString=__name((buf,off,size)=>buf.slice(off,off+size).toString(\"utf8\").replace(/\\0.*/,\"\"),\"decString\");const decDate=__name((buf,off,size)=>numToDate(decNumber(buf,off,size)),\"decDate\");const numToDate=__name(num=>num===null?null:new Date(num*1e3),\"numToDate\");const decNumber=__name((buf,off,size)=>buf[off]&128?large.parse(buf.slice(off,off+size)):decSmallNumber(buf,off,size),\"decNumber\");const nanNull=__name(value=>isNaN(value)?null:value,\"nanNull\");const decSmallNumber=__name((buf,off,size)=>nanNull(parseInt(buf.slice(off,off+size).toString(\"utf8\").replace(/\\0.*$/,\"\").trim(),8)),\"decSmallNumber\");const MAXNUM={12:8589934591,8:2097151};const encNumber=__name((buf,off,size,number)=>number===null?false:number>MAXNUM[size]||number<0?(large.encode(number,buf.slice(off,off+size)),true):(encSmallNumber(buf,off,size,number),false),\"encNumber\");const encSmallNumber=__name((buf,off,size,number)=>buf.write(octalString(number,size),off,size,\"ascii\"),\"encSmallNumber\");const octalString=__name((number,size)=>padOctal(Math.floor(number).toString(8),size),\"octalString\");const padOctal=__name((string,size)=>(string.length===size-1?string:new Array(size-string.length-1).join(\"0\")+string+\" \")+\"\\0\",\"padOctal\");const encDate=__name((buf,off,size,date)=>date===null?false:encNumber(buf,off,size,date.getTime()/1e3),\"encDate\");const NULLS=new Array(156).join(\"\\0\");const encString=__name((buf,off,size,string)=>string===null?false:(buf.write(string+NULLS,off,size,\"utf8\"),string.length!==Buffer.byteLength(string)||string.length>size),\"encString\");module.exports=Header;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/header.js"],"sourcesContent":["'use strict'\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst types = require('./types.js')\nconst pathModule = require('path').posix\nconst large = require('./large-numbers.js')\n\nconst SLURP = Symbol('slurp')\nconst TYPE = Symbol('type')\n\nclass Header {\n  constructor (data, off, ex, gex) {\n    this.cksumValid = false\n    this.needPax = false\n    this.nullBlock = false\n\n    this.block = null\n    this.path = null\n    this.mode = null\n    this.uid = null\n    this.gid = null\n    this.size = null\n    this.mtime = null\n    this.cksum = null\n    this[TYPE] = '0'\n    this.linkpath = null\n    this.uname = null\n    this.gname = null\n    this.devmaj = 0\n    this.devmin = 0\n    this.atime = null\n    this.ctime = null\n\n    if (Buffer.isBuffer(data)) {\n      this.decode(data, off || 0, ex, gex)\n    } else if (data) {\n      this.set(data)\n    }\n  }\n\n  decode (buf, off, ex, gex) {\n    if (!off) {\n      off = 0\n    }\n\n    if (!buf || !(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    this.path = decString(buf, off, 100)\n    this.mode = decNumber(buf, off + 100, 8)\n    this.uid = decNumber(buf, off + 108, 8)\n    this.gid = decNumber(buf, off + 116, 8)\n    this.size = decNumber(buf, off + 124, 12)\n    this.mtime = decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    this[SLURP](ex)\n    this[SLURP](gex, true)\n\n    // old tar versions marked dirs as a file with a trailing /\n    this[TYPE] = decString(buf, off + 156, 1)\n    if (this[TYPE] === '') {\n      this[TYPE] = '0'\n    }\n    if (this[TYPE] === '0' && this.path.slice(-1) === '/') {\n      this[TYPE] = '5'\n    }\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this[TYPE] === '5') {\n      this.size = 0\n    }\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32)\n      this.gname = decString(buf, off + 297, 32)\n      this.devmaj = decNumber(buf, off + 329, 8)\n      this.devmin = decNumber(buf, off + 337, 8)\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix) {\n          this.path = prefix + '/' + this.path\n        }\n        this.atime = decDate(buf, off + 476, 12)\n        this.ctime = decDate(buf, off + 488, 12)\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === null && sum === 8 * 0x20) {\n      this.nullBlock = true\n    }\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = ex[k]\n      }\n    }\n  }\n\n  encode (buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n      off = 0\n    }\n\n    if (!off) {\n      off = 0\n    }\n\n    if (!(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this[TYPE].charCodeAt(0)\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0) {\n      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax\n    } else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  set (data) {\n    for (const i in data) {\n      if (data[i] !== null && data[i] !== undefined) {\n        this[i] = data[i]\n      }\n    }\n  }\n\n  get type () {\n    return types.name.get(this[TYPE]) || this[TYPE]\n  }\n\n  get typeKey () {\n    return this[TYPE]\n  }\n\n  set type (type) {\n    if (types.code.has(type)) {\n      this[TYPE] = types.code.get(type)\n    } else {\n      this[TYPE] = type\n    }\n  }\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize) {\n    ret = [pp, prefix, false]\n  } else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      if (Buffer.byteLength(pp) <= pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize) {\n        // both fit!\n        ret = [pp, prefix, false]\n      } else if (Buffer.byteLength(pp) > pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize) {\n        // prefix fits in prefix, but path doesn't fit in path\n        ret = [pp.slice(0, pathSize - 1), prefix, true]\n      } else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && !ret)\n\n    // at this point, found no resolution, just truncate\n    if (!ret) {\n      ret = [p.slice(0, pathSize - 1), '', true]\n    }\n  }\n  return ret\n}\n\nconst decString = (buf, off, size) =>\n  buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '')\n\nconst decDate = (buf, off, size) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = num => num === null ? null : new Date(num * 1000)\n\nconst decNumber = (buf, off, size) =>\n  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))\n  : decSmallNumber(buf, off, size)\n\nconst nanNull = value => isNaN(value) ? null : value\n\nconst decSmallNumber = (buf, off, size) =>\n  nanNull(parseInt(\n    buf.slice(off, off + size)\n      .toString('utf8').replace(/\\0.*$/, '').trim(), 8))\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8: 0o7777777,\n}\n\nconst encNumber = (buf, off, size, number) =>\n  number === null ? false :\n  number > MAXNUM[size] || number < 0\n    ? (large.encode(number, buf.slice(off, off + size)), true)\n    : (encSmallNumber(buf, off, size, number), false)\n\nconst encSmallNumber = (buf, off, size, number) =>\n  buf.write(octalString(number, size), off, size, 'ascii')\n\nconst octalString = (number, size) =>\n  padOctal(Math.floor(number).toString(8), size)\n\nconst padOctal = (string, size) =>\n  (string.length === size - 1 ? string\n  : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0'\n\nconst encDate = (buf, off, size, date) =>\n  date === null ? false :\n  encNumber(buf, off, size, date.getTime() / 1000)\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, string) =>\n  string === null ? false :\n  (buf.write(string + NULLS, off, size, 'utf8'),\n  string.length !== Buffer.byteLength(string) || string.length > size)\n\nmodule.exports = Header\n"]}}