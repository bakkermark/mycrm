{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});class PackJob{static{__name(this,\"PackJob\")}constructor(path2,absolute){this.path=path2||\"./\";this.absolute=absolute;this.entry=null;this.stat=null;this.readdir=null;this.pending=false;this.ignore=false;this.piped=false}}const{Minipass}=require(\"minipass\");const zlib=require(\"minizlib\");const ReadEntry=require(\"./read-entry.js\");const WriteEntry=require(\"./write-entry.js\");const WriteEntrySync=WriteEntry.Sync;const WriteEntryTar=WriteEntry.Tar;const Yallist=require(\"yallist\");const EOF=Buffer.alloc(1024);const ONSTAT=Symbol(\"onStat\");const ENDED=Symbol(\"ended\");const QUEUE=Symbol(\"queue\");const CURRENT=Symbol(\"current\");const PROCESS=Symbol(\"process\");const PROCESSING=Symbol(\"processing\");const PROCESSJOB=Symbol(\"processJob\");const JOBS=Symbol(\"jobs\");const JOBDONE=Symbol(\"jobDone\");const ADDFSENTRY=Symbol(\"addFSEntry\");const ADDTARENTRY=Symbol(\"addTarEntry\");const STAT=Symbol(\"stat\");const READDIR=Symbol(\"readdir\");const ONREADDIR=Symbol(\"onreaddir\");const PIPE=Symbol(\"pipe\");const ENTRY=Symbol(\"entry\");const ENTRYOPT=Symbol(\"entryOpt\");const WRITEENTRYCLASS=Symbol(\"writeEntryClass\");const WRITE=Symbol(\"write\");const ONDRAIN=Symbol(\"ondrain\");const fs=require(\"fs\");const path=require(\"path\");const warner=require(\"./warn-mixin.js\");const normPath=require(\"./normalize-windows-path.js\");const Pack=warner(class Pack2 extends Minipass{static{__name(this,\"Pack\")}constructor(opt){super(opt);opt=opt||Object.create(null);this.opt=opt;this.file=opt.file||\"\";this.cwd=opt.cwd||process.cwd();this.maxReadSize=opt.maxReadSize;this.preservePaths=!!opt.preservePaths;this.strict=!!opt.strict;this.noPax=!!opt.noPax;this.prefix=normPath(opt.prefix||\"\");this.linkCache=opt.linkCache||new Map;this.statCache=opt.statCache||new Map;this.readdirCache=opt.readdirCache||new Map;this[WRITEENTRYCLASS]=WriteEntry;if(typeof opt.onwarn===\"function\"){this.on(\"warn\",opt.onwarn)}this.portable=!!opt.portable;this.zip=null;if(opt.gzip||opt.brotli){if(opt.gzip&&opt.brotli){throw new TypeError(\"gzip and brotli are mutually exclusive\")}if(opt.gzip){if(typeof opt.gzip!==\"object\"){opt.gzip={}}if(this.portable){opt.gzip.portable=true}this.zip=new zlib.Gzip(opt.gzip)}if(opt.brotli){if(typeof opt.brotli!==\"object\"){opt.brotli={}}this.zip=new zlib.BrotliCompress(opt.brotli)}this.zip.on(\"data\",chunk=>super.write(chunk));this.zip.on(\"end\",_=>super.end());this.zip.on(\"drain\",_=>this[ONDRAIN]());this.on(\"resume\",_=>this.zip.resume())}else{this.on(\"drain\",this[ONDRAIN])}this.noDirRecurse=!!opt.noDirRecurse;this.follow=!!opt.follow;this.noMtime=!!opt.noMtime;this.mtime=opt.mtime||null;this.filter=typeof opt.filter===\"function\"?opt.filter:_=>true;this[QUEUE]=new Yallist;this[JOBS]=0;this.jobs=+opt.jobs||4;this[PROCESSING]=false;this[ENDED]=false}[WRITE](chunk){return super.write(chunk)}add(path2){this.write(path2);return this}end(path2){if(path2){this.write(path2)}this[ENDED]=true;this[PROCESS]();return this}write(path2){if(this[ENDED]){throw new Error(\"write after end\")}if(path2 instanceof ReadEntry){this[ADDTARENTRY](path2)}else{this[ADDFSENTRY](path2)}return this.flowing}[ADDTARENTRY](p){const absolute=normPath(path.resolve(this.cwd,p.path));if(!this.filter(p.path,p)){p.resume()}else{const job=new PackJob(p.path,absolute,false);job.entry=new WriteEntryTar(p,this[ENTRYOPT](job));job.entry.on(\"end\",_=>this[JOBDONE](job));this[JOBS]+=1;this[QUEUE].push(job)}this[PROCESS]()}[ADDFSENTRY](p){const absolute=normPath(path.resolve(this.cwd,p));this[QUEUE].push(new PackJob(p,absolute));this[PROCESS]()}[STAT](job){job.pending=true;this[JOBS]+=1;const stat=this.follow?\"stat\":\"lstat\";fs[stat](job.absolute,(er,stat2)=>{job.pending=false;this[JOBS]-=1;if(er){this.emit(\"error\",er)}else{this[ONSTAT](job,stat2)}})}[ONSTAT](job,stat){this.statCache.set(job.absolute,stat);job.stat=stat;if(!this.filter(job.path,stat)){job.ignore=true}this[PROCESS]()}[READDIR](job){job.pending=true;this[JOBS]+=1;fs.readdir(job.absolute,(er,entries)=>{job.pending=false;this[JOBS]-=1;if(er){return this.emit(\"error\",er)}this[ONREADDIR](job,entries)})}[ONREADDIR](job,entries){this.readdirCache.set(job.absolute,entries);job.readdir=entries;this[PROCESS]()}[PROCESS](){if(this[PROCESSING]){return}this[PROCESSING]=true;for(let w=this[QUEUE].head;w!==null&&this[JOBS]<this.jobs;w=w.next){this[PROCESSJOB](w.value);if(w.value.ignore){const p=w.next;this[QUEUE].removeNode(w);w.next=p}}this[PROCESSING]=false;if(this[ENDED]&&!this[QUEUE].length&&this[JOBS]===0){if(this.zip){this.zip.end(EOF)}else{super.write(EOF);super.end()}}}get[CURRENT](){return this[QUEUE]&&this[QUEUE].head&&this[QUEUE].head.value}[JOBDONE](job){this[QUEUE].shift();this[JOBS]-=1;this[PROCESS]()}[PROCESSJOB](job){if(job.pending){return}if(job.entry){if(job===this[CURRENT]&&!job.piped){this[PIPE](job)}return}if(!job.stat){if(this.statCache.has(job.absolute)){this[ONSTAT](job,this.statCache.get(job.absolute))}else{this[STAT](job)}}if(!job.stat){return}if(job.ignore){return}if(!this.noDirRecurse&&job.stat.isDirectory()&&!job.readdir){if(this.readdirCache.has(job.absolute)){this[ONREADDIR](job,this.readdirCache.get(job.absolute))}else{this[READDIR](job)}if(!job.readdir){return}}job.entry=this[ENTRY](job);if(!job.entry){job.ignore=true;return}if(job===this[CURRENT]&&!job.piped){this[PIPE](job)}}[ENTRYOPT](job){return{onwarn:(code,msg,data)=>this.warn(code,msg,data),noPax:this.noPax,cwd:this.cwd,absolute:job.absolute,preservePaths:this.preservePaths,maxReadSize:this.maxReadSize,strict:this.strict,portable:this.portable,linkCache:this.linkCache,statCache:this.statCache,noMtime:this.noMtime,mtime:this.mtime,prefix:this.prefix}}[ENTRY](job){this[JOBS]+=1;try{return new this[WRITEENTRYCLASS](job.path,this[ENTRYOPT](job)).on(\"end\",()=>this[JOBDONE](job)).on(\"error\",er=>this.emit(\"error\",er))}catch(er){this.emit(\"error\",er)}}[ONDRAIN](){if(this[CURRENT]&&this[CURRENT].entry){this[CURRENT].entry.resume()}}[PIPE](job){job.piped=true;if(job.readdir){job.readdir.forEach(entry=>{const p=job.path;const base=p===\"./\"?\"\":p.replace(/\\/*$/,\"/\");this[ADDFSENTRY](base+entry)})}const source=job.entry;const zip=this.zip;if(zip){source.on(\"data\",chunk=>{if(!zip.write(chunk)){source.pause()}})}else{source.on(\"data\",chunk=>{if(!super.write(chunk)){source.pause()}})}}pause(){if(this.zip){this.zip.pause()}return super.pause()}});class PackSync extends Pack{static{__name(this,\"PackSync\")}constructor(opt){super(opt);this[WRITEENTRYCLASS]=WriteEntrySync}pause(){}resume(){}[STAT](job){const stat=this.follow?\"statSync\":\"lstatSync\";this[ONSTAT](job,fs[stat](job.absolute))}[READDIR](job,stat){this[ONREADDIR](job,fs.readdirSync(job.absolute))}[PIPE](job){const source=job.entry;const zip=this.zip;if(job.readdir){job.readdir.forEach(entry=>{const p=job.path;const base=p===\"./\"?\"\":p.replace(/\\/*$/,\"/\");this[ADDFSENTRY](base+entry)})}if(zip){source.on(\"data\",chunk=>{zip.write(chunk)})}else{source.on(\"data\",chunk=>{super[WRITE](chunk)})}}}Pack.Sync=PackSync;module.exports=Pack;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["path","Pack","stat"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/pack.js"],"sourcesContent":["'use strict'\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst { Minipass } = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\nconst normPath = require('./normalize-windows-path.js')\n\nconst Pack = warner(class Pack extends Minipass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    this.portable = !!opt.portable\n    this.zip = null\n\n    if (opt.gzip || opt.brotli) {\n      if (opt.gzip && opt.brotli) {\n        throw new TypeError('gzip and brotli are mutually exclusive')\n      }\n      if (opt.gzip) {\n        if (typeof opt.gzip !== 'object') {\n          opt.gzip = {}\n        }\n        if (this.portable) {\n          opt.gzip.portable = true\n        }\n        this.zip = new zlib.Gzip(opt.gzip)\n      }\n      if (opt.brotli) {\n        if (typeof opt.brotli !== 'object') {\n          opt.brotli = {}\n        }\n        this.zip = new zlib.BrotliCompress(opt.brotli)\n      }\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else {\n      this.on('drain', this[ONDRAIN])\n    }\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist()\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path) {\n      this.write(path)\n    }\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED]) {\n      throw new Error('write after end')\n    }\n\n    if (path instanceof ReadEntry) {\n      this[ADDTARENTRY](path)\n    } else {\n      this[ADDFSENTRY](path)\n    }\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p)) {\n      p.resume()\n    } else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        this.emit('error', er)\n      } else {\n        this[ONSTAT](job, stat)\n      }\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat)) {\n      job.ignore = true\n    }\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING]) {\n      return\n    }\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n      w !== null && this[JOBS] < this.jobs;\n      w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) {\n        this.zip.end(EOF)\n      } else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending) {\n      return\n    }\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job)\n      }\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) {\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      } else {\n        this[STAT](job)\n      }\n    }\n    if (!job.stat) {\n      return\n    }\n\n    // filtered out!\n    if (job.ignore) {\n      return\n    }\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) {\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      } else {\n        this[READDIR](job)\n      }\n      if (!job.readdir) {\n        return\n      }\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped) {\n      this[PIPE](job)\n    }\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry) {\n      this[CURRENT].entry.resume()\n    }\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) {\n          source.pause()\n        }\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk)) {\n          source.pause()\n        }\n      })\n    }\n  }\n\n  pause () {\n    if (this.zip) {\n      this.zip.pause()\n    }\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n"]}}