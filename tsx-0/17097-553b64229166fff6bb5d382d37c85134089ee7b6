{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const encode=__name((num,buf)=>{if(!Number.isSafeInteger(num)){throw Error(\"cannot encode number outside of javascript safe integer range\")}else if(num<0){encodeNegative(num,buf)}else{encodePositive(num,buf)}return buf},\"encode\");const encodePositive=__name((num,buf)=>{buf[0]=128;for(var i=buf.length;i>1;i--){buf[i-1]=num&255;num=Math.floor(num/256)}},\"encodePositive\");const encodeNegative=__name((num,buf)=>{buf[0]=255;var flipped=false;num=num*-1;for(var i=buf.length;i>1;i--){var byte=num&255;num=Math.floor(num/256);if(flipped){buf[i-1]=onesComp(byte)}else if(byte===0){buf[i-1]=0}else{flipped=true;buf[i-1]=twosComp(byte)}}},\"encodeNegative\");const parse=__name(buf=>{const pre=buf[0];const value=pre===128?pos(buf.slice(1,buf.length)):pre===255?twos(buf):null;if(value===null){throw Error(\"invalid base256 encoding\")}if(!Number.isSafeInteger(value)){throw Error(\"parsed number outside of javascript safe integer range\")}return value},\"parse\");const twos=__name(buf=>{var len=buf.length;var sum=0;var flipped=false;for(var i=len-1;i>-1;i--){var byte=buf[i];var f;if(flipped){f=onesComp(byte)}else if(byte===0){f=byte}else{flipped=true;f=twosComp(byte)}if(f!==0){sum-=f*Math.pow(256,len-i-1)}}return sum},\"twos\");const pos=__name(buf=>{var len=buf.length;var sum=0;for(var i=len-1;i>-1;i--){var byte=buf[i];if(byte!==0){sum+=byte*Math.pow(256,len-i-1)}}return sum},\"pos\");const onesComp=__name(byte=>(255^byte)&255,\"onesComp\");const twosComp=__name(byte=>(255^byte)+1&255,\"twosComp\");module.exports={encode,parse};\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAIA,MAAM,OAAS,QAAC,IAAK,MAAQ,CAC3B,GAAI,CAAC,OAAO,cAAc,GAAG,EAAG,CAG9B,MAAM,MAAM,+DAA+D,CAC7E,SAAW,IAAM,EAAG,CAClB,eAAe,IAAK,GAAG,CACzB,KAAO,CACL,eAAe,IAAK,GAAG,CACzB,CACA,OAAO,GACT,EAXe,UAaf,MAAM,eAAiB,QAAC,IAAK,MAAQ,CACnC,IAAI,CAAC,EAAI,IAET,QAAS,EAAI,IAAI,OAAQ,EAAI,EAAG,IAAK,CACnC,IAAI,EAAI,CAAC,EAAI,IAAM,IACnB,IAAM,KAAK,MAAM,IAAM,GAAK,CAC9B,CACF,EAPuB,kBASvB,MAAM,eAAiB,QAAC,IAAK,MAAQ,CACnC,IAAI,CAAC,EAAI,IACT,IAAI,QAAU,MACd,IAAM,IAAM,GACZ,QAAS,EAAI,IAAI,OAAQ,EAAI,EAAG,IAAK,CACnC,IAAI,KAAO,IAAM,IACjB,IAAM,KAAK,MAAM,IAAM,GAAK,EAC5B,GAAI,QAAS,CACX,IAAI,EAAI,CAAC,EAAI,SAAS,IAAI,CAC5B,SAAW,OAAS,EAAG,CACrB,IAAI,EAAI,CAAC,EAAI,CACf,KAAO,CACL,QAAU,KACV,IAAI,EAAI,CAAC,EAAI,SAAS,IAAI,CAC5B,CACF,CACF,EAhBuB,kBAkBvB,MAAM,MAAQ,OAAC,KAAQ,CACrB,MAAM,IAAM,IAAI,CAAC,EACjB,MAAM,MAAQ,MAAQ,IAAO,IAAI,IAAI,MAAM,EAAG,IAAI,MAAM,CAAC,EACrD,MAAQ,IAAO,KAAK,GAAG,EACvB,KACJ,GAAI,QAAU,KAAM,CAClB,MAAM,MAAM,0BAA0B,CACxC,CAEA,GAAI,CAAC,OAAO,cAAc,KAAK,EAAG,CAGhC,MAAM,MAAM,wDAAwD,CACtE,CAEA,OAAO,KACT,EAhBc,SAkBd,MAAM,KAAO,OAAC,KAAQ,CACpB,IAAI,IAAM,IAAI,OACd,IAAI,IAAM,EACV,IAAI,QAAU,MACd,QAAS,EAAI,IAAM,EAAG,EAAI,GAAI,IAAK,CACjC,IAAI,KAAO,IAAI,CAAC,EAChB,IAAI,EACJ,GAAI,QAAS,CACX,EAAI,SAAS,IAAI,CACnB,SAAW,OAAS,EAAG,CACrB,EAAI,IACN,KAAO,CACL,QAAU,KACV,EAAI,SAAS,IAAI,CACnB,CACA,GAAI,IAAM,EAAG,CACX,KAAO,EAAI,KAAK,IAAI,IAAK,IAAM,EAAI,CAAC,CACtC,CACF,CACA,OAAO,GACT,EApBa,QAsBb,MAAM,IAAM,OAAC,KAAQ,CACnB,IAAI,IAAM,IAAI,OACd,IAAI,IAAM,EACV,QAAS,EAAI,IAAM,EAAG,EAAI,GAAI,IAAK,CACjC,IAAI,KAAO,IAAI,CAAC,EAChB,GAAI,OAAS,EAAG,CACd,KAAO,KAAO,KAAK,IAAI,IAAK,IAAM,EAAI,CAAC,CACzC,CACF,CACA,OAAO,GACT,EAVY,OAYZ,MAAM,SAAW,cAAS,IAAO,MAAQ,IAAxB,YAEjB,MAAM,SAAW,cAAU,IAAO,MAAQ,EAAK,IAA9B,YAEjB,OAAO,QAAU,CACf,OACA,KACF","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/large-numbers.js"],"sourcesContent":["'use strict'\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = (num, buf) => {\n  if (!Number.isSafeInteger(num)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('cannot encode number outside of javascript safe integer range')\n  } else if (num < 0) {\n    encodeNegative(num, buf)\n  } else {\n    encodePositive(num, buf)\n  }\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped) {\n      buf[i - 1] = onesComp(byte)\n    } else if (byte === 0) {\n      buf[i - 1] = 0\n    } else {\n      flipped = true\n      buf[i - 1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = (buf) => {\n  const pre = buf[0]\n  const value = pre === 0x80 ? pos(buf.slice(1, buf.length))\n    : pre === 0xff ? twos(buf)\n    : null\n  if (value === null) {\n    throw Error('invalid base256 encoding')\n  }\n\n  if (!Number.isSafeInteger(value)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('parsed number outside of javascript safe integer range')\n  }\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped) {\n      f = onesComp(byte)\n    } else if (byte === 0) {\n      f = byte\n    } else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0) {\n      sum -= f * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0) {\n      sum += byte * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n\nmodule.exports = {\n  encode,\n  parse,\n}\n"]}}