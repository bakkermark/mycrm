{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const SAX=require(\"@trysound/sax\");const{textElems}=require(\"../plugins/_collections.js\");class SvgoParserError extends Error{static{__name(this,\"SvgoParserError\")}constructor(message,line,column,source,file){super(message);this.name=\"SvgoParserError\";this.message=`${file||\"<input>\"}:${line}:${column}: ${message}`;this.reason=message;this.line=line;this.column=column;this.source=source;if(Error.captureStackTrace){Error.captureStackTrace(this,SvgoParserError)}}toString(){const lines=this.source.split(/\\r?\\n/);const startLine=Math.max(this.line-3,0);const endLine=Math.min(this.line+2,lines.length);const lineNumberWidth=String(endLine).length;const startColumn=Math.max(this.column-54,0);const endColumn=Math.max(this.column+20,80);const code=lines.slice(startLine,endLine).map((line,index)=>{const lineSlice=line.slice(startColumn,endColumn);let ellipsisPrefix=\"\";let ellipsisSuffix=\"\";if(startColumn!==0){ellipsisPrefix=startColumn>line.length-1?\" \":\"\\u2026\"}if(endColumn<line.length-1){ellipsisSuffix=\"\\u2026\"}const number=startLine+1+index;const gutter=` ${number.toString().padStart(lineNumberWidth)} | `;if(number===this.line){const gutterSpacing=gutter.replace(/[^|]/g,\" \");const lineSpacing=(ellipsisPrefix+line.slice(startColumn,this.column-1)).replace(/[^\\t]/g,\" \");const spacing=gutterSpacing+lineSpacing;return`>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\n ${spacing}^`}return` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`}).join(\"\\n\");return`${this.name}: ${this.message}\n\n${code}\n`}}const entityDeclaration=/<!ENTITY\\s+(\\S+)\\s+(?:'([^']+)'|\"([^\"]+)\")\\s*>/g;const config={strict:true,trim:false,normalize:false,lowercase:true,xmlns:true,position:true};const parseSvg=__name((data,from)=>{const sax=SAX.parser(config.strict,config);const root={type:\"root\",children:[]};let current=root;const stack=[root];const pushToContent=__name(node=>{Object.defineProperty(node,\"parentNode\",{writable:true,value:current});current.children.push(node)},\"pushToContent\");sax.ondoctype=doctype=>{const node={type:\"doctype\",name:\"svg\",data:{doctype}};pushToContent(node);const subsetStart=doctype.indexOf(\"[\");if(subsetStart>=0){entityDeclaration.lastIndex=subsetStart;let entityMatch=entityDeclaration.exec(data);while(entityMatch!=null){sax.ENTITIES[entityMatch[1]]=entityMatch[2]||entityMatch[3];entityMatch=entityDeclaration.exec(data)}}};sax.onprocessinginstruction=data2=>{const node={type:\"instruction\",name:data2.name,value:data2.body};pushToContent(node)};sax.oncomment=comment=>{const node={type:\"comment\",value:comment.trim()};pushToContent(node)};sax.oncdata=cdata=>{const node={type:\"cdata\",value:cdata};pushToContent(node)};sax.onopentag=data2=>{let element={type:\"element\",name:data2.name,attributes:{},children:[]};for(const[name,attr]of Object.entries(data2.attributes)){element.attributes[name]=attr.value}pushToContent(element);current=element;stack.push(element)};sax.ontext=text=>{if(current.type===\"element\"){if(textElems.includes(current.name)){const node={type:\"text\",value:text};pushToContent(node)}else if(/\\S/.test(text)){const node={type:\"text\",value:text.trim()};pushToContent(node)}}};sax.onclosetag=()=>{stack.pop();current=stack[stack.length-1]};sax.onerror=e=>{const error=new SvgoParserError(e.reason,e.line+1,e.column,data,from);if(e.message.indexOf(\"Unexpected end\")===-1){throw error}};sax.write(data).close();return root},\"parseSvg\");exports.parseSvg=parseSvg;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAgBA,MAAM,IAAM,QAAQ,eAAe,EACnC,KAAM,CAAE,SAAU,EAAI,QAAQ,4BAA4B,EAE1D,MAAM,wBAAwB,KAAM,CAnBpC,MAmBoC,gCAQlC,YAAY,QAAS,KAAM,OAAQ,OAAQ,KAAM,CAC/C,MAAM,OAAO,EACb,KAAK,KAAO,kBACZ,KAAK,QAAU,GAAG,MAAQ,SAAS,IAAI,IAAI,IAAI,MAAM,KAAK,OAAO,GACjE,KAAK,OAAS,QACd,KAAK,KAAO,KACZ,KAAK,OAAS,OACd,KAAK,OAAS,OACd,GAAI,MAAM,kBAAmB,CAC3B,MAAM,kBAAkB,KAAM,eAAe,CAC/C,CACF,CACA,UAAW,CACT,MAAM,MAAQ,KAAK,OAAO,MAAM,OAAO,EACvC,MAAM,UAAY,KAAK,IAAI,KAAK,KAAO,EAAG,CAAC,EAC3C,MAAM,QAAU,KAAK,IAAI,KAAK,KAAO,EAAG,MAAM,MAAM,EACpD,MAAM,gBAAkB,OAAO,OAAO,EAAE,OACxC,MAAM,YAAc,KAAK,IAAI,KAAK,OAAS,GAAI,CAAC,EAChD,MAAM,UAAY,KAAK,IAAI,KAAK,OAAS,GAAI,EAAE,EAC/C,MAAM,KAAO,MACV,MAAM,UAAW,OAAO,EACxB,IAAI,CAAC,KAAM,QAAU,CACpB,MAAM,UAAY,KAAK,MAAM,YAAa,SAAS,EACnD,IAAI,eAAiB,GACrB,IAAI,eAAiB,GACrB,GAAI,cAAgB,EAAG,CACrB,eAAiB,YAAc,KAAK,OAAS,EAAI,IAAM,QACzD,CACA,GAAI,UAAY,KAAK,OAAS,EAAG,CAC/B,eAAiB,QACnB,CACA,MAAM,OAAS,UAAY,EAAI,MAC/B,MAAM,OAAS,IAAI,OAAO,SAAS,EAAE,SAAS,eAAe,CAAC,MAC9D,GAAI,SAAW,KAAK,KAAM,CACxB,MAAM,cAAgB,OAAO,QAAQ,QAAS,GAAG,EACjD,MAAM,aACJ,eAAiB,KAAK,MAAM,YAAa,KAAK,OAAS,CAAC,GACxD,QAAQ,SAAU,GAAG,EACvB,MAAM,QAAU,cAAgB,YAChC,MAAO,IAAI,MAAM,GAAG,cAAc,GAAG,SAAS,GAAG,cAAc;AAAA,GAAM,OAAO,GAC9E,CACA,MAAO,IAAI,MAAM,GAAG,cAAc,GAAG,SAAS,GAAG,cAAc,EACjE,CAAC,EACA,KAAK,IAAI,EACZ,MAAO,GAAG,KAAK,IAAI,KAAK,KAAK,OAAO;AAAA;AAAA,EAAO,IAAI;AAAA,CACjD,CACF,CAEA,MAAM,kBAAoB,kDAE1B,MAAM,OAAS,CACb,OAAQ,KACR,KAAM,MACN,UAAW,MACX,UAAW,KACX,MAAO,KACP,SAAU,IACZ,EAOA,MAAM,SAAW,QAAC,KAAM,OAAS,CAC/B,MAAM,IAAM,IAAI,OAAO,OAAO,OAAQ,MAAM,EAI5C,MAAM,KAAO,CAAE,KAAM,OAAQ,SAAU,CAAC,CAAE,EAI1C,IAAI,QAAU,KAId,MAAM,MAAQ,CAAC,IAAI,EAKnB,MAAM,cAAgB,OAAC,MAAS,CAE9B,OAAO,eAAe,KAAM,aAAc,CACxC,SAAU,KACV,MAAO,OACT,CAAC,EACD,QAAQ,SAAS,KAAK,IAAI,CAC5B,EAPsB,iBAYtB,IAAI,UAAa,SAAY,CAI3B,MAAM,KAAO,CACX,KAAM,UAEN,KAAM,MACN,KAAM,CACJ,OACF,CACF,EACA,cAAc,IAAI,EAClB,MAAM,YAAc,QAAQ,QAAQ,GAAG,EACvC,GAAI,aAAe,EAAG,CACpB,kBAAkB,UAAY,YAC9B,IAAI,YAAc,kBAAkB,KAAK,IAAI,EAC7C,MAAO,aAAe,KAAM,CAC1B,IAAI,SAAS,YAAY,CAAC,CAAC,EAAI,YAAY,CAAC,GAAK,YAAY,CAAC,EAC9D,YAAc,kBAAkB,KAAK,IAAI,CAC3C,CACF,CACF,EAKA,IAAI,wBAA2BA,OAAS,CAItC,MAAM,KAAO,CACX,KAAM,cACN,KAAMA,MAAK,KACX,MAAOA,MAAK,IACd,EACA,cAAc,IAAI,CACpB,EAKA,IAAI,UAAa,SAAY,CAI3B,MAAM,KAAO,CACX,KAAM,UACN,MAAO,QAAQ,KAAK,CACtB,EACA,cAAc,IAAI,CACpB,EAKA,IAAI,QAAW,OAAU,CAIvB,MAAM,KAAO,CACX,KAAM,QACN,MAAO,KACT,EACA,cAAc,IAAI,CACpB,EAKA,IAAI,UAAaA,OAAS,CAIxB,IAAI,QAAU,CACZ,KAAM,UACN,KAAMA,MAAK,KACX,WAAY,CAAC,EACb,SAAU,CAAC,CACb,EACA,SAAW,CAAC,KAAM,IAAI,IAAK,OAAO,QAAQA,MAAK,UAAU,EAAG,CAC1D,QAAQ,WAAW,IAAI,EAAI,KAAK,KAClC,CACA,cAAc,OAAO,EACrB,QAAU,QACV,MAAM,KAAK,OAAO,CACpB,EAKA,IAAI,OAAU,MAAS,CACrB,GAAI,QAAQ,OAAS,UAAW,CAE9B,GAAI,UAAU,SAAS,QAAQ,IAAI,EAAG,CAIpC,MAAM,KAAO,CACX,KAAM,OACN,MAAO,IACT,EACA,cAAc,IAAI,CACpB,SAAW,KAAK,KAAK,IAAI,EAAG,CAI1B,MAAM,KAAO,CACX,KAAM,OACN,MAAO,KAAK,KAAK,CACnB,EACA,cAAc,IAAI,CACpB,CACF,CACF,EAEA,IAAI,WAAa,IAAM,CACrB,MAAM,IAAI,EACV,QAAU,MAAM,MAAM,OAAS,CAAC,CAClC,EAKA,IAAI,QAAW,GAAM,CACnB,MAAM,MAAQ,IAAI,gBAChB,EAAE,OACF,EAAE,KAAO,EACT,EAAE,OACF,KACA,IACF,EACA,GAAI,EAAE,QAAQ,QAAQ,gBAAgB,IAAM,GAAI,CAC9C,MAAM,KACR,CACF,EAEA,IAAI,MAAM,IAAI,EAAE,MAAM,EACtB,OAAO,IACT,EAzKiB,YA0KjB,QAAQ,SAAW","names":["data"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/lib/parser.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('./types').XastNode} XastNode\n * @typedef {import('./types').XastInstruction} XastInstruction\n * @typedef {import('./types').XastDoctype} XastDoctype\n * @typedef {import('./types').XastComment} XastComment\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastCdata} XastCdata\n * @typedef {import('./types').XastText} XastText\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\n\n// @ts-ignore sax will be replaced with something else later\nconst SAX = require('@trysound/sax');\nconst { textElems } = require('../plugins/_collections.js');\n\nclass SvgoParserError extends Error {\n  /**\n   * @param message {string}\n   * @param line {number}\n   * @param column {number}\n   * @param source {string}\n   * @param file {void | string}\n   */\n  constructor(message, line, column, source, file) {\n    super(message);\n    this.name = 'SvgoParserError';\n    this.message = `${file || '<input>'}:${line}:${column}: ${message}`;\n    this.reason = message;\n    this.line = line;\n    this.column = column;\n    this.source = source;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, SvgoParserError);\n    }\n  }\n  toString() {\n    const lines = this.source.split(/\\r?\\n/);\n    const startLine = Math.max(this.line - 3, 0);\n    const endLine = Math.min(this.line + 2, lines.length);\n    const lineNumberWidth = String(endLine).length;\n    const startColumn = Math.max(this.column - 54, 0);\n    const endColumn = Math.max(this.column + 20, 80);\n    const code = lines\n      .slice(startLine, endLine)\n      .map((line, index) => {\n        const lineSlice = line.slice(startColumn, endColumn);\n        let ellipsisPrefix = '';\n        let ellipsisSuffix = '';\n        if (startColumn !== 0) {\n          ellipsisPrefix = startColumn > line.length - 1 ? ' ' : '…';\n        }\n        if (endColumn < line.length - 1) {\n          ellipsisSuffix = '…';\n        }\n        const number = startLine + 1 + index;\n        const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;\n        if (number === this.line) {\n          const gutterSpacing = gutter.replace(/[^|]/g, ' ');\n          const lineSpacing = (\n            ellipsisPrefix + line.slice(startColumn, this.column - 1)\n          ).replace(/[^\\t]/g, ' ');\n          const spacing = gutterSpacing + lineSpacing;\n          return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\\n ${spacing}^`;\n        }\n        return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;\n      })\n      .join('\\n');\n    return `${this.name}: ${this.message}\\n\\n${code}\\n`;\n  }\n}\n\nconst entityDeclaration = /<!ENTITY\\s+(\\S+)\\s+(?:'([^']+)'|\"([^\"]+)\")\\s*>/g;\n\nconst config = {\n  strict: true,\n  trim: false,\n  normalize: false,\n  lowercase: true,\n  xmlns: true,\n  position: true,\n};\n\n/**\n * Convert SVG (XML) string to SVG-as-JS object.\n *\n * @type {(data: string, from?: string) => XastRoot}\n */\nconst parseSvg = (data, from) => {\n  const sax = SAX.parser(config.strict, config);\n  /**\n   * @type {XastRoot}\n   */\n  const root = { type: 'root', children: [] };\n  /**\n   * @type {XastParent}\n   */\n  let current = root;\n  /**\n   * @type {Array<XastParent>}\n   */\n  const stack = [root];\n\n  /**\n   * @type {(node: XastChild) => void}\n   */\n  const pushToContent = (node) => {\n    // TODO remove legacy parentNode in v4\n    Object.defineProperty(node, 'parentNode', {\n      writable: true,\n      value: current,\n    });\n    current.children.push(node);\n  };\n\n  /**\n   * @type {(doctype: string) => void}\n   */\n  sax.ondoctype = (doctype) => {\n    /**\n     * @type {XastDoctype}\n     */\n    const node = {\n      type: 'doctype',\n      // TODO parse doctype for name, public and system to match xast\n      name: 'svg',\n      data: {\n        doctype,\n      },\n    };\n    pushToContent(node);\n    const subsetStart = doctype.indexOf('[');\n    if (subsetStart >= 0) {\n      entityDeclaration.lastIndex = subsetStart;\n      let entityMatch = entityDeclaration.exec(data);\n      while (entityMatch != null) {\n        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];\n        entityMatch = entityDeclaration.exec(data);\n      }\n    }\n  };\n\n  /**\n   * @type {(data: { name: string, body: string }) => void}\n   */\n  sax.onprocessinginstruction = (data) => {\n    /**\n     * @type {XastInstruction}\n     */\n    const node = {\n      type: 'instruction',\n      name: data.name,\n      value: data.body,\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(comment: string) => void}\n   */\n  sax.oncomment = (comment) => {\n    /**\n     * @type {XastComment}\n     */\n    const node = {\n      type: 'comment',\n      value: comment.trim(),\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(cdata: string) => void}\n   */\n  sax.oncdata = (cdata) => {\n    /**\n     * @type {XastCdata}\n     */\n    const node = {\n      type: 'cdata',\n      value: cdata,\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(data: { name: string, attributes: Record<string, { value: string }>}) => void}\n   */\n  sax.onopentag = (data) => {\n    /**\n     * @type {XastElement}\n     */\n    let element = {\n      type: 'element',\n      name: data.name,\n      attributes: {},\n      children: [],\n    };\n    for (const [name, attr] of Object.entries(data.attributes)) {\n      element.attributes[name] = attr.value;\n    }\n    pushToContent(element);\n    current = element;\n    stack.push(element);\n  };\n\n  /**\n   * @type {(text: string) => void}\n   */\n  sax.ontext = (text) => {\n    if (current.type === 'element') {\n      // prevent trimming of meaningful whitespace inside textual tags\n      if (textElems.includes(current.name)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text,\n        };\n        pushToContent(node);\n      } else if (/\\S/.test(text)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text.trim(),\n        };\n        pushToContent(node);\n      }\n    }\n  };\n\n  sax.onclosetag = () => {\n    stack.pop();\n    current = stack[stack.length - 1];\n  };\n\n  /**\n   * @type {(e: any) => void}\n   */\n  sax.onerror = (e) => {\n    const error = new SvgoParserError(\n      e.reason,\n      e.line + 1,\n      e.column,\n      data,\n      from\n    );\n    if (e.message.indexOf('Unexpected end') === -1) {\n      throw error;\n    }\n  };\n\n  sax.write(data).close();\n  return root;\n};\nexports.parseSvg = parseSvg;\n"]}}