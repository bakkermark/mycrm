{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{cleanupOutData}=require(\"../lib/svgo/tools.js\");const{transform2js,transformsMultiply,matrixToTransform}=require(\"./_transforms.js\");exports.name=\"convertTransform\";exports.description=\"collapses multiple transformations and optimizes it\";exports.fn=(_root,params)=>{const{convertToShorts:convertToShorts2=true,degPrecision,floatPrecision=3,transformPrecision=5,matrixToTransform:matrixToTransform2=true,shortTranslate=true,shortScale=true,shortRotate=true,removeUseless:removeUseless2=true,collapseIntoOne=true,leadingZero=true,negativeExtraSpace=false}=params;const newParams={convertToShorts:convertToShorts2,degPrecision,floatPrecision,transformPrecision,matrixToTransform:matrixToTransform2,shortTranslate,shortScale,shortRotate,removeUseless:removeUseless2,collapseIntoOne,leadingZero,negativeExtraSpace};return{element:{enter:node=>{if(node.attributes.transform!=null){convertTransform(node,\"transform\",newParams)}if(node.attributes.gradientTransform!=null){convertTransform(node,\"gradientTransform\",newParams)}if(node.attributes.patternTransform!=null){convertTransform(node,\"patternTransform\",newParams)}}}}};const convertTransform=__name((item,attrName,params)=>{let data=transform2js(item.attributes[attrName]);params=definePrecision(data,params);if(params.collapseIntoOne&&data.length>1){data=[transformsMultiply(data)]}if(params.convertToShorts){data=convertToShorts(data,params)}else{data.forEach(item2=>roundTransform(item2,params))}if(params.removeUseless){data=removeUseless(data)}if(data.length){item.attributes[attrName]=js2transform(data,params)}else{delete item.attributes[attrName]}},\"convertTransform\");const definePrecision=__name((data,{...newParams})=>{const matrixData=[];for(const item of data){if(item.name==\"matrix\"){matrixData.push(...item.data.slice(0,4))}}let significantDigits=newParams.transformPrecision;if(matrixData.length){newParams.transformPrecision=Math.min(newParams.transformPrecision,Math.max.apply(Math,matrixData.map(floatDigits))||newParams.transformPrecision);significantDigits=Math.max.apply(Math,matrixData.map(n=>n.toString().replace(/\\D+/g,\"\").length))}if(newParams.degPrecision==null){newParams.degPrecision=Math.max(0,Math.min(newParams.floatPrecision,significantDigits-2))}return newParams},\"definePrecision\");const degRound=__name((data,params)=>{if(params.degPrecision!=null&&params.degPrecision>=1&&params.floatPrecision<20){return smartRound(params.degPrecision,data)}else{return round(data)}},\"degRound\");const floatRound=__name((data,params)=>{if(params.floatPrecision>=1&&params.floatPrecision<20){return smartRound(params.floatPrecision,data)}else{return round(data)}},\"floatRound\");const transformRound=__name((data,params)=>{if(params.transformPrecision>=1&&params.floatPrecision<20){return smartRound(params.transformPrecision,data)}else{return round(data)}},\"transformRound\");const floatDigits=__name(n=>{const str=n.toString();return str.slice(str.indexOf(\".\")).length-1},\"floatDigits\");const convertToShorts=__name((transforms,params)=>{for(var i=0;i<transforms.length;i++){var transform=transforms[i];if(params.matrixToTransform&&transform.name===\"matrix\"){var decomposed=matrixToTransform(transform,params);if(js2transform(decomposed,params).length<=js2transform([transform],params).length){transforms.splice(i,1,...decomposed)}transform=transforms[i]}roundTransform(transform,params);if(params.shortTranslate&&transform.name===\"translate\"&&transform.data.length===2&&!transform.data[1]){transform.data.pop()}if(params.shortScale&&transform.name===\"scale\"&&transform.data.length===2&&transform.data[0]===transform.data[1]){transform.data.pop()}if(params.shortRotate&&transforms[i-2]&&transforms[i-2].name===\"translate\"&&transforms[i-1].name===\"rotate\"&&transforms[i].name===\"translate\"&&transforms[i-2].data[0]===-transforms[i].data[0]&&transforms[i-2].data[1]===-transforms[i].data[1]){transforms.splice(i-2,3,{name:\"rotate\",data:[transforms[i-1].data[0],transforms[i-2].data[0],transforms[i-2].data[1]]});i-=2}}return transforms},\"convertToShorts\");const removeUseless=__name(transforms=>{return transforms.filter(transform=>{if([\"translate\",\"rotate\",\"skewX\",\"skewY\"].indexOf(transform.name)>-1&&(transform.data.length==1||transform.name==\"rotate\")&&!transform.data[0]||transform.name==\"translate\"&&!transform.data[0]&&!transform.data[1]||transform.name==\"scale\"&&transform.data[0]==1&&(transform.data.length<2||transform.data[1]==1)||transform.name==\"matrix\"&&transform.data[0]==1&&transform.data[3]==1&&!(transform.data[1]||transform.data[2]||transform.data[4]||transform.data[5])){return false}return true})},\"removeUseless\");const js2transform=__name((transformJS,params)=>{const transformString=transformJS.map(transform=>{roundTransform(transform,params);return`${transform.name}(${cleanupOutData(transform.data,params)})`}).join(\"\");return transformString},\"js2transform\");const roundTransform=__name((transform,params)=>{switch(transform.name){case\"translate\":transform.data=floatRound(transform.data,params);break;case\"rotate\":transform.data=[...degRound(transform.data.slice(0,1),params),...floatRound(transform.data.slice(1),params)];break;case\"skewX\":case\"skewY\":transform.data=degRound(transform.data,params);break;case\"scale\":transform.data=transformRound(transform.data,params);break;case\"matrix\":transform.data=[...transformRound(transform.data.slice(0,4),params),...floatRound(transform.data.slice(4),params)];break}return transform},\"roundTransform\");const round=__name(data=>{return data.map(Math.round)},\"round\");const smartRound=__name((precision,data)=>{for(var i=data.length,tolerance=+Math.pow(.1,precision).toFixed(precision);i--;){if(Number(data[i].toFixed(precision))!==data[i]){var rounded=+data[i].toFixed(precision-1);data[i]=+Math.abs(rounded-data[i]).toFixed(precision+1)>=tolerance?+data[i].toFixed(precision):rounded}}return data},\"smartRound\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["convertToShorts","matrixToTransform","removeUseless","item"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/convertTransform.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst { cleanupOutData } = require('../lib/svgo/tools.js');\nconst {\n  transform2js,\n  transformsMultiply,\n  matrixToTransform,\n} = require('./_transforms.js');\n\nexports.name = 'convertTransform';\nexports.description = 'collapses multiple transformations and optimizes it';\n\n/**\n * Convert matrices to the short aliases,\n * convert long translate, scale or rotate transform notations to the shorts ones,\n * convert transforms to the matrices and multiply them all into one,\n * remove useless transforms.\n *\n * @see https://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'convertTransform'>}\n */\nexports.fn = (_root, params) => {\n  const {\n    convertToShorts = true,\n    // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default\n    degPrecision,\n    floatPrecision = 3,\n    transformPrecision = 5,\n    matrixToTransform = true,\n    shortTranslate = true,\n    shortScale = true,\n    shortRotate = true,\n    removeUseless = true,\n    collapseIntoOne = true,\n    leadingZero = true,\n    negativeExtraSpace = false,\n  } = params;\n  const newParams = {\n    convertToShorts,\n    degPrecision,\n    floatPrecision,\n    transformPrecision,\n    matrixToTransform,\n    shortTranslate,\n    shortScale,\n    shortRotate,\n    removeUseless,\n    collapseIntoOne,\n    leadingZero,\n    negativeExtraSpace,\n  };\n  return {\n    element: {\n      enter: (node) => {\n        // transform\n        if (node.attributes.transform != null) {\n          convertTransform(node, 'transform', newParams);\n        }\n        // gradientTransform\n        if (node.attributes.gradientTransform != null) {\n          convertTransform(node, 'gradientTransform', newParams);\n        }\n        // patternTransform\n        if (node.attributes.patternTransform != null) {\n          convertTransform(node, 'patternTransform', newParams);\n        }\n      },\n    },\n  };\n};\n\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   degPrecision?: number,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Main function.\n *\n * @type {(item: XastElement, attrName: string, params: TransformParams) => void}\n */\nconst convertTransform = (item, attrName, params) => {\n  let data = transform2js(item.attributes[attrName]);\n  params = definePrecision(data, params);\n\n  if (params.collapseIntoOne && data.length > 1) {\n    data = [transformsMultiply(data)];\n  }\n\n  if (params.convertToShorts) {\n    data = convertToShorts(data, params);\n  } else {\n    data.forEach((item) => roundTransform(item, params));\n  }\n\n  if (params.removeUseless) {\n    data = removeUseless(data);\n  }\n\n  if (data.length) {\n    item.attributes[attrName] = js2transform(data, params);\n  } else {\n    delete item.attributes[attrName];\n  }\n};\n\n/**\n * Defines precision to work with certain parts.\n * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),\n * floatPrecision - for translate including two last matrix and rotate parameters,\n * degPrecision - for rotate and skew. By default it's equal to (rougly)\n * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.\n *\n * @type {(data: Array<TransformItem>, params: TransformParams) => TransformParams}\n *\n * clone params so it don't affect other elements transformations.\n */\nconst definePrecision = (data, { ...newParams }) => {\n  const matrixData = [];\n  for (const item of data) {\n    if (item.name == 'matrix') {\n      matrixData.push(...item.data.slice(0, 4));\n    }\n  }\n  let significantDigits = newParams.transformPrecision;\n  // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.\n  if (matrixData.length) {\n    newParams.transformPrecision = Math.min(\n      newParams.transformPrecision,\n      Math.max.apply(Math, matrixData.map(floatDigits)) ||\n        newParams.transformPrecision\n    );\n    significantDigits = Math.max.apply(\n      Math,\n      matrixData.map(\n        (n) => n.toString().replace(/\\D+/g, '').length // Number of digits in a number. 123.45 → 5\n      )\n    );\n  }\n  // No sense in angle precision more then number of significant digits in matrix.\n  if (newParams.degPrecision == null) {\n    newParams.degPrecision = Math.max(\n      0,\n      Math.min(newParams.floatPrecision, significantDigits - 2)\n    );\n  }\n  return newParams;\n};\n\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst degRound = (data, params) => {\n  if (\n    params.degPrecision != null &&\n    params.degPrecision >= 1 &&\n    params.floatPrecision < 20\n  ) {\n    return smartRound(params.degPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst floatRound = (data, params) => {\n  if (params.floatPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.floatPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst transformRound = (data, params) => {\n  if (params.transformPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.transformPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n\n/**\n * Returns number of digits after the point. 0.125 → 3\n *\n * @type {(n: number) => number}\n */\nconst floatDigits = (n) => {\n  const str = n.toString();\n  return str.slice(str.indexOf('.')).length - 1;\n};\n\n/**\n * Convert transforms to the shorthand alternatives.\n *\n * @type {(transforms: Array<TransformItem>, params: TransformParams) => Array<TransformItem>}\n */\nconst convertToShorts = (transforms, params) => {\n  for (var i = 0; i < transforms.length; i++) {\n    var transform = transforms[i];\n\n    // convert matrix to the short aliases\n    if (params.matrixToTransform && transform.name === 'matrix') {\n      var decomposed = matrixToTransform(transform, params);\n      if (\n        js2transform(decomposed, params).length <=\n        js2transform([transform], params).length\n      ) {\n        transforms.splice(i, 1, ...decomposed);\n      }\n      transform = transforms[i];\n    }\n\n    // fixed-point numbers\n    // 12.754997 → 12.755\n    roundTransform(transform, params);\n\n    // convert long translate transform notation to the shorts one\n    // translate(10 0) → translate(10)\n    if (\n      params.shortTranslate &&\n      transform.name === 'translate' &&\n      transform.data.length === 2 &&\n      !transform.data[1]\n    ) {\n      transform.data.pop();\n    }\n\n    // convert long scale transform notation to the shorts one\n    // scale(2 2) → scale(2)\n    if (\n      params.shortScale &&\n      transform.name === 'scale' &&\n      transform.data.length === 2 &&\n      transform.data[0] === transform.data[1]\n    ) {\n      transform.data.pop();\n    }\n\n    // convert long rotate transform notation to the short one\n    // translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)\n    if (\n      params.shortRotate &&\n      transforms[i - 2] &&\n      transforms[i - 2].name === 'translate' &&\n      transforms[i - 1].name === 'rotate' &&\n      transforms[i].name === 'translate' &&\n      transforms[i - 2].data[0] === -transforms[i].data[0] &&\n      transforms[i - 2].data[1] === -transforms[i].data[1]\n    ) {\n      transforms.splice(i - 2, 3, {\n        name: 'rotate',\n        data: [\n          transforms[i - 1].data[0],\n          transforms[i - 2].data[0],\n          transforms[i - 2].data[1],\n        ],\n      });\n\n      // splice compensation\n      i -= 2;\n    }\n  }\n\n  return transforms;\n};\n\n/**\n * Remove useless transforms.\n *\n * @type {(trasforms: Array<TransformItem>) => Array<TransformItem>}\n */\nconst removeUseless = (transforms) => {\n  return transforms.filter((transform) => {\n    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)\n    if (\n      (['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 &&\n        (transform.data.length == 1 || transform.name == 'rotate') &&\n        !transform.data[0]) ||\n      // translate(0, 0)\n      (transform.name == 'translate' &&\n        !transform.data[0] &&\n        !transform.data[1]) ||\n      // scale(1)\n      (transform.name == 'scale' &&\n        transform.data[0] == 1 &&\n        (transform.data.length < 2 || transform.data[1] == 1)) ||\n      // matrix(1 0 0 1 0 0)\n      (transform.name == 'matrix' &&\n        transform.data[0] == 1 &&\n        transform.data[3] == 1 &&\n        !(\n          transform.data[1] ||\n          transform.data[2] ||\n          transform.data[4] ||\n          transform.data[5]\n        ))\n    ) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\n/**\n * Convert transforms JS representation to string.\n *\n * @type {(transformJS: Array<TransformItem>, params: TransformParams) => string}\n */\nconst js2transform = (transformJS, params) => {\n  const transformString = transformJS\n    .map((transform) => {\n      roundTransform(transform, params);\n      return `${transform.name}(${cleanupOutData(transform.data, params)})`;\n    })\n    .join('');\n\n  return transformString;\n};\n\n/**\n * @type {(transform: TransformItem, params: TransformParams) => TransformItem}\n */\nconst roundTransform = (transform, params) => {\n  switch (transform.name) {\n    case 'translate':\n      transform.data = floatRound(transform.data, params);\n      break;\n    case 'rotate':\n      transform.data = [\n        ...degRound(transform.data.slice(0, 1), params),\n        ...floatRound(transform.data.slice(1), params),\n      ];\n      break;\n    case 'skewX':\n    case 'skewY':\n      transform.data = degRound(transform.data, params);\n      break;\n    case 'scale':\n      transform.data = transformRound(transform.data, params);\n      break;\n    case 'matrix':\n      transform.data = [\n        ...transformRound(transform.data.slice(0, 4), params),\n        ...floatRound(transform.data.slice(4), params),\n      ];\n      break;\n  }\n  return transform;\n};\n\n/**\n * Rounds numbers in array.\n *\n * @type {(data: Array<number>) => Array<number>}\n */\nconst round = (data) => {\n  return data.map(Math.round);\n};\n\n/**\n * Decrease accuracy of floating-point numbers\n * in transforms keeping a specified number of decimals.\n * Smart rounds values like 2.349 to 2.35.\n *\n * @type {(precision: number, data: Array<number>) => Array<number>}\n */\nconst smartRound = (precision, data) => {\n  for (\n    var i = data.length,\n      tolerance = +Math.pow(0.1, precision).toFixed(precision);\n    i--;\n\n  ) {\n    if (Number(data[i].toFixed(precision)) !== data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] =\n        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance\n          ? +data[i].toFixed(precision)\n          : rounded;\n    }\n  }\n  return data;\n};\n"]}}