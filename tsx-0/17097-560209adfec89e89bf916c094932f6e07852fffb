{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{visitSkip}=require(\"../lib/xast.js\");const{hasScripts}=require(\"../lib/svgo/tools\");const{referencesProps}=require(\"./_collections.js\");exports.name=\"cleanupIds\";exports.description=\"removes unused IDs and minifies used\";const regReferencesUrl=/\\burl\\(([\"'])?#(.+?)\\1\\)/g;const regReferencesHref=/^#(.+?)$/;const regReferencesBegin=/(\\D+)\\./;const generateIdChars=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"];const maxIdIndex=generateIdChars.length-1;const hasStringPrefix=__name((string,prefixes)=>{for(const prefix of prefixes){if(string.startsWith(prefix)){return true}}return false},\"hasStringPrefix\");const generateId=__name(currentId=>{if(currentId==null){return[0]}currentId[currentId.length-1]+=1;for(let i=currentId.length-1;i>0;i--){if(currentId[i]>maxIdIndex){currentId[i]=0;if(currentId[i-1]!==void 0){currentId[i-1]++}}}if(currentId[0]>maxIdIndex){currentId[0]=0;currentId.unshift(0)}return currentId},\"generateId\");const getIdString=__name(arr=>{return arr.map(i=>generateIdChars[i]).join(\"\")},\"getIdString\");exports.fn=(_root,params)=>{const{remove=true,minify=true,preserve=[],preservePrefixes=[],force=false}=params;const preserveIds=new Set(Array.isArray(preserve)?preserve:preserve?[preserve]:[]);const preserveIdPrefixes=Array.isArray(preservePrefixes)?preservePrefixes:preservePrefixes?[preservePrefixes]:[];const nodeById=new Map;const referencesById=new Map;let deoptimized=false;return{element:{enter:node=>{if(!force){if(node.name===\"style\"&&node.children.length!==0||hasScripts(node)){deoptimized=true;return}if(node.name===\"svg\"){let hasDefsOnly=true;for(const child of node.children){if(child.type!==\"element\"||child.name!==\"defs\"){hasDefsOnly=false;break}}if(hasDefsOnly){return visitSkip}}}for(const[name,value]of Object.entries(node.attributes)){if(name===\"id\"){const id=value;if(nodeById.has(id)){delete node.attributes.id}else{nodeById.set(id,node)}}else{let ids=[];if(referencesProps.includes(name)){const matches=value.matchAll(regReferencesUrl);for(const match of matches){ids.push(match[2])}}if(name===\"href\"||name.endsWith(\":href\")){const match=value.match(regReferencesHref);if(match!=null){ids.push(match[1])}}if(name===\"begin\"){const match=value.match(regReferencesBegin);if(match!=null){ids.push(match[1])}}for(const id of ids){let refs=referencesById.get(id);if(refs==null){refs=[];referencesById.set(id,refs)}refs.push({element:node,name})}}}}},root:{exit:()=>{if(deoptimized){return}const isIdPreserved=__name(id=>preserveIds.has(id)||hasStringPrefix(id,preserveIdPrefixes),\"isIdPreserved\");let currentId=null;for(const[id,refs]of referencesById){const node=nodeById.get(id);if(node!=null){if(minify&&isIdPreserved(id)===false){let currentIdString=null;do{currentId=generateId(currentId);currentIdString=getIdString(currentId)}while(isIdPreserved(currentIdString)||referencesById.has(currentIdString)&&nodeById.get(currentIdString)==null);node.attributes.id=currentIdString;for(const{element,name}of refs){const value=element.attributes[name];if(value.includes(\"#\")){element.attributes[name]=value.replace(`#${id}`,`#${currentIdString}`)}else{element.attributes[name]=value.replace(`${id}.`,`${currentIdString}.`)}}}nodeById.delete(id)}}if(remove){for(const[id,node]of nodeById){if(isIdPreserved(id)===false){delete node.attributes.id}}}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/cleanupIds.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst { visitSkip } = require('../lib/xast.js');\nconst { hasScripts } = require('../lib/svgo/tools');\nconst { referencesProps } = require('./_collections.js');\n\nexports.name = 'cleanupIds';\nexports.description = 'removes unused IDs and minifies used';\n\nconst regReferencesUrl = /\\burl\\(([\"'])?#(.+?)\\1\\)/g;\nconst regReferencesHref = /^#(.+?)$/;\nconst regReferencesBegin = /(\\D+)\\./;\nconst generateIdChars = [\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n  'A',\n  'B',\n  'C',\n  'D',\n  'E',\n  'F',\n  'G',\n  'H',\n  'I',\n  'J',\n  'K',\n  'L',\n  'M',\n  'N',\n  'O',\n  'P',\n  'Q',\n  'R',\n  'S',\n  'T',\n  'U',\n  'V',\n  'W',\n  'X',\n  'Y',\n  'Z',\n];\nconst maxIdIndex = generateIdChars.length - 1;\n\n/**\n * Check if an ID starts with any one of a list of strings.\n *\n * @type {(string: string, prefixes: Array<string>) => boolean}\n */\nconst hasStringPrefix = (string, prefixes) => {\n  for (const prefix of prefixes) {\n    if (string.startsWith(prefix)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Generate unique minimal ID.\n *\n * @param {?number[]} currentId\n * @returns {number[]}\n */\nconst generateId = (currentId) => {\n  if (currentId == null) {\n    return [0];\n  }\n  currentId[currentId.length - 1] += 1;\n  for (let i = currentId.length - 1; i > 0; i--) {\n    if (currentId[i] > maxIdIndex) {\n      currentId[i] = 0;\n      if (currentId[i - 1] !== undefined) {\n        currentId[i - 1]++;\n      }\n    }\n  }\n  if (currentId[0] > maxIdIndex) {\n    currentId[0] = 0;\n    currentId.unshift(0);\n  }\n  return currentId;\n};\n\n/**\n * Get string from generated ID array.\n *\n * @type {(arr: Array<number>) => string}\n */\nconst getIdString = (arr) => {\n  return arr.map((i) => generateIdChars[i]).join('');\n};\n\n/**\n * Remove unused and minify used IDs\n * (only if there are no any <style> or <script>).\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'cleanupIds'>}\n */\nexports.fn = (_root, params) => {\n  const {\n    remove = true,\n    minify = true,\n    preserve = [],\n    preservePrefixes = [],\n    force = false,\n  } = params;\n  const preserveIds = new Set(\n    Array.isArray(preserve) ? preserve : preserve ? [preserve] : []\n  );\n  const preserveIdPrefixes = Array.isArray(preservePrefixes)\n    ? preservePrefixes\n    : preservePrefixes\n    ? [preservePrefixes]\n    : [];\n  /**\n   * @type {Map<string, XastElement>}\n   */\n  const nodeById = new Map();\n  /**\n   * @type {Map<string, Array<{element: XastElement, name: string }>>}\n   */\n  const referencesById = new Map();\n  let deoptimized = false;\n\n  return {\n    element: {\n      enter: (node) => {\n        if (!force) {\n          // deoptimize if style or scripts are present\n          if (\n            (node.name === 'style' && node.children.length !== 0) ||\n            hasScripts(node)\n          ) {\n            deoptimized = true;\n            return;\n          }\n\n          // avoid removing IDs if the whole SVG consists only of defs\n          if (node.name === 'svg') {\n            let hasDefsOnly = true;\n            for (const child of node.children) {\n              if (child.type !== 'element' || child.name !== 'defs') {\n                hasDefsOnly = false;\n                break;\n              }\n            }\n            if (hasDefsOnly) {\n              return visitSkip;\n            }\n          }\n        }\n\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (name === 'id') {\n            // collect all ids\n            const id = value;\n            if (nodeById.has(id)) {\n              delete node.attributes.id; // remove repeated id\n            } else {\n              nodeById.set(id, node);\n            }\n          } else {\n            // collect all references\n            /**\n             * @type {string[]}\n             */\n            let ids = [];\n            if (referencesProps.includes(name)) {\n              const matches = value.matchAll(regReferencesUrl);\n              for (const match of matches) {\n                ids.push(match[2]); // url() reference\n              }\n            }\n            if (name === 'href' || name.endsWith(':href')) {\n              const match = value.match(regReferencesHref);\n              if (match != null) {\n                ids.push(match[1]); // href reference\n              }\n            }\n            if (name === 'begin') {\n              const match = value.match(regReferencesBegin);\n              if (match != null) {\n                ids.push(match[1]); // href reference\n              }\n            }\n            for (const id of ids) {\n              let refs = referencesById.get(id);\n              if (refs == null) {\n                refs = [];\n                referencesById.set(id, refs);\n              }\n              refs.push({ element: node, name });\n            }\n          }\n        }\n      },\n    },\n\n    root: {\n      exit: () => {\n        if (deoptimized) {\n          return;\n        }\n        /**\n         * @param {string} id\n         * @returns {boolean}\n         */\n        const isIdPreserved = (id) =>\n          preserveIds.has(id) || hasStringPrefix(id, preserveIdPrefixes);\n        /** @type {?number[]} */\n        let currentId = null;\n        for (const [id, refs] of referencesById) {\n          const node = nodeById.get(id);\n          if (node != null) {\n            // replace referenced IDs with the minified ones\n            if (minify && isIdPreserved(id) === false) {\n              /** @type {?string} */\n              let currentIdString = null;\n              do {\n                currentId = generateId(currentId);\n                currentIdString = getIdString(currentId);\n              } while (\n                isIdPreserved(currentIdString) ||\n                (referencesById.has(currentIdString) &&\n                  nodeById.get(currentIdString) == null)\n              );\n              node.attributes.id = currentIdString;\n              for (const { element, name } of refs) {\n                const value = element.attributes[name];\n                if (value.includes('#')) {\n                  // replace id in href and url()\n                  element.attributes[name] = value.replace(\n                    `#${id}`,\n                    `#${currentIdString}`\n                  );\n                } else {\n                  // replace id in begin attribute\n                  element.attributes[name] = value.replace(\n                    `${id}.`,\n                    `${currentIdString}.`\n                  );\n                }\n              }\n            }\n            // keep referenced node\n            nodeById.delete(id);\n          }\n        }\n        // remove non-referenced IDs attributes from elements\n        if (remove) {\n          for (const [id, node] of nodeById) {\n            if (isIdPreserved(id) === false) {\n              delete node.attributes.id;\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"]}}