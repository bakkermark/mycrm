{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});exports.FormattingElementList=exports.EntryType=void 0;const NOAH_ARK_CAPACITY=3;var EntryType;(function(EntryType2){EntryType2[EntryType2[\"Marker\"]=0]=\"Marker\";EntryType2[EntryType2[\"Element\"]=1]=\"Element\"})(EntryType=exports.EntryType||(exports.EntryType={}));const MARKER={type:EntryType.Marker};class FormattingElementList{static{__name(this,\"FormattingElementList\")}constructor(treeAdapter){this.treeAdapter=treeAdapter;this.entries=[];this.bookmark=null}_getNoahArkConditionCandidates(newElement,neAttrs){const candidates=[];const neAttrsLength=neAttrs.length;const neTagName=this.treeAdapter.getTagName(newElement);const neNamespaceURI=this.treeAdapter.getNamespaceURI(newElement);for(let i=0;i<this.entries.length;i++){const entry=this.entries[i];if(entry.type===EntryType.Marker){break}const{element}=entry;if(this.treeAdapter.getTagName(element)===neTagName&&this.treeAdapter.getNamespaceURI(element)===neNamespaceURI){const elementAttrs=this.treeAdapter.getAttrList(element);if(elementAttrs.length===neAttrsLength){candidates.push({idx:i,attrs:elementAttrs})}}}return candidates}_ensureNoahArkCondition(newElement){if(this.entries.length<NOAH_ARK_CAPACITY)return;const neAttrs=this.treeAdapter.getAttrList(newElement);const candidates=this._getNoahArkConditionCandidates(newElement,neAttrs);if(candidates.length<NOAH_ARK_CAPACITY)return;const neAttrsMap=new Map(neAttrs.map(neAttr=>[neAttr.name,neAttr.value]));let validCandidates=0;for(let i=0;i<candidates.length;i++){const candidate=candidates[i];if(candidate.attrs.every(cAttr=>neAttrsMap.get(cAttr.name)===cAttr.value)){validCandidates+=1;if(validCandidates>=NOAH_ARK_CAPACITY){this.entries.splice(candidate.idx,1)}}}}insertMarker(){this.entries.unshift(MARKER)}pushElement(element,token){this._ensureNoahArkCondition(element);this.entries.unshift({type:EntryType.Element,element,token})}insertElementAfterBookmark(element,token){const bookmarkIdx=this.entries.indexOf(this.bookmark);this.entries.splice(bookmarkIdx,0,{type:EntryType.Element,element,token})}removeEntry(entry){const entryIndex=this.entries.indexOf(entry);if(entryIndex>=0){this.entries.splice(entryIndex,1)}}clearToLastMarker(){const markerIdx=this.entries.indexOf(MARKER);if(markerIdx>=0){this.entries.splice(0,markerIdx+1)}else{this.entries.length=0}}getElementEntryInScopeWithTagName(tagName){const entry=this.entries.find(entry2=>entry2.type===EntryType.Marker||this.treeAdapter.getTagName(entry2.element)===tagName);return entry&&entry.type===EntryType.Element?entry:null}getElementEntry(element){return this.entries.find(entry=>entry.type===EntryType.Element&&entry.element===element)}}exports.FormattingElementList=FormattingElementList;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["EntryType","entry"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/cjs/parser/formatting-element-list.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormattingElementList = exports.EntryType = void 0;\n//Const\nconst NOAH_ARK_CAPACITY = 3;\nvar EntryType;\n(function (EntryType) {\n    EntryType[EntryType[\"Marker\"] = 0] = \"Marker\";\n    EntryType[EntryType[\"Element\"] = 1] = \"Element\";\n})(EntryType = exports.EntryType || (exports.EntryType = {}));\nconst MARKER = { type: EntryType.Marker };\n//List of formatting elements\nclass FormattingElementList {\n    constructor(treeAdapter) {\n        this.treeAdapter = treeAdapter;\n        this.entries = [];\n        this.bookmark = null;\n    }\n    //Noah Ark's condition\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n    //lightweight heuristics without thorough attributes check.\n    _getNoahArkConditionCandidates(newElement, neAttrs) {\n        const candidates = [];\n        const neAttrsLength = neAttrs.length;\n        const neTagName = this.treeAdapter.getTagName(newElement);\n        const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n        for (let i = 0; i < this.entries.length; i++) {\n            const entry = this.entries[i];\n            if (entry.type === EntryType.Marker) {\n                break;\n            }\n            const { element } = entry;\n            if (this.treeAdapter.getTagName(element) === neTagName &&\n                this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {\n                const elementAttrs = this.treeAdapter.getAttrList(element);\n                if (elementAttrs.length === neAttrsLength) {\n                    candidates.push({ idx: i, attrs: elementAttrs });\n                }\n            }\n        }\n        return candidates;\n    }\n    _ensureNoahArkCondition(newElement) {\n        if (this.entries.length < NOAH_ARK_CAPACITY)\n            return;\n        const neAttrs = this.treeAdapter.getAttrList(newElement);\n        const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);\n        if (candidates.length < NOAH_ARK_CAPACITY)\n            return;\n        //NOTE: build attrs map for the new element, so we can perform fast lookups\n        const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));\n        let validCandidates = 0;\n        //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met\n        for (let i = 0; i < candidates.length; i++) {\n            const candidate = candidates[i];\n            // We know that `candidate.attrs.length === neAttrs.length`\n            if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {\n                validCandidates += 1;\n                if (validCandidates >= NOAH_ARK_CAPACITY) {\n                    this.entries.splice(candidate.idx, 1);\n                }\n            }\n        }\n    }\n    //Mutations\n    insertMarker() {\n        this.entries.unshift(MARKER);\n    }\n    pushElement(element, token) {\n        this._ensureNoahArkCondition(element);\n        this.entries.unshift({\n            type: EntryType.Element,\n            element,\n            token,\n        });\n    }\n    insertElementAfterBookmark(element, token) {\n        const bookmarkIdx = this.entries.indexOf(this.bookmark);\n        this.entries.splice(bookmarkIdx, 0, {\n            type: EntryType.Element,\n            element,\n            token,\n        });\n    }\n    removeEntry(entry) {\n        const entryIndex = this.entries.indexOf(entry);\n        if (entryIndex >= 0) {\n            this.entries.splice(entryIndex, 1);\n        }\n    }\n    /**\n     * Clears the list of formatting elements up to the last marker.\n     *\n     * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker\n     */\n    clearToLastMarker() {\n        const markerIdx = this.entries.indexOf(MARKER);\n        if (markerIdx >= 0) {\n            this.entries.splice(0, markerIdx + 1);\n        }\n        else {\n            this.entries.length = 0;\n        }\n    }\n    //Search\n    getElementEntryInScopeWithTagName(tagName) {\n        const entry = this.entries.find((entry) => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);\n        return entry && entry.type === EntryType.Element ? entry : null;\n    }\n    getElementEntry(element) {\n        return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);\n    }\n}\nexports.FormattingElementList = FormattingElementList;\n//# sourceMappingURL=formatting-element-list.js.map"]}}