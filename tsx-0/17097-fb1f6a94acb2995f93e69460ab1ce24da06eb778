{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const regTransformTypes=/matrix|translate|scale|rotate|skewX|skewY/;const regTransformSplit=/\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;const regNumericValues=/[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;exports.transform2js=transformString=>{const transforms=[];let current=null;for(const item of transformString.split(regTransformSplit)){var num;if(item){if(regTransformTypes.test(item)){current={name:item,data:[]};transforms.push(current)}else{while(num=regNumericValues.exec(item)){num=Number(num);if(current!=null){current.data.push(num)}}}}}return current==null||current.data.length==0?[]:transforms};exports.transformsMultiply=transforms=>{const matrixData=transforms.map(transform=>{if(transform.name===\"matrix\"){return transform.data}return transformToMatrix(transform)});const matrixTransform={name:\"matrix\",data:matrixData.length>0?matrixData.reduce(multiplyTransformMatrices):[]};return matrixTransform};const mth={rad:deg=>{return deg*Math.PI/180},deg:rad=>{return rad*180/Math.PI},cos:deg=>{return Math.cos(mth.rad(deg))},acos:(val,floatPrecision)=>{return Number(mth.deg(Math.acos(val)).toFixed(floatPrecision))},sin:deg=>{return Math.sin(mth.rad(deg))},asin:(val,floatPrecision)=>{return Number(mth.deg(Math.asin(val)).toFixed(floatPrecision))},tan:deg=>{return Math.tan(mth.rad(deg))},atan:(val,floatPrecision)=>{return Number(mth.deg(Math.atan(val)).toFixed(floatPrecision))}};exports.matrixToTransform=(transform,params)=>{let floatPrecision=params.floatPrecision;let data=transform.data;let transforms=[];let sx=Number(Math.hypot(data[0],data[1]).toFixed(params.transformPrecision));let sy=Number(((data[0]*data[3]-data[1]*data[2])/sx).toFixed(params.transformPrecision));let colsSum=data[0]*data[2]+data[1]*data[3];let rowsSum=data[0]*data[1]+data[2]*data[3];let scaleBefore=rowsSum!=0||sx==sy;if(data[4]||data[5]){transforms.push({name:\"translate\",data:data.slice(4,data[5]?6:5)})}if(!data[1]&&data[2]){transforms.push({name:\"skewX\",data:[mth.atan(data[2]/sy,floatPrecision)]})}else if(data[1]&&!data[2]){transforms.push({name:\"skewY\",data:[mth.atan(data[1]/data[0],floatPrecision)]});sx=data[0];sy=data[3]}else if(!colsSum||sx==1&&sy==1||!scaleBefore){if(!scaleBefore){sx=(data[0]<0?-1:1)*Math.hypot(data[0],data[2]);sy=(data[3]<0?-1:1)*Math.hypot(data[1],data[3]);transforms.push({name:\"scale\",data:[sx,sy]})}var angle=Math.min(Math.max(-1,data[0]/sx),1),rotate=[mth.acos(angle,floatPrecision)*((scaleBefore?1:sy)*data[1]<0?-1:1)];if(rotate[0])transforms.push({name:\"rotate\",data:rotate});if(rowsSum&&colsSum)transforms.push({name:\"skewX\",data:[mth.atan(colsSum/(sx*sx),floatPrecision)]});if(rotate[0]&&(data[4]||data[5])){transforms.shift();var cos=data[0]/sx,sin=data[1]/(scaleBefore?sx:sy),x=data[4]*(scaleBefore?1:sy),y=data[5]*(scaleBefore?1:sx),denom=(Math.pow(1-cos,2)+Math.pow(sin,2))*(scaleBefore?1:sx*sy);rotate.push(((1-cos)*x-sin*y)/denom);rotate.push(((1-cos)*y+sin*x)/denom)}}else if(data[1]||data[2]){return[transform]}if(scaleBefore&&(sx!=1||sy!=1)||!transforms.length)transforms.push({name:\"scale\",data:sx==sy?[sx]:[sx,sy]});return transforms};const transformToMatrix=__name(transform=>{if(transform.name===\"matrix\"){return transform.data}switch(transform.name){case\"translate\":return[1,0,0,1,transform.data[0],transform.data[1]||0];case\"scale\":return[transform.data[0],0,0,transform.data[1]||transform.data[0],0,0];case\"rotate\":var cos=mth.cos(transform.data[0]),sin=mth.sin(transform.data[0]),cx=transform.data[1]||0,cy=transform.data[2]||0;return[cos,sin,-sin,cos,(1-cos)*cx+sin*cy,(1-cos)*cy-sin*cx];case\"skewX\":return[1,0,mth.tan(transform.data[0]),1,0,0];case\"skewY\":return[1,mth.tan(transform.data[0]),0,1,0,0];default:throw Error(`Unknown transform ${transform.name}`)}},\"transformToMatrix\");exports.transformArc=(cursor,arc,transform)=>{const x=arc[5]-cursor[0];const y=arc[6]-cursor[1];let a=arc[0];let b=arc[1];const rot=arc[2]*Math.PI/180;const cos=Math.cos(rot);const sin=Math.sin(rot);if(a>0&&b>0){let h=Math.pow(x*cos+y*sin,2)/(4*a*a)+Math.pow(y*cos-x*sin,2)/(4*b*b);if(h>1){h=Math.sqrt(h);a*=h;b*=h}}const ellipse=[a*cos,a*sin,-b*sin,b*cos,0,0];const m=multiplyTransformMatrices(transform,ellipse);const lastCol=m[2]*m[2]+m[3]*m[3];const squareSum=m[0]*m[0]+m[1]*m[1]+lastCol;const root=Math.hypot(m[0]-m[3],m[1]+m[2])*Math.hypot(m[0]+m[3],m[1]-m[2]);if(!root){arc[0]=arc[1]=Math.sqrt(squareSum/2);arc[2]=0}else{const majorAxisSqr=(squareSum+root)/2;const minorAxisSqr=(squareSum-root)/2;const major=Math.abs(majorAxisSqr-lastCol)>1e-6;const sub=(major?majorAxisSqr:minorAxisSqr)-lastCol;const rowsSum=m[0]*m[2]+m[1]*m[3];const term1=m[0]*sub+m[2]*rowsSum;const term2=m[1]*sub+m[3]*rowsSum;arc[0]=Math.sqrt(majorAxisSqr);arc[1]=Math.sqrt(minorAxisSqr);arc[2]=((major?term2<0:term1>0)?-1:1)*Math.acos((major?term1:term2)/Math.hypot(term1,term2))*180/Math.PI}if(transform[0]<0!==transform[3]<0){arc[4]=1-arc[4]}return arc};const multiplyTransformMatrices=__name((a,b)=>{return[a[0]*b[0]+a[2]*b[1],a[1]*b[0]+a[3]*b[1],a[0]*b[2]+a[2]*b[3],a[1]*b[2]+a[3]*b[3],a[0]*b[4]+a[2]*b[5]+a[4],a[1]*b[4]+a[3]*b[5]+a[5]]},\"multiplyTransformMatrices\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/_transforms.js"],"sourcesContent":["'use strict';\n\nconst regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/;\nconst regTransformSplit =\n  /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;\nconst regNumericValues = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Convert transform string to JS representation.\n *\n * @type {(transformString: string) => Array<TransformItem>}\n */\nexports.transform2js = (transformString) => {\n  // JS representation of the transform data\n  /**\n   * @type {Array<TransformItem>}\n   */\n  const transforms = [];\n  // current transform context\n  /**\n   * @type {?TransformItem}\n   */\n  let current = null;\n  // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']\n  for (const item of transformString.split(regTransformSplit)) {\n    var num;\n    if (item) {\n      // if item is a translate function\n      if (regTransformTypes.test(item)) {\n        // then collect it and change current context\n        current = { name: item, data: [] };\n        transforms.push(current);\n        // else if item is data\n      } else {\n        // then split it into [10, 50] and collect as context.data\n        // eslint-disable-next-line no-cond-assign\n        while ((num = regNumericValues.exec(item))) {\n          num = Number(num);\n          if (current != null) {\n            current.data.push(num);\n          }\n        }\n      }\n    }\n  }\n  // return empty array if broken transform (no data)\n  return current == null || current.data.length == 0 ? [] : transforms;\n};\n\n/**\n * Multiply transforms into one.\n *\n * @type {(transforms: Array<TransformItem>) => TransformItem}\n */\nexports.transformsMultiply = (transforms) => {\n  // convert transforms objects to the matrices\n  const matrixData = transforms.map((transform) => {\n    if (transform.name === 'matrix') {\n      return transform.data;\n    }\n    return transformToMatrix(transform);\n  });\n  // multiply all matrices into one\n  const matrixTransform = {\n    name: 'matrix',\n    data:\n      matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : [],\n  };\n  return matrixTransform;\n};\n\n/**\n * math utilities in radians.\n */\nconst mth = {\n  /**\n   * @type {(deg: number) => number}\n   */\n  rad: (deg) => {\n    return (deg * Math.PI) / 180;\n  },\n\n  /**\n   * @type {(rad: number) => number}\n   */\n  deg: (rad) => {\n    return (rad * 180) / Math.PI;\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  cos: (deg) => {\n    return Math.cos(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  acos: (val, floatPrecision) => {\n    return Number(mth.deg(Math.acos(val)).toFixed(floatPrecision));\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  sin: (deg) => {\n    return Math.sin(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  asin: (val, floatPrecision) => {\n    return Number(mth.deg(Math.asin(val)).toFixed(floatPrecision));\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  tan: (deg) => {\n    return Math.tan(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  atan: (val, floatPrecision) => {\n    return Number(mth.deg(Math.atan(val)).toFixed(floatPrecision));\n  },\n};\n\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * Decompose matrix into simple transforms. See\n * https://frederic-wang.fr/decomposition-of-2d-transform-matrices.html\n *\n * @type {(transform: TransformItem, params: TransformParams) => Array<TransformItem>}\n */\nexports.matrixToTransform = (transform, params) => {\n  let floatPrecision = params.floatPrecision;\n  let data = transform.data;\n  let transforms = [];\n  let sx = Number(\n    Math.hypot(data[0], data[1]).toFixed(params.transformPrecision)\n  );\n  let sy = Number(\n    ((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(\n      params.transformPrecision\n    )\n  );\n  let colsSum = data[0] * data[2] + data[1] * data[3];\n  let rowsSum = data[0] * data[1] + data[2] * data[3];\n  let scaleBefore = rowsSum != 0 || sx == sy;\n\n  // [..., ..., ..., ..., tx, ty] → translate(tx, ty)\n  if (data[4] || data[5]) {\n    transforms.push({\n      name: 'translate',\n      data: data.slice(4, data[5] ? 6 : 5),\n    });\n  }\n\n  // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)\n  if (!data[1] && data[2]) {\n    transforms.push({\n      name: 'skewX',\n      data: [mth.atan(data[2] / sy, floatPrecision)],\n    });\n\n    // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)\n  } else if (data[1] && !data[2]) {\n    transforms.push({\n      name: 'skewY',\n      data: [mth.atan(data[1] / data[0], floatPrecision)],\n    });\n    sx = data[0];\n    sy = data[3];\n\n    // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or\n    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)\n  } else if (!colsSum || (sx == 1 && sy == 1) || !scaleBefore) {\n    if (!scaleBefore) {\n      sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);\n      sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);\n      transforms.push({ name: 'scale', data: [sx, sy] });\n    }\n    var angle = Math.min(Math.max(-1, data[0] / sx), 1),\n      rotate = [\n        mth.acos(angle, floatPrecision) *\n          ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1),\n      ];\n\n    if (rotate[0]) transforms.push({ name: 'rotate', data: rotate });\n\n    if (rowsSum && colsSum)\n      transforms.push({\n        name: 'skewX',\n        data: [mth.atan(colsSum / (sx * sx), floatPrecision)],\n      });\n\n    // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)\n    if (rotate[0] && (data[4] || data[5])) {\n      transforms.shift();\n      var cos = data[0] / sx,\n        sin = data[1] / (scaleBefore ? sx : sy),\n        x = data[4] * (scaleBefore ? 1 : sy),\n        y = data[5] * (scaleBefore ? 1 : sx),\n        denom =\n          (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) *\n          (scaleBefore ? 1 : sx * sy);\n      rotate.push(((1 - cos) * x - sin * y) / denom);\n      rotate.push(((1 - cos) * y + sin * x) / denom);\n    }\n\n    // Too many transformations, return original matrix if it isn't just a scale/translate\n  } else if (data[1] || data[2]) {\n    return [transform];\n  }\n\n  if ((scaleBefore && (sx != 1 || sy != 1)) || !transforms.length)\n    transforms.push({\n      name: 'scale',\n      data: sx == sy ? [sx] : [sx, sy],\n    });\n\n  return transforms;\n};\n\n/**\n * Convert transform to the matrix data.\n *\n * @type {(transform: TransformItem) => Array<number> }\n */\nconst transformToMatrix = (transform) => {\n  if (transform.name === 'matrix') {\n    return transform.data;\n  }\n  switch (transform.name) {\n    case 'translate':\n      // [1, 0, 0, 1, tx, ty]\n      return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];\n    case 'scale':\n      // [sx, 0, 0, sy, 0, 0]\n      return [\n        transform.data[0],\n        0,\n        0,\n        transform.data[1] || transform.data[0],\n        0,\n        0,\n      ];\n    case 'rotate':\n      // [cos(a), sin(a), -sin(a), cos(a), x, y]\n      var cos = mth.cos(transform.data[0]),\n        sin = mth.sin(transform.data[0]),\n        cx = transform.data[1] || 0,\n        cy = transform.data[2] || 0;\n      return [\n        cos,\n        sin,\n        -sin,\n        cos,\n        (1 - cos) * cx + sin * cy,\n        (1 - cos) * cy - sin * cx,\n      ];\n    case 'skewX':\n      // [1, 0, tan(a), 1, 0, 0]\n      return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];\n    case 'skewY':\n      // [1, tan(a), 0, 1, 0, 0]\n      return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];\n    default:\n      throw Error(`Unknown transform ${transform.name}`);\n  }\n};\n\n/**\n * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it\n * by the transformation matrix and use a singular value decomposition to represent in a form\n * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.\n * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})\n *\n * @type {(\n *   cursor: [x: number, y: number],\n *   arc: Array<number>,\n *   transform: Array<number>\n * ) => Array<number>}\n */\nexports.transformArc = (cursor, arc, transform) => {\n  const x = arc[5] - cursor[0];\n  const y = arc[6] - cursor[1];\n  let a = arc[0];\n  let b = arc[1];\n  const rot = (arc[2] * Math.PI) / 180;\n  const cos = Math.cos(rot);\n  const sin = Math.sin(rot);\n  // skip if radius is 0\n  if (a > 0 && b > 0) {\n    let h =\n      Math.pow(x * cos + y * sin, 2) / (4 * a * a) +\n      Math.pow(y * cos - x * sin, 2) / (4 * b * b);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      a *= h;\n      b *= h;\n    }\n  }\n  const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];\n  const m = multiplyTransformMatrices(transform, ellipse);\n  // Decompose the new ellipse matrix\n  const lastCol = m[2] * m[2] + m[3] * m[3];\n  const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;\n  const root =\n    Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);\n\n  if (!root) {\n    // circle\n    arc[0] = arc[1] = Math.sqrt(squareSum / 2);\n    arc[2] = 0;\n  } else {\n    const majorAxisSqr = (squareSum + root) / 2;\n    const minorAxisSqr = (squareSum - root) / 2;\n    const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;\n    const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;\n    const rowsSum = m[0] * m[2] + m[1] * m[3];\n    const term1 = m[0] * sub + m[2] * rowsSum;\n    const term2 = m[1] * sub + m[3] * rowsSum;\n    arc[0] = Math.sqrt(majorAxisSqr);\n    arc[1] = Math.sqrt(minorAxisSqr);\n    arc[2] =\n      (((major ? term2 < 0 : term1 > 0) ? -1 : 1) *\n        Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) *\n        180) /\n      Math.PI;\n  }\n\n  if (transform[0] < 0 !== transform[3] < 0) {\n    // Flip the sweep flag if coordinates are being flipped horizontally XOR vertically\n    arc[4] = 1 - arc[4];\n  }\n\n  return arc;\n};\n\n/**\n * Multiply transformation matrices.\n *\n * @type {(a: Array<number>, b: Array<number>) => Array<number>}\n */\nconst multiplyTransformMatrices = (a, b) => {\n  return [\n    a[0] * b[0] + a[2] * b[1],\n    a[1] * b[0] + a[3] * b[1],\n    a[0] * b[2] + a[2] * b[3],\n    a[1] * b[2] + a[3] * b[3],\n    a[0] * b[4] + a[2] * b[5] + a[4],\n    a[1] * b[4] + a[3] * b[5] + a[5],\n  ];\n};\n"]}}