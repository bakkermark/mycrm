{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{textElems}=require(\"../plugins/_collections.js\");const encodeEntity=__name(char=>{return entities[char]},\"encodeEntity\");const defaults={doctypeStart:\"<!DOCTYPE\",doctypeEnd:\">\",procInstStart:\"<?\",procInstEnd:\"?>\",tagOpenStart:\"<\",tagOpenEnd:\">\",tagCloseStart:\"</\",tagCloseEnd:\">\",tagShortStart:\"<\",tagShortEnd:\"/>\",attrStart:'=\"',attrEnd:'\"',commentStart:\"<!--\",commentEnd:\"-->\",cdataStart:\"<![CDATA[\",cdataEnd:\"]]>\",textStart:\"\",textEnd:\"\",indent:4,regEntities:/[&'\"<>]/g,regValEntities:/[&\"<>]/g,encodeEntity,pretty:false,useShortTags:true,eol:\"lf\",finalNewline:false};const entities={\"&\":\"&amp;\",\"'\":\"&apos;\",'\"':\"&quot;\",\">\":\"&gt;\",\"<\":\"&lt;\"};const stringifySvg=__name((data,userOptions={})=>{const config={...defaults,...userOptions};const indent=config.indent;let newIndent=\"    \";if(typeof indent===\"number\"&&Number.isNaN(indent)===false){newIndent=indent<0?\"\t\":\" \".repeat(indent)}else if(typeof indent===\"string\"){newIndent=indent}const state={indent:newIndent,textContext:null,indentLevel:0};const eol=config.eol===\"crlf\"?\"\\r\\n\":\"\\n\";if(config.pretty){config.doctypeEnd+=eol;config.procInstEnd+=eol;config.commentEnd+=eol;config.cdataEnd+=eol;config.tagShortEnd+=eol;config.tagOpenEnd+=eol;config.tagCloseEnd+=eol;config.textEnd+=eol}let svg=stringifyNode(data,config,state);if(config.finalNewline&&svg.length>0&&svg[svg.length-1]!==\"\\n\"){svg+=eol}return svg},\"stringifySvg\");exports.stringifySvg=stringifySvg;const stringifyNode=__name((data,config,state)=>{let svg=\"\";state.indentLevel+=1;for(const item of data.children){if(item.type===\"element\"){svg+=stringifyElement(item,config,state)}if(item.type===\"text\"){svg+=stringifyText(item,config,state)}if(item.type===\"doctype\"){svg+=stringifyDoctype(item,config)}if(item.type===\"instruction\"){svg+=stringifyInstruction(item,config)}if(item.type===\"comment\"){svg+=stringifyComment(item,config)}if(item.type===\"cdata\"){svg+=stringifyCdata(item,config,state)}}state.indentLevel-=1;return svg},\"stringifyNode\");const createIndent=__name((config,state)=>{let indent=\"\";if(config.pretty&&state.textContext==null){indent=state.indent.repeat(state.indentLevel-1)}return indent},\"createIndent\");const stringifyDoctype=__name((node,config)=>{return config.doctypeStart+node.data.doctype+config.doctypeEnd},\"stringifyDoctype\");const stringifyInstruction=__name((node,config)=>{return config.procInstStart+node.name+\" \"+node.value+config.procInstEnd},\"stringifyInstruction\");const stringifyComment=__name((node,config)=>{return config.commentStart+node.value+config.commentEnd},\"stringifyComment\");const stringifyCdata=__name((node,config,state)=>{return createIndent(config,state)+config.cdataStart+node.value+config.cdataEnd},\"stringifyCdata\");const stringifyElement=__name((node,config,state)=>{if(node.children.length===0){if(config.useShortTags){return createIndent(config,state)+config.tagShortStart+node.name+stringifyAttributes(node,config)+config.tagShortEnd}else{return createIndent(config,state)+config.tagShortStart+node.name+stringifyAttributes(node,config)+config.tagOpenEnd+config.tagCloseStart+node.name+config.tagCloseEnd}}else{let tagOpenStart=config.tagOpenStart;let tagOpenEnd=config.tagOpenEnd;let tagCloseStart=config.tagCloseStart;let tagCloseEnd=config.tagCloseEnd;let openIndent=createIndent(config,state);let closeIndent=createIndent(config,state);if(state.textContext){tagOpenStart=defaults.tagOpenStart;tagOpenEnd=defaults.tagOpenEnd;tagCloseStart=defaults.tagCloseStart;tagCloseEnd=defaults.tagCloseEnd;openIndent=\"\"}else if(textElems.includes(node.name)){tagOpenEnd=defaults.tagOpenEnd;tagCloseStart=defaults.tagCloseStart;closeIndent=\"\";state.textContext=node}const children=stringifyNode(node,config,state);if(state.textContext===node){state.textContext=null}return openIndent+tagOpenStart+node.name+stringifyAttributes(node,config)+tagOpenEnd+children+closeIndent+tagCloseStart+node.name+tagCloseEnd}},\"stringifyElement\");const stringifyAttributes=__name((node,config)=>{let attrs=\"\";for(const[name,value]of Object.entries(node.attributes)){if(value!==void 0){const encodedValue=value.toString().replace(config.regValEntities,config.encodeEntity);attrs+=\" \"+name+config.attrStart+encodedValue+config.attrEnd}else{attrs+=\" \"+name}}return attrs},\"stringifyAttributes\");const stringifyText=__name((node,config,state)=>{return createIndent(config,state)+config.textStart+node.value.replace(config.regEntities,config.encodeEntity)+(state.textContext?\"\":config.textEnd)},\"stringifyText\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/lib/stringifier.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastInstruction} XastInstruction\n * @typedef {import('./types').XastDoctype} XastDoctype\n * @typedef {import('./types').XastText} XastText\n * @typedef {import('./types').XastCdata} XastCdata\n * @typedef {import('./types').XastComment} XastComment\n * @typedef {import('./types').StringifyOptions} StringifyOptions\n */\n\nconst { textElems } = require('../plugins/_collections.js');\n\n/**\n * @typedef {{\n *   indent: string,\n *   textContext: ?XastElement,\n *   indentLevel: number,\n * }} State\n */\n\n/**\n * @typedef {Required<StringifyOptions>} Options\n */\n\n/**\n * @type {(char: string) => string}\n */\nconst encodeEntity = (char) => {\n  return entities[char];\n};\n\n/**\n * @type {Options}\n */\nconst defaults = {\n  doctypeStart: '<!DOCTYPE',\n  doctypeEnd: '>',\n  procInstStart: '<?',\n  procInstEnd: '?>',\n  tagOpenStart: '<',\n  tagOpenEnd: '>',\n  tagCloseStart: '</',\n  tagCloseEnd: '>',\n  tagShortStart: '<',\n  tagShortEnd: '/>',\n  attrStart: '=\"',\n  attrEnd: '\"',\n  commentStart: '<!--',\n  commentEnd: '-->',\n  cdataStart: '<![CDATA[',\n  cdataEnd: ']]>',\n  textStart: '',\n  textEnd: '',\n  indent: 4,\n  regEntities: /[&'\"<>]/g,\n  regValEntities: /[&\"<>]/g,\n  encodeEntity: encodeEntity,\n  pretty: false,\n  useShortTags: true,\n  eol: 'lf',\n  finalNewline: false,\n};\n\n/**\n * @type {Record<string, string>}\n */\nconst entities = {\n  '&': '&amp;',\n  \"'\": '&apos;',\n  '\"': '&quot;',\n  '>': '&gt;',\n  '<': '&lt;',\n};\n\n/**\n * convert XAST to SVG string\n *\n * @type {(data: XastRoot, config: StringifyOptions) => string}\n */\nconst stringifySvg = (data, userOptions = {}) => {\n  /**\n   * @type {Options}\n   */\n  const config = { ...defaults, ...userOptions };\n  const indent = config.indent;\n  let newIndent = '    ';\n  if (typeof indent === 'number' && Number.isNaN(indent) === false) {\n    newIndent = indent < 0 ? '\\t' : ' '.repeat(indent);\n  } else if (typeof indent === 'string') {\n    newIndent = indent;\n  }\n  /**\n   * @type {State}\n   */\n  const state = {\n    indent: newIndent,\n    textContext: null,\n    indentLevel: 0,\n  };\n  const eol = config.eol === 'crlf' ? '\\r\\n' : '\\n';\n  if (config.pretty) {\n    config.doctypeEnd += eol;\n    config.procInstEnd += eol;\n    config.commentEnd += eol;\n    config.cdataEnd += eol;\n    config.tagShortEnd += eol;\n    config.tagOpenEnd += eol;\n    config.tagCloseEnd += eol;\n    config.textEnd += eol;\n  }\n  let svg = stringifyNode(data, config, state);\n  if (config.finalNewline && svg.length > 0 && svg[svg.length - 1] !== '\\n') {\n    svg += eol;\n  }\n  return svg;\n};\nexports.stringifySvg = stringifySvg;\n\n/**\n * @type {(node: XastParent, config: Options, state: State) => string}\n */\nconst stringifyNode = (data, config, state) => {\n  let svg = '';\n  state.indentLevel += 1;\n  for (const item of data.children) {\n    if (item.type === 'element') {\n      svg += stringifyElement(item, config, state);\n    }\n    if (item.type === 'text') {\n      svg += stringifyText(item, config, state);\n    }\n    if (item.type === 'doctype') {\n      svg += stringifyDoctype(item, config);\n    }\n    if (item.type === 'instruction') {\n      svg += stringifyInstruction(item, config);\n    }\n    if (item.type === 'comment') {\n      svg += stringifyComment(item, config);\n    }\n    if (item.type === 'cdata') {\n      svg += stringifyCdata(item, config, state);\n    }\n  }\n  state.indentLevel -= 1;\n  return svg;\n};\n\n/**\n * create indent string in accordance with the current node level.\n *\n * @type {(config: Options, state: State) => string}\n */\nconst createIndent = (config, state) => {\n  let indent = '';\n  if (config.pretty && state.textContext == null) {\n    indent = state.indent.repeat(state.indentLevel - 1);\n  }\n  return indent;\n};\n\n/**\n * @type {(node: XastDoctype, config: Options) => string}\n */\nconst stringifyDoctype = (node, config) => {\n  return config.doctypeStart + node.data.doctype + config.doctypeEnd;\n};\n\n/**\n * @type {(node: XastInstruction, config: Options) => string}\n */\nconst stringifyInstruction = (node, config) => {\n  return (\n    config.procInstStart + node.name + ' ' + node.value + config.procInstEnd\n  );\n};\n\n/**\n * @type {(node: XastComment, config: Options) => string}\n */\nconst stringifyComment = (node, config) => {\n  return config.commentStart + node.value + config.commentEnd;\n};\n\n/**\n * @type {(node: XastCdata, config: Options, state: State) => string}\n */\nconst stringifyCdata = (node, config, state) => {\n  return (\n    createIndent(config, state) +\n    config.cdataStart +\n    node.value +\n    config.cdataEnd\n  );\n};\n\n/**\n * @type {(node: XastElement, config: Options, state: State) => string}\n */\nconst stringifyElement = (node, config, state) => {\n  // empty element and short tag\n  if (node.children.length === 0) {\n    if (config.useShortTags) {\n      return (\n        createIndent(config, state) +\n        config.tagShortStart +\n        node.name +\n        stringifyAttributes(node, config) +\n        config.tagShortEnd\n      );\n    } else {\n      return (\n        createIndent(config, state) +\n        config.tagShortStart +\n        node.name +\n        stringifyAttributes(node, config) +\n        config.tagOpenEnd +\n        config.tagCloseStart +\n        node.name +\n        config.tagCloseEnd\n      );\n    }\n    // non-empty element\n  } else {\n    let tagOpenStart = config.tagOpenStart;\n    let tagOpenEnd = config.tagOpenEnd;\n    let tagCloseStart = config.tagCloseStart;\n    let tagCloseEnd = config.tagCloseEnd;\n    let openIndent = createIndent(config, state);\n    let closeIndent = createIndent(config, state);\n\n    if (state.textContext) {\n      tagOpenStart = defaults.tagOpenStart;\n      tagOpenEnd = defaults.tagOpenEnd;\n      tagCloseStart = defaults.tagCloseStart;\n      tagCloseEnd = defaults.tagCloseEnd;\n      openIndent = '';\n    } else if (textElems.includes(node.name)) {\n      tagOpenEnd = defaults.tagOpenEnd;\n      tagCloseStart = defaults.tagCloseStart;\n      closeIndent = '';\n      state.textContext = node;\n    }\n\n    const children = stringifyNode(node, config, state);\n\n    if (state.textContext === node) {\n      state.textContext = null;\n    }\n\n    return (\n      openIndent +\n      tagOpenStart +\n      node.name +\n      stringifyAttributes(node, config) +\n      tagOpenEnd +\n      children +\n      closeIndent +\n      tagCloseStart +\n      node.name +\n      tagCloseEnd\n    );\n  }\n};\n\n/**\n * @type {(node: XastElement, config: Options) => string}\n */\nconst stringifyAttributes = (node, config) => {\n  let attrs = '';\n  for (const [name, value] of Object.entries(node.attributes)) {\n    // TODO remove attributes without values support in v3\n    if (value !== undefined) {\n      const encodedValue = value\n        .toString()\n        .replace(config.regValEntities, config.encodeEntity);\n      attrs += ' ' + name + config.attrStart + encodedValue + config.attrEnd;\n    } else {\n      attrs += ' ' + name;\n    }\n  }\n  return attrs;\n};\n\n/**\n * @type {(node: XastText, config: Options, state: State) => string}\n */\nconst stringifyText = (node, config, state) => {\n  return (\n    createIndent(config, state) +\n    config.textStart +\n    node.value.replace(config.regEntities, config.encodeEntity) +\n    (state.textContext ? '' : config.textEnd)\n  );\n};\n"]}}