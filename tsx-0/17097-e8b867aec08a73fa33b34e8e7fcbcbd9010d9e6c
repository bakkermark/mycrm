{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});exports.isTraversal=void 0;var css_what_1=require(\"css-what\");var procedure=new Map([[css_what_1.SelectorType.Universal,50],[css_what_1.SelectorType.Tag,30],[css_what_1.SelectorType.Attribute,1],[css_what_1.SelectorType.Pseudo,0]]);function isTraversal(token){return!procedure.has(token.type)}__name(isTraversal,\"isTraversal\");exports.isTraversal=isTraversal;var attributes=new Map([[css_what_1.AttributeAction.Exists,10],[css_what_1.AttributeAction.Equals,8],[css_what_1.AttributeAction.Not,7],[css_what_1.AttributeAction.Start,6],[css_what_1.AttributeAction.End,6],[css_what_1.AttributeAction.Any,5]]);function sortByProcedure(arr){var procs=arr.map(getProcedure);for(var i=1;i<arr.length;i++){var procNew=procs[i];if(procNew<0)continue;for(var j=i-1;j>=0&&procNew<procs[j];j--){var token=arr[j+1];arr[j+1]=arr[j];arr[j]=token;procs[j+1]=procs[j];procs[j]=procNew}}}__name(sortByProcedure,\"sortByProcedure\");exports.default=sortByProcedure;function getProcedure(token){var _a,_b;var proc=(_a=procedure.get(token.type))!==null&&_a!==void 0?_a:-1;if(token.type===css_what_1.SelectorType.Attribute){proc=(_b=attributes.get(token.action))!==null&&_b!==void 0?_b:4;if(token.action===css_what_1.AttributeAction.Equals&&token.name===\"id\"){proc=9}if(token.ignoreCase){proc>>=1}}else if(token.type===css_what_1.SelectorType.Pseudo){if(!token.data){proc=3}else if(token.name===\"has\"||token.name===\"contains\"){proc=0}else if(Array.isArray(token.data)){proc=Math.min.apply(Math,token.data.map(function(d){return Math.min.apply(Math,d.map(getProcedure))}));if(proc<0){proc=0}}else{proc=2}}return proc}__name(getProcedure,\"getProcedure\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CAAE,MAAO,IAAK,CAAC,EAC5D,QAAQ,YAAc,OACtB,IAAI,WAAa,QAAQ,UAAU,EACnC,IAAI,UAAY,IAAI,IAAI,CACpB,CAAC,WAAW,aAAa,UAAW,EAAE,EACtC,CAAC,WAAW,aAAa,IAAK,EAAE,EAChC,CAAC,WAAW,aAAa,UAAW,CAAC,EACrC,CAAC,WAAW,aAAa,OAAQ,CAAC,CACtC,CAAC,EACD,SAAS,YAAY,MAAO,CACxB,MAAO,CAAC,UAAU,IAAI,MAAM,IAAI,CACpC,CAFS,kCAGT,QAAQ,YAAc,YACtB,IAAI,WAAa,IAAI,IAAI,CACrB,CAAC,WAAW,gBAAgB,OAAQ,EAAE,EACtC,CAAC,WAAW,gBAAgB,OAAQ,CAAC,EACrC,CAAC,WAAW,gBAAgB,IAAK,CAAC,EAClC,CAAC,WAAW,gBAAgB,MAAO,CAAC,EACpC,CAAC,WAAW,gBAAgB,IAAK,CAAC,EAClC,CAAC,WAAW,gBAAgB,IAAK,CAAC,CACtC,CAAC,EAQD,SAAS,gBAAgB,IAAK,CAC1B,IAAI,MAAQ,IAAI,IAAI,YAAY,EAChC,QAAS,EAAI,EAAG,EAAI,IAAI,OAAQ,IAAK,CACjC,IAAI,QAAU,MAAM,CAAC,EACrB,GAAI,QAAU,EACV,SACJ,QAAS,EAAI,EAAI,EAAG,GAAK,GAAK,QAAU,MAAM,CAAC,EAAG,IAAK,CACnD,IAAI,MAAQ,IAAI,EAAI,CAAC,EACrB,IAAI,EAAI,CAAC,EAAI,IAAI,CAAC,EAClB,IAAI,CAAC,EAAI,MACT,MAAM,EAAI,CAAC,EAAI,MAAM,CAAC,EACtB,MAAM,CAAC,EAAI,OACf,CACJ,CACJ,CAdS,0CAeT,QAAQ,QAAU,gBAClB,SAAS,aAAa,MAAO,CACzB,IAAI,GAAI,GACR,IAAI,MAAQ,GAAK,UAAU,IAAI,MAAM,IAAI,KAAO,MAAQ,KAAO,OAAS,GAAK,GAC7E,GAAI,MAAM,OAAS,WAAW,aAAa,UAAW,CAClD,MAAQ,GAAK,WAAW,IAAI,MAAM,MAAM,KAAO,MAAQ,KAAO,OAAS,GAAK,EAC5E,GAAI,MAAM,SAAW,WAAW,gBAAgB,QAAU,MAAM,OAAS,KAAM,CAE3E,KAAO,CACX,CACA,GAAI,MAAM,WAAY,CAKlB,OAAS,CACb,CACJ,SACS,MAAM,OAAS,WAAW,aAAa,OAAQ,CACpD,GAAI,CAAC,MAAM,KAAM,CACb,KAAO,CACX,SACS,MAAM,OAAS,OAAS,MAAM,OAAS,WAAY,CACxD,KAAO,CACX,SACS,MAAM,QAAQ,MAAM,IAAI,EAAG,CAEhC,KAAO,KAAK,IAAI,MAAM,KAAM,MAAM,KAAK,IAAI,SAAU,EAAG,CAAE,OAAO,KAAK,IAAI,MAAM,KAAM,EAAE,IAAI,YAAY,CAAC,CAAG,CAAC,CAAC,EAE9G,GAAI,KAAO,EAAG,CACV,KAAO,CACX,CACJ,KACK,CACD,KAAO,CACX,CACJ,CACA,OAAO,IACX,CArCS","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/sort.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTraversal = void 0;\nvar css_what_1 = require(\"css-what\");\nvar procedure = new Map([\n    [css_what_1.SelectorType.Universal, 50],\n    [css_what_1.SelectorType.Tag, 30],\n    [css_what_1.SelectorType.Attribute, 1],\n    [css_what_1.SelectorType.Pseudo, 0],\n]);\nfunction isTraversal(token) {\n    return !procedure.has(token.type);\n}\nexports.isTraversal = isTraversal;\nvar attributes = new Map([\n    [css_what_1.AttributeAction.Exists, 10],\n    [css_what_1.AttributeAction.Equals, 8],\n    [css_what_1.AttributeAction.Not, 7],\n    [css_what_1.AttributeAction.Start, 6],\n    [css_what_1.AttributeAction.End, 6],\n    [css_what_1.AttributeAction.Any, 5],\n]);\n/**\n * Sort the parts of the passed selector,\n * as there is potential for optimization\n * (some types of selectors are faster than others)\n *\n * @param arr Selector to sort\n */\nfunction sortByProcedure(arr) {\n    var procs = arr.map(getProcedure);\n    for (var i = 1; i < arr.length; i++) {\n        var procNew = procs[i];\n        if (procNew < 0)\n            continue;\n        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {\n            var token = arr[j + 1];\n            arr[j + 1] = arr[j];\n            arr[j] = token;\n            procs[j + 1] = procs[j];\n            procs[j] = procNew;\n        }\n    }\n}\nexports.default = sortByProcedure;\nfunction getProcedure(token) {\n    var _a, _b;\n    var proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;\n    if (token.type === css_what_1.SelectorType.Attribute) {\n        proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;\n        if (token.action === css_what_1.AttributeAction.Equals && token.name === \"id\") {\n            // Prefer ID selectors (eg. #ID)\n            proc = 9;\n        }\n        if (token.ignoreCase) {\n            /*\n             * IgnoreCase adds some overhead, prefer \"normal\" token\n             * this is a binary operation, to ensure it's still an int\n             */\n            proc >>= 1;\n        }\n    }\n    else if (token.type === css_what_1.SelectorType.Pseudo) {\n        if (!token.data) {\n            proc = 3;\n        }\n        else if (token.name === \"has\" || token.name === \"contains\") {\n            proc = 0; // Expensive in any case\n        }\n        else if (Array.isArray(token.data)) {\n            // Eg. :matches, :not\n            proc = Math.min.apply(Math, token.data.map(function (d) { return Math.min.apply(Math, d.map(getProcedure)); }));\n            // If we have traversals, try to avoid executing this selector\n            if (proc < 0) {\n                proc = 0;\n            }\n        }\n        else {\n            proc = 2;\n        }\n    }\n    return proc;\n}\n//# sourceMappingURL=sort.js.map"]}}