{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{Minipass}=require(\"minipass\");const Pax=require(\"./pax.js\");const Header=require(\"./header.js\");const fs=require(\"fs\");const path=require(\"path\");const normPath=require(\"./normalize-windows-path.js\");const stripSlash=require(\"./strip-trailing-slashes.js\");const prefixPath=__name((path2,prefix)=>{if(!prefix){return normPath(path2)}path2=normPath(path2).replace(/^\\.(\\/|$)/,\"\");return stripSlash(prefix)+\"/\"+path2},\"prefixPath\");const maxReadSize=16*1024*1024;const PROCESS=Symbol(\"process\");const FILE=Symbol(\"file\");const DIRECTORY=Symbol(\"directory\");const SYMLINK=Symbol(\"symlink\");const HARDLINK=Symbol(\"hardlink\");const HEADER=Symbol(\"header\");const READ=Symbol(\"read\");const LSTAT=Symbol(\"lstat\");const ONLSTAT=Symbol(\"onlstat\");const ONREAD=Symbol(\"onread\");const ONREADLINK=Symbol(\"onreadlink\");const OPENFILE=Symbol(\"openfile\");const ONOPENFILE=Symbol(\"onopenfile\");const CLOSE=Symbol(\"close\");const MODE=Symbol(\"mode\");const AWAITDRAIN=Symbol(\"awaitDrain\");const ONDRAIN=Symbol(\"ondrain\");const PREFIX=Symbol(\"prefix\");const HAD_ERROR=Symbol(\"hadError\");const warner=require(\"./warn-mixin.js\");const winchars=require(\"./winchars.js\");const stripAbsolutePath=require(\"./strip-absolute-path.js\");const modeFix=require(\"./mode-fix.js\");const WriteEntry=warner(class WriteEntry2 extends Minipass{static{__name(this,\"WriteEntry\")}constructor(p,opt){opt=opt||{};super(opt);if(typeof p!==\"string\"){throw new TypeError(\"path is required\")}this.path=normPath(p);this.portable=!!opt.portable;this.myuid=process.getuid&&process.getuid()||0;this.myuser=process.env.USER||\"\";this.maxReadSize=opt.maxReadSize||maxReadSize;this.linkCache=opt.linkCache||new Map;this.statCache=opt.statCache||new Map;this.preservePaths=!!opt.preservePaths;this.cwd=normPath(opt.cwd||process.cwd());this.strict=!!opt.strict;this.noPax=!!opt.noPax;this.noMtime=!!opt.noMtime;this.mtime=opt.mtime||null;this.prefix=opt.prefix?normPath(opt.prefix):null;this.fd=null;this.blockLen=null;this.blockRemain=null;this.buf=null;this.offset=null;this.length=null;this.pos=null;this.remain=null;if(typeof opt.onwarn===\"function\"){this.on(\"warn\",opt.onwarn)}let pathWarn=false;if(!this.preservePaths){const[root,stripped]=stripAbsolutePath(this.path);if(root){this.path=stripped;pathWarn=root}}this.win32=!!opt.win32||process.platform===\"win32\";if(this.win32){this.path=winchars.decode(this.path.replace(/\\\\/g,\"/\"));p=p.replace(/\\\\/g,\"/\")}this.absolute=normPath(opt.absolute||path.resolve(this.cwd,p));if(this.path===\"\"){this.path=\"./\"}if(pathWarn){this.warn(\"TAR_ENTRY_INFO\",`stripping ${pathWarn} from absolute path`,{entry:this,path:pathWarn+this.path})}if(this.statCache.has(this.absolute)){this[ONLSTAT](this.statCache.get(this.absolute))}else{this[LSTAT]()}}emit(ev,...data){if(ev===\"error\"){this[HAD_ERROR]=true}return super.emit(ev,...data)}[LSTAT](){fs.lstat(this.absolute,(er,stat)=>{if(er){return this.emit(\"error\",er)}this[ONLSTAT](stat)})}[ONLSTAT](stat){this.statCache.set(this.absolute,stat);this.stat=stat;if(!stat.isFile()){stat.size=0}this.type=getType(stat);this.emit(\"stat\",stat);this[PROCESS]()}[PROCESS](){switch(this.type){case\"File\":return this[FILE]();case\"Directory\":return this[DIRECTORY]();case\"SymbolicLink\":return this[SYMLINK]();default:return this.end()}}[MODE](mode){return modeFix(mode,this.type===\"Directory\",this.portable)}[PREFIX](path2){return prefixPath(path2,this.prefix)}[HEADER](){if(this.type===\"Directory\"&&this.portable){this.noMtime=true}this.header=new Header({path:this[PREFIX](this.path),linkpath:this.type===\"Link\"?this[PREFIX](this.linkpath):this.linkpath,mode:this[MODE](this.stat.mode),uid:this.portable?null:this.stat.uid,gid:this.portable?null:this.stat.gid,size:this.stat.size,mtime:this.noMtime?null:this.mtime||this.stat.mtime,type:this.type,uname:this.portable?null:this.stat.uid===this.myuid?this.myuser:\"\",atime:this.portable?null:this.stat.atime,ctime:this.portable?null:this.stat.ctime});if(this.header.encode()&&!this.noPax){super.write(new Pax({atime:this.portable?null:this.header.atime,ctime:this.portable?null:this.header.ctime,gid:this.portable?null:this.header.gid,mtime:this.noMtime?null:this.mtime||this.header.mtime,path:this[PREFIX](this.path),linkpath:this.type===\"Link\"?this[PREFIX](this.linkpath):this.linkpath,size:this.header.size,uid:this.portable?null:this.header.uid,uname:this.portable?null:this.header.uname,dev:this.portable?null:this.stat.dev,ino:this.portable?null:this.stat.ino,nlink:this.portable?null:this.stat.nlink}).encode())}super.write(this.header.block)}[DIRECTORY](){if(this.path.slice(-1)!==\"/\"){this.path+=\"/\"}this.stat.size=0;this[HEADER]();this.end()}[SYMLINK](){fs.readlink(this.absolute,(er,linkpath)=>{if(er){return this.emit(\"error\",er)}this[ONREADLINK](linkpath)})}[ONREADLINK](linkpath){this.linkpath=normPath(linkpath);this[HEADER]();this.end()}[HARDLINK](linkpath){this.type=\"Link\";this.linkpath=normPath(path.relative(this.cwd,linkpath));this.stat.size=0;this[HEADER]();this.end()}[FILE](){if(this.stat.nlink>1){const linkKey=this.stat.dev+\":\"+this.stat.ino;if(this.linkCache.has(linkKey)){const linkpath=this.linkCache.get(linkKey);if(linkpath.indexOf(this.cwd)===0){return this[HARDLINK](linkpath)}}this.linkCache.set(linkKey,this.absolute)}this[HEADER]();if(this.stat.size===0){return this.end()}this[OPENFILE]()}[OPENFILE](){fs.open(this.absolute,\"r\",(er,fd)=>{if(er){return this.emit(\"error\",er)}this[ONOPENFILE](fd)})}[ONOPENFILE](fd){this.fd=fd;if(this[HAD_ERROR]){return this[CLOSE]()}this.blockLen=512*Math.ceil(this.stat.size/512);this.blockRemain=this.blockLen;const bufLen=Math.min(this.blockLen,this.maxReadSize);this.buf=Buffer.allocUnsafe(bufLen);this.offset=0;this.pos=0;this.remain=this.stat.size;this.length=this.buf.length;this[READ]()}[READ](){const{fd,buf,offset,length,pos}=this;fs.read(fd,buf,offset,length,pos,(er,bytesRead)=>{if(er){return this[CLOSE](()=>this.emit(\"error\",er))}this[ONREAD](bytesRead)})}[CLOSE](cb){fs.close(this.fd,cb)}[ONREAD](bytesRead){if(bytesRead<=0&&this.remain>0){const er=new Error(\"encountered unexpected EOF\");er.path=this.absolute;er.syscall=\"read\";er.code=\"EOF\";return this[CLOSE](()=>this.emit(\"error\",er))}if(bytesRead>this.remain){const er=new Error(\"did not encounter expected EOF\");er.path=this.absolute;er.syscall=\"read\";er.code=\"EOF\";return this[CLOSE](()=>this.emit(\"error\",er))}if(bytesRead===this.remain){for(let i=bytesRead;i<this.length&&bytesRead<this.blockRemain;i++){this.buf[i+this.offset]=0;bytesRead++;this.remain++}}const writeBuf=this.offset===0&&bytesRead===this.buf.length?this.buf:this.buf.slice(this.offset,this.offset+bytesRead);const flushed=this.write(writeBuf);if(!flushed){this[AWAITDRAIN](()=>this[ONDRAIN]())}else{this[ONDRAIN]()}}[AWAITDRAIN](cb){this.once(\"drain\",cb)}write(writeBuf){if(this.blockRemain<writeBuf.length){const er=new Error(\"writing more data than expected\");er.path=this.absolute;return this.emit(\"error\",er)}this.remain-=writeBuf.length;this.blockRemain-=writeBuf.length;this.pos+=writeBuf.length;this.offset+=writeBuf.length;return super.write(writeBuf)}[ONDRAIN](){if(!this.remain){if(this.blockRemain){super.write(Buffer.alloc(this.blockRemain))}return this[CLOSE](er=>er?this.emit(\"error\",er):this.end())}if(this.offset>=this.length){this.buf=Buffer.allocUnsafe(Math.min(this.blockRemain,this.buf.length));this.offset=0}this.length=this.buf.length-this.offset;this[READ]()}});class WriteEntrySync extends WriteEntry{static{__name(this,\"WriteEntrySync\")}[LSTAT](){this[ONLSTAT](fs.lstatSync(this.absolute))}[SYMLINK](){this[ONREADLINK](fs.readlinkSync(this.absolute))}[OPENFILE](){this[ONOPENFILE](fs.openSync(this.absolute,\"r\"))}[READ](){let threw=true;try{const{fd,buf,offset,length,pos}=this;const bytesRead=fs.readSync(fd,buf,offset,length,pos);this[ONREAD](bytesRead);threw=false}finally{if(threw){try{this[CLOSE](()=>{})}catch(er){}}}}[AWAITDRAIN](cb){cb()}[CLOSE](cb){fs.closeSync(this.fd);cb()}}const WriteEntryTar=warner(class WriteEntryTar2 extends Minipass{static{__name(this,\"WriteEntryTar\")}constructor(readEntry,opt){opt=opt||{};super(opt);this.preservePaths=!!opt.preservePaths;this.portable=!!opt.portable;this.strict=!!opt.strict;this.noPax=!!opt.noPax;this.noMtime=!!opt.noMtime;this.readEntry=readEntry;this.type=readEntry.type;if(this.type===\"Directory\"&&this.portable){this.noMtime=true}this.prefix=opt.prefix||null;this.path=normPath(readEntry.path);this.mode=this[MODE](readEntry.mode);this.uid=this.portable?null:readEntry.uid;this.gid=this.portable?null:readEntry.gid;this.uname=this.portable?null:readEntry.uname;this.gname=this.portable?null:readEntry.gname;this.size=readEntry.size;this.mtime=this.noMtime?null:opt.mtime||readEntry.mtime;this.atime=this.portable?null:readEntry.atime;this.ctime=this.portable?null:readEntry.ctime;this.linkpath=normPath(readEntry.linkpath);if(typeof opt.onwarn===\"function\"){this.on(\"warn\",opt.onwarn)}let pathWarn=false;if(!this.preservePaths){const[root,stripped]=stripAbsolutePath(this.path);if(root){this.path=stripped;pathWarn=root}}this.remain=readEntry.size;this.blockRemain=readEntry.startBlockSize;this.header=new Header({path:this[PREFIX](this.path),linkpath:this.type===\"Link\"?this[PREFIX](this.linkpath):this.linkpath,mode:this.mode,uid:this.portable?null:this.uid,gid:this.portable?null:this.gid,size:this.size,mtime:this.noMtime?null:this.mtime,type:this.type,uname:this.portable?null:this.uname,atime:this.portable?null:this.atime,ctime:this.portable?null:this.ctime});if(pathWarn){this.warn(\"TAR_ENTRY_INFO\",`stripping ${pathWarn} from absolute path`,{entry:this,path:pathWarn+this.path})}if(this.header.encode()&&!this.noPax){super.write(new Pax({atime:this.portable?null:this.atime,ctime:this.portable?null:this.ctime,gid:this.portable?null:this.gid,mtime:this.noMtime?null:this.mtime,path:this[PREFIX](this.path),linkpath:this.type===\"Link\"?this[PREFIX](this.linkpath):this.linkpath,size:this.size,uid:this.portable?null:this.uid,uname:this.portable?null:this.uname,dev:this.portable?null:this.readEntry.dev,ino:this.portable?null:this.readEntry.ino,nlink:this.portable?null:this.readEntry.nlink}).encode())}super.write(this.header.block);readEntry.pipe(this)}[PREFIX](path2){return prefixPath(path2,this.prefix)}[MODE](mode){return modeFix(mode,this.type===\"Directory\",this.portable)}write(data){const writeLen=data.length;if(writeLen>this.blockRemain){throw new Error(\"writing more to entry than is appropriate\")}this.blockRemain-=writeLen;return super.write(data)}end(){if(this.blockRemain){super.write(Buffer.alloc(this.blockRemain))}return super.end()}});WriteEntry.Sync=WriteEntrySync;WriteEntry.Tar=WriteEntryTar;const getType=__name(stat=>stat.isFile()?\"File\":stat.isDirectory()?\"Directory\":stat.isSymbolicLink()?\"SymbolicLink\":\"Unsupported\",\"getType\");module.exports=WriteEntry;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["path","WriteEntry","WriteEntryTar"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/write-entry.js"],"sourcesContent":["'use strict'\nconst { Minipass } = require('minipass')\nconst Pax = require('./pax.js')\nconst Header = require('./header.js')\nconst fs = require('fs')\nconst path = require('path')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix) {\n    return normPath(path)\n  }\n  path = normPath(path).replace(/^\\.(\\/|$)/, '')\n  return stripSlash(prefix) + '/' + path\n}\n\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst AWAITDRAIN = Symbol('awaitDrain')\nconst ONDRAIN = Symbol('ondrain')\nconst PREFIX = Symbol('prefix')\nconst HAD_ERROR = Symbol('hadError')\nconst warner = require('./warn-mixin.js')\nconst winchars = require('./winchars.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\n\nconst modeFix = require('./mode-fix.js')\n\nconst WriteEntry = warner(class WriteEntry extends Minipass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string') {\n      throw new TypeError('path is required')\n    }\n    this.path = normPath(p)\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid() || 0\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = normPath(opt.cwd || process.cwd())\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null\n\n    this.fd = null\n    this.blockLen = null\n    this.blockRemain = null\n    this.buf = null\n    this.offset = null\n    this.length = null\n    this.pos = null\n    this.remain = null\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))\n\n    if (this.path === '') {\n      this.path = './'\n    }\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute)) {\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    } else {\n      this[LSTAT]()\n    }\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'error') {\n      this[HAD_ERROR] = true\n    }\n    return super.emit(ev, ...data)\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile()) {\n      stat.size = 0\n    }\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n      this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime,\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink,\n      }).encode())\n    }\n    super.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.slice(-1) !== '/') {\n      this.path += '/'\n    }\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = normPath(linkpath)\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = normPath(path.relative(this.cwd, linkpath))\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0) {\n          return this[HARDLINK](linkpath)\n        }\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0) {\n      return this.end()\n    }\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    this.fd = fd\n    if (this[HAD_ERROR]) {\n      return this[CLOSE]()\n    }\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512)\n    this.blockRemain = this.blockLen\n    const bufLen = Math.min(this.blockLen, this.maxReadSize)\n    this.buf = Buffer.allocUnsafe(bufLen)\n    this.offset = 0\n    this.pos = 0\n    this.remain = this.stat.size\n    this.length = this.buf.length\n    this[READ]()\n  }\n\n  [READ] () {\n    const { fd, buf, offset, length, pos } = this\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er))\n      }\n      this[ONREAD](bytesRead)\n    })\n  }\n\n  [CLOSE] (cb) {\n    fs.close(this.fd, cb)\n  }\n\n  [ONREAD] (bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0\n        bytesRead++\n        this.remain++\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?\n      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)\n\n    const flushed = this.write(writeBuf)\n    if (!flushed) {\n      this[AWAITDRAIN](() => this[ONDRAIN]())\n    } else {\n      this[ONDRAIN]()\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    this.once('drain', cb)\n  }\n\n  write (writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected')\n      er.path = this.absolute\n      return this.emit('error', er)\n    }\n    this.remain -= writeBuf.length\n    this.blockRemain -= writeBuf.length\n    this.pos += writeBuf.length\n    this.offset += writeBuf.length\n    return super.write(writeBuf)\n  }\n\n  [ONDRAIN] () {\n    if (!this.remain) {\n      if (this.blockRemain) {\n        super.write(Buffer.alloc(this.blockRemain))\n      }\n      return this[CLOSE](er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))\n      this.offset = 0\n    }\n    this.length = this.buf.length - this.offset\n    this[READ]()\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] () {\n    let threw = true\n    try {\n      const { fd, buf, offset, length, pos } = this\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    cb()\n  }\n\n  [CLOSE] (cb) {\n    fs.closeSync(this.fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends Minipass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.prefix = opt.prefix || null\n\n    this.path = normPath(readEntry.path)\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = normPath(readEntry.linkpath)\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink,\n      }).encode())\n    }\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain) {\n      super.write(Buffer.alloc(this.blockRemain))\n    }\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n"]}}