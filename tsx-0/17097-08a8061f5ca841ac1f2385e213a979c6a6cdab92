{"code":"(()=>{\n\"use strict\";const{visitSkip,detachNodeFromParent}=require(\"../lib/xast.js\");const{parsePathData}=require(\"../lib/path.js\");const{intersects}=require(\"./_path.js\");exports.name=\"removeOffCanvasPaths\";exports.description=\"removes elements that are drawn outside of the viewbox (disabled by default)\";exports.fn=()=>{let viewBoxData=null;return{element:{enter:(node,parentNode)=>{if(node.name===\"svg\"&&parentNode.type===\"root\"){let viewBox=\"\";if(node.attributes.viewBox!=null){viewBox=node.attributes.viewBox}else if(node.attributes.height!=null&&node.attributes.width!=null){viewBox=`0 0 ${node.attributes.width} ${node.attributes.height}`}viewBox=viewBox.replace(/[,+]|px/g,\" \").replace(/\\s+/g,\" \").replace(/^\\s*|\\s*$/g,\"\");const m=/^(-?\\d*\\.?\\d+) (-?\\d*\\.?\\d+) (\\d*\\.?\\d+) (\\d*\\.?\\d+)$/.exec(viewBox);if(m==null){return}const left=Number.parseFloat(m[1]);const top=Number.parseFloat(m[2]);const width=Number.parseFloat(m[3]);const height=Number.parseFloat(m[4]);viewBoxData={left,top,right:left+width,bottom:top+height,width,height}}if(node.attributes.transform!=null){return visitSkip}if(node.name===\"path\"&&node.attributes.d!=null&&viewBoxData!=null){const pathData=parsePathData(node.attributes.d);let visible=false;for(const pathDataItem of pathData){if(pathDataItem.command===\"M\"){const[x,y]=pathDataItem.args;if(x>=viewBoxData.left&&x<=viewBoxData.right&&y>=viewBoxData.top&&y<=viewBoxData.bottom){visible=true}}}if(visible){return}if(pathData.length===2){pathData.push({command:\"z\",args:[]})}const{left,top,width,height}=viewBoxData;const viewBoxPathData=[{command:\"M\",args:[left,top]},{command:\"h\",args:[width]},{command:\"v\",args:[height]},{command:\"H\",args:[left]},{command:\"z\",args:[]}];if(intersects(viewBoxPathData,pathData)===false){detachNodeFromParent(node,parentNode)}}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":";aAMA,KAAM,CAAE,UAAW,oBAAqB,EAAI,QAAQ,gBAAgB,EACpE,KAAM,CAAE,aAAc,EAAI,QAAQ,gBAAgB,EAClD,KAAM,CAAE,UAAW,EAAI,QAAQ,YAAY,EAE3C,QAAQ,KAAO,uBACf,QAAQ,YACN,+EASF,QAAQ,GAAK,IAAM,CAWjB,IAAI,YAAc,KAElB,MAAO,CACL,QAAS,CACP,MAAO,CAAC,KAAM,aAAe,CAC3B,GAAI,KAAK,OAAS,OAAS,WAAW,OAAS,OAAQ,CACrD,IAAI,QAAU,GAEd,GAAI,KAAK,WAAW,SAAW,KAAM,CAEnC,QAAU,KAAK,WAAW,OAC5B,SACE,KAAK,WAAW,QAAU,MAC1B,KAAK,WAAW,OAAS,KACzB,CACA,QAAU,OAAO,KAAK,WAAW,KAAK,IAAI,KAAK,WAAW,MAAM,EAClE,CAIA,QAAU,QACP,QAAQ,WAAY,GAAG,EACvB,QAAQ,OAAQ,GAAG,EACnB,QAAQ,aAAc,EAAE,EAE3B,MAAM,EACJ,wDAAwD,KACtD,OACF,EACF,GAAI,GAAK,KAAM,CACb,MACF,CACA,MAAM,KAAO,OAAO,WAAW,EAAE,CAAC,CAAC,EACnC,MAAM,IAAM,OAAO,WAAW,EAAE,CAAC,CAAC,EAClC,MAAM,MAAQ,OAAO,WAAW,EAAE,CAAC,CAAC,EACpC,MAAM,OAAS,OAAO,WAAW,EAAE,CAAC,CAAC,EAGrC,YAAc,CACZ,KACA,IACA,MAAO,KAAO,MACd,OAAQ,IAAM,OACd,MACA,MACF,CACF,CAGA,GAAI,KAAK,WAAW,WAAa,KAAM,CACrC,OAAO,SACT,CAEA,GACE,KAAK,OAAS,QACd,KAAK,WAAW,GAAK,MACrB,aAAe,KACf,CACA,MAAM,SAAW,cAAc,KAAK,WAAW,CAAC,EAGhD,IAAI,QAAU,MACd,UAAW,gBAAgB,SAAU,CACnC,GAAI,aAAa,UAAY,IAAK,CAChC,KAAM,CAAC,EAAG,CAAC,EAAI,aAAa,KAC5B,GACE,GAAK,YAAY,MACjB,GAAK,YAAY,OACjB,GAAK,YAAY,KACjB,GAAK,YAAY,OACjB,CACA,QAAU,IACZ,CACF,CACF,CACA,GAAI,QAAS,CACX,MACF,CAEA,GAAI,SAAS,SAAW,EAAG,CAEzB,SAAS,KAAK,CAAE,QAAS,IAAK,KAAM,CAAC,CAAE,CAAC,CAC1C,CAEA,KAAM,CAAE,KAAM,IAAK,MAAO,MAAO,EAAI,YAIrC,MAAM,gBAAkB,CACtB,CAAE,QAAS,IAAK,KAAM,CAAC,KAAM,GAAG,CAAE,EAClC,CAAE,QAAS,IAAK,KAAM,CAAC,KAAK,CAAE,EAC9B,CAAE,QAAS,IAAK,KAAM,CAAC,MAAM,CAAE,EAC/B,CAAE,QAAS,IAAK,KAAM,CAAC,IAAI,CAAE,EAC7B,CAAE,QAAS,IAAK,KAAM,CAAC,CAAE,CAC3B,EAEA,GAAI,WAAW,gBAAiB,QAAQ,IAAM,MAAO,CACnD,qBAAqB,KAAM,UAAU,CACvC,CACF,CACF,CACF,CACF,CACF","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/removeOffCanvasPaths.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { visitSkip, detachNodeFromParent } = require('../lib/xast.js');\nconst { parsePathData } = require('../lib/path.js');\nconst { intersects } = require('./_path.js');\n\nexports.name = 'removeOffCanvasPaths';\nexports.description =\n  'removes elements that are drawn outside of the viewbox (disabled by default)';\n\n/**\n * Remove elements that are drawn outside of the viewbox.\n *\n * @author JoshyPHP\n *\n * @type {import('./plugins-types').Plugin<'removeOffCanvasPaths'>}\n */\nexports.fn = () => {\n  /**\n   * @type {?{\n   *   top: number,\n   *   right: number,\n   *   bottom: number,\n   *   left: number,\n   *   width: number,\n   *   height: number\n   * }}\n   */\n  let viewBoxData = null;\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.name === 'svg' && parentNode.type === 'root') {\n          let viewBox = '';\n          // find viewbox\n          if (node.attributes.viewBox != null) {\n            // remove commas and plus signs, normalize and trim whitespace\n            viewBox = node.attributes.viewBox;\n          } else if (\n            node.attributes.height != null &&\n            node.attributes.width != null\n          ) {\n            viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;\n          }\n\n          // parse viewbox\n          // remove commas and plus signs, normalize and trim whitespace\n          viewBox = viewBox\n            .replace(/[,+]|px/g, ' ')\n            .replace(/\\s+/g, ' ')\n            .replace(/^\\s*|\\s*$/g, '');\n          // ensure that the dimensions are 4 values separated by space\n          const m =\n            /^(-?\\d*\\.?\\d+) (-?\\d*\\.?\\d+) (\\d*\\.?\\d+) (\\d*\\.?\\d+)$/.exec(\n              viewBox\n            );\n          if (m == null) {\n            return;\n          }\n          const left = Number.parseFloat(m[1]);\n          const top = Number.parseFloat(m[2]);\n          const width = Number.parseFloat(m[3]);\n          const height = Number.parseFloat(m[4]);\n\n          // store the viewBox boundaries\n          viewBoxData = {\n            left,\n            top,\n            right: left + width,\n            bottom: top + height,\n            width,\n            height,\n          };\n        }\n\n        // consider that any item with a transform attribute is visible\n        if (node.attributes.transform != null) {\n          return visitSkip;\n        }\n\n        if (\n          node.name === 'path' &&\n          node.attributes.d != null &&\n          viewBoxData != null\n        ) {\n          const pathData = parsePathData(node.attributes.d);\n\n          // consider that a M command within the viewBox is visible\n          let visible = false;\n          for (const pathDataItem of pathData) {\n            if (pathDataItem.command === 'M') {\n              const [x, y] = pathDataItem.args;\n              if (\n                x >= viewBoxData.left &&\n                x <= viewBoxData.right &&\n                y >= viewBoxData.top &&\n                y <= viewBoxData.bottom\n              ) {\n                visible = true;\n              }\n            }\n          }\n          if (visible) {\n            return;\n          }\n\n          if (pathData.length === 2) {\n            // close the path too short for intersects()\n            pathData.push({ command: 'z', args: [] });\n          }\n\n          const { left, top, width, height } = viewBoxData;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const viewBoxPathData = [\n            { command: 'M', args: [left, top] },\n            { command: 'h', args: [width] },\n            { command: 'v', args: [height] },\n            { command: 'H', args: [left] },\n            { command: 'z', args: [] },\n          ];\n\n          if (intersects(viewBoxPathData, pathData) === false) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      },\n    },\n  };\n};\n"]}}