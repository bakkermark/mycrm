{"code":"(()=>{\n\"use strict\";const{visitSkip,detachNodeFromParent}=require(\"../lib/xast.js\");const{collectStylesheet,computeStyle}=require(\"../lib/style.js\");const{elems,attrsGroups,elemsGroups,attrsGroupsDefaults,presentationNonInheritableGroupAttrs}=require(\"./_collections\");exports.name=\"removeUnknownsAndDefaults\";exports.description=\"removes unknown elements content and attributes, removes attrs with default values\";const allowedChildrenPerElement=new Map;const allowedAttributesPerElement=new Map;const attributesDefaultsPerElement=new Map;for(const[name,config]of Object.entries(elems)){const allowedChildren=new Set;if(config.content){for(const elementName of config.content){allowedChildren.add(elementName)}}if(config.contentGroups){for(const contentGroupName of config.contentGroups){const elemsGroup=elemsGroups[contentGroupName];if(elemsGroup){for(const elementName of elemsGroup){allowedChildren.add(elementName)}}}}const allowedAttributes=new Set;if(config.attrs){for(const attrName of config.attrs){allowedAttributes.add(attrName)}}const attributesDefaults=new Map;if(config.defaults){for(const[attrName,defaultValue]of Object.entries(config.defaults)){attributesDefaults.set(attrName,defaultValue)}}for(const attrsGroupName of config.attrsGroups){const attrsGroup=attrsGroups[attrsGroupName];if(attrsGroup){for(const attrName of attrsGroup){allowedAttributes.add(attrName)}}const groupDefaults=attrsGroupsDefaults[attrsGroupName];if(groupDefaults){for(const[attrName,defaultValue]of Object.entries(groupDefaults)){attributesDefaults.set(attrName,defaultValue)}}}allowedChildrenPerElement.set(name,allowedChildren);allowedAttributesPerElement.set(name,allowedAttributes);attributesDefaultsPerElement.set(name,attributesDefaults)}exports.fn=(root,params)=>{const{unknownContent=true,unknownAttrs=true,defaultAttrs=true,uselessOverrides=true,keepDataAttrs=true,keepAriaAttrs=true,keepRoleAttr=false}=params;const stylesheet=collectStylesheet(root);return{element:{enter:(node,parentNode)=>{if(node.name.includes(\":\")){return}if(node.name===\"foreignObject\"){return visitSkip}if(unknownContent&&parentNode.type===\"element\"){const allowedChildren=allowedChildrenPerElement.get(parentNode.name);if(allowedChildren==null||allowedChildren.size===0){if(allowedChildrenPerElement.get(node.name)==null){detachNodeFromParent(node,parentNode);return}}else{if(allowedChildren.has(node.name)===false){detachNodeFromParent(node,parentNode);return}}}const allowedAttributes=allowedAttributesPerElement.get(node.name);const attributesDefaults=attributesDefaultsPerElement.get(node.name);const computedParentStyle=parentNode.type===\"element\"?computeStyle(stylesheet,parentNode):null;for(const[name,value]of Object.entries(node.attributes)){if(keepDataAttrs&&name.startsWith(\"data-\")){continue}if(keepAriaAttrs&&name.startsWith(\"aria-\")){continue}if(keepRoleAttr&&name===\"role\"){continue}if(name===\"xmlns\"){continue}if(name.includes(\":\")){const[prefix]=name.split(\":\");if(prefix!==\"xml\"&&prefix!==\"xlink\"){continue}}if(unknownAttrs&&allowedAttributes&&allowedAttributes.has(name)===false){delete node.attributes[name]}if(defaultAttrs&&node.attributes.id==null&&attributesDefaults&&attributesDefaults.get(name)===value){if(computedParentStyle?.[name]==null){delete node.attributes[name]}}if(uselessOverrides&&node.attributes.id==null){const style=computedParentStyle?.[name];if(presentationNonInheritableGroupAttrs.includes(name)===false&&style!=null&&style.type===\"static\"&&style.value===value){delete node.attributes[name]}}}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/removeUnknownsAndDefaults.js"],"sourcesContent":["'use strict';\n\nconst { visitSkip, detachNodeFromParent } = require('../lib/xast.js');\nconst { collectStylesheet, computeStyle } = require('../lib/style.js');\nconst {\n  elems,\n  attrsGroups,\n  elemsGroups,\n  attrsGroupsDefaults,\n  presentationNonInheritableGroupAttrs,\n} = require('./_collections');\n\nexports.name = 'removeUnknownsAndDefaults';\nexports.description =\n  'removes unknown elements content and attributes, removes attrs with default values';\n\n// resolve all groups references\n\n/**\n * @type {Map<string, Set<string>>}\n */\nconst allowedChildrenPerElement = new Map();\n/**\n * @type {Map<string, Set<string>>}\n */\nconst allowedAttributesPerElement = new Map();\n/**\n * @type {Map<string, Map<string, string>>}\n */\nconst attributesDefaultsPerElement = new Map();\n\nfor (const [name, config] of Object.entries(elems)) {\n  /**\n   * @type {Set<string>}\n   */\n  const allowedChildren = new Set();\n  if (config.content) {\n    for (const elementName of config.content) {\n      allowedChildren.add(elementName);\n    }\n  }\n  if (config.contentGroups) {\n    for (const contentGroupName of config.contentGroups) {\n      const elemsGroup = elemsGroups[contentGroupName];\n      if (elemsGroup) {\n        for (const elementName of elemsGroup) {\n          allowedChildren.add(elementName);\n        }\n      }\n    }\n  }\n  /**\n   * @type {Set<string>}\n   */\n  const allowedAttributes = new Set();\n  if (config.attrs) {\n    for (const attrName of config.attrs) {\n      allowedAttributes.add(attrName);\n    }\n  }\n  /**\n   * @type {Map<string, string>}\n   */\n  const attributesDefaults = new Map();\n  if (config.defaults) {\n    for (const [attrName, defaultValue] of Object.entries(config.defaults)) {\n      attributesDefaults.set(attrName, defaultValue);\n    }\n  }\n  for (const attrsGroupName of config.attrsGroups) {\n    const attrsGroup = attrsGroups[attrsGroupName];\n    if (attrsGroup) {\n      for (const attrName of attrsGroup) {\n        allowedAttributes.add(attrName);\n      }\n    }\n    const groupDefaults = attrsGroupsDefaults[attrsGroupName];\n    if (groupDefaults) {\n      for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {\n        attributesDefaults.set(attrName, defaultValue);\n      }\n    }\n  }\n  allowedChildrenPerElement.set(name, allowedChildren);\n  allowedAttributesPerElement.set(name, allowedAttributes);\n  attributesDefaultsPerElement.set(name, attributesDefaults);\n}\n\n/**\n * Remove unknown elements content and attributes,\n * remove attributes with default values.\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'removeUnknownsAndDefaults'>}\n */\nexports.fn = (root, params) => {\n  const {\n    unknownContent = true,\n    unknownAttrs = true,\n    defaultAttrs = true,\n    uselessOverrides = true,\n    keepDataAttrs = true,\n    keepAriaAttrs = true,\n    keepRoleAttr = false,\n  } = params;\n  const stylesheet = collectStylesheet(root);\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip namespaced elements\n        if (node.name.includes(':')) {\n          return;\n        }\n        // skip visiting foreignObject subtree\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n\n        // remove unknown element's content\n        if (unknownContent && parentNode.type === 'element') {\n          const allowedChildren = allowedChildrenPerElement.get(\n            parentNode.name\n          );\n          if (allowedChildren == null || allowedChildren.size === 0) {\n            // remove unknown elements\n            if (allowedChildrenPerElement.get(node.name) == null) {\n              detachNodeFromParent(node, parentNode);\n              return;\n            }\n          } else {\n            // remove not allowed children\n            if (allowedChildren.has(node.name) === false) {\n              detachNodeFromParent(node, parentNode);\n              return;\n            }\n          }\n        }\n\n        const allowedAttributes = allowedAttributesPerElement.get(node.name);\n        const attributesDefaults = attributesDefaultsPerElement.get(node.name);\n        const computedParentStyle =\n          parentNode.type === 'element'\n            ? computeStyle(stylesheet, parentNode)\n            : null;\n\n        // remove element's unknown attrs and attrs with default values\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (keepDataAttrs && name.startsWith('data-')) {\n            continue;\n          }\n          if (keepAriaAttrs && name.startsWith('aria-')) {\n            continue;\n          }\n          if (keepRoleAttr && name === 'role') {\n            continue;\n          }\n          // skip xmlns attribute\n          if (name === 'xmlns') {\n            continue;\n          }\n          // skip namespaced attributes except xml:* and xlink:*\n          if (name.includes(':')) {\n            const [prefix] = name.split(':');\n            if (prefix !== 'xml' && prefix !== 'xlink') {\n              continue;\n            }\n          }\n\n          if (\n            unknownAttrs &&\n            allowedAttributes &&\n            allowedAttributes.has(name) === false\n          ) {\n            delete node.attributes[name];\n          }\n          if (\n            defaultAttrs &&\n            node.attributes.id == null &&\n            attributesDefaults &&\n            attributesDefaults.get(name) === value\n          ) {\n            // keep defaults if parent has own or inherited style\n            if (computedParentStyle?.[name] == null) {\n              delete node.attributes[name];\n            }\n          }\n          if (uselessOverrides && node.attributes.id == null) {\n            const style = computedParentStyle?.[name];\n            if (\n              presentationNonInheritableGroupAttrs.includes(name) === false &&\n              style != null &&\n              style.type === 'static' &&\n              style.value === value\n            ) {\n              delete node.attributes[name];\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"]}}