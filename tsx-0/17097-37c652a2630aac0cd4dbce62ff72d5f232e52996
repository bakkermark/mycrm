{"code":"(()=>{\n\"use strict\";const csstree=require(\"css-tree\");const{syntax:{specificity}}=require(\"csso\");const{visitSkip,querySelectorAll,detachNodeFromParent}=require(\"../lib/xast.js\");const{compareSpecificity}=require(\"../lib/style\");exports.name=\"inlineStyles\";exports.description=\"inline styles (additional options)\";exports.fn=(root,params)=>{const{onlyMatchedOnce=true,removeMatchedSelectors=true,useMqs=[\"\",\"screen\"],usePseudos=[\"\"]}=params;const styles=[];let selectors=[];return{element:{enter:(node,parentNode)=>{if(node.name===\"foreignObject\"){return visitSkip}if(node.name!==\"style\"||node.children.length===0){return}if(node.attributes.type!=null&&node.attributes.type!==\"\"&&node.attributes.type!==\"text/css\"){return}let cssText=\"\";for(const child of node.children){if(child.type===\"text\"||child.type===\"cdata\"){cssText+=child.value}}let cssAst=null;try{cssAst=csstree.parse(cssText,{parseValue:false,parseCustomProperty:false})}catch{return}if(cssAst.type===\"StyleSheet\"){styles.push({node,parentNode,cssAst})}csstree.walk(cssAst,{visit:\"Selector\",enter(node2,item){const atrule=this.atrule;const rule=this.rule;if(rule==null){return}let mq=\"\";if(atrule!=null){mq=atrule.name;if(atrule.prelude!=null){mq+=` ${csstree.generate(atrule.prelude)}`}}if(useMqs.includes(mq)===false){return}const pseudos=[];if(node2.type===\"Selector\"){node2.children.forEach((childNode,childItem,childList)=>{if(childNode.type===\"PseudoClassSelector\"||childNode.type===\"PseudoElementSelector\"){pseudos.push({item:childItem,list:childList})}})}const pseudoSelectors=csstree.generate({type:\"Selector\",children:new csstree.List().fromArray(pseudos.map(pseudo=>pseudo.item.data))});if(usePseudos.includes(pseudoSelectors)===false){return}for(const pseudo of pseudos){pseudo.list.remove(pseudo.item)}selectors.push({node:node2,item,rule})}})}},root:{exit:()=>{if(styles.length===0){return}const sortedSelectors=[...selectors].sort((a,b)=>{const aSpecificity=specificity(a.item.data);const bSpecificity=specificity(b.item.data);return compareSpecificity(aSpecificity,bSpecificity)}).reverse();for(const selector of sortedSelectors){const selectorText=csstree.generate(selector.item.data);const matchedElements=[];try{for(const node of querySelectorAll(root,selectorText)){if(node.type===\"element\"){matchedElements.push(node)}}}catch(selectError){continue}if(matchedElements.length===0){continue}if(onlyMatchedOnce&&matchedElements.length>1){continue}for(const selectedEl of matchedElements){const styleDeclarationList=csstree.parse(selectedEl.attributes.style??\"\",{context:\"declarationList\",parseValue:false});if(styleDeclarationList.type!==\"DeclarationList\"){continue}const styleDeclarationItems=new Map;csstree.walk(styleDeclarationList,{visit:\"Declaration\",enter(node,item){styleDeclarationItems.set(node.property.toLowerCase(),item)}});csstree.walk(selector.rule,{visit:\"Declaration\",enter(ruleDeclaration){const matchedItem=styleDeclarationItems.get(ruleDeclaration.property);const ruleDeclarationItem=styleDeclarationList.children.createItem(ruleDeclaration);if(matchedItem==null){styleDeclarationList.children.append(ruleDeclarationItem)}else if(matchedItem.data.important!==true&&ruleDeclaration.important===true){styleDeclarationList.children.replace(matchedItem,ruleDeclarationItem);styleDeclarationItems.set(ruleDeclaration.property,ruleDeclarationItem)}}});const newStyles=csstree.generate(styleDeclarationList);if(newStyles.length!==0){selectedEl.attributes.style=newStyles}}if(removeMatchedSelectors&&matchedElements.length!==0&&selector.rule.prelude.type===\"SelectorList\"){selector.rule.prelude.children.remove(selector.item)}selector.matchedElements=matchedElements}if(removeMatchedSelectors===false){return}for(const selector of sortedSelectors){if(selector.matchedElements==null){continue}if(onlyMatchedOnce&&selector.matchedElements.length>1){continue}for(const selectedEl of selector.matchedElements){const classList=new Set(selectedEl.attributes.class==null?null:selectedEl.attributes.class.split(\" \"));for(const child of selector.node.children){if(child.type===\"ClassSelector\"){classList.delete(child.name)}}if(classList.size===0){delete selectedEl.attributes.class}else{selectedEl.attributes.class=Array.from(classList).join(\" \")}const firstSubSelector=selector.node.children.first;if(firstSubSelector!=null&&firstSubSelector.type===\"IdSelector\"&&selectedEl.attributes.id===firstSubSelector.name){delete selectedEl.attributes.id}}}for(const style of styles){csstree.walk(style.cssAst,{visit:\"Rule\",enter:function(node,item,list){if(node.type===\"Rule\"&&node.prelude.type===\"SelectorList\"&&node.prelude.children.isEmpty){list.remove(item)}}});if(style.cssAst.children.isEmpty){detachNodeFromParent(style.node,style.parentNode)}else{const firstChild=style.node.children[0];if(firstChild.type===\"text\"||firstChild.type===\"cdata\"){firstChild.value=csstree.generate(style.cssAst)}}}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["node"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/inlineStyles.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').Specificity} Specificity\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n */\n\nconst csstree = require('css-tree');\nconst {\n  // @ts-ignore internal api\n  syntax: { specificity },\n} = require('csso');\nconst {\n  visitSkip,\n  querySelectorAll,\n  detachNodeFromParent,\n} = require('../lib/xast.js');\nconst { compareSpecificity } = require('../lib/style');\n\nexports.name = 'inlineStyles';\nexports.description = 'inline styles (additional options)';\n\n/**\n * Merges styles from style nodes into inline styles.\n *\n * @type {import('./plugins-types').Plugin<'inlineStyles'>}\n * @author strarsis <strarsis@gmail.com>\n */\nexports.fn = (root, params) => {\n  const {\n    onlyMatchedOnce = true,\n    removeMatchedSelectors = true,\n    useMqs = ['', 'screen'],\n    usePseudos = [''],\n  } = params;\n\n  /**\n   * @type {Array<{ node: XastElement, parentNode: XastParent, cssAst: csstree.StyleSheet }>}\n   */\n  const styles = [];\n  /**\n   * @type {Array<{\n   *   node: csstree.Selector,\n   *   item: csstree.ListItem<csstree.CssNode>,\n   *   rule: csstree.Rule,\n   *   matchedElements?: Array<XastElement>\n   * }>}\n   */\n  let selectors = [];\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip <foreignObject /> content\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n        // collect only non-empty <style /> elements\n        if (node.name !== 'style' || node.children.length === 0) {\n          return;\n        }\n        // values other than the empty string or text/css are not used\n        if (\n          node.attributes.type != null &&\n          node.attributes.type !== '' &&\n          node.attributes.type !== 'text/css'\n        ) {\n          return;\n        }\n        // parse css in style element\n        let cssText = '';\n        for (const child of node.children) {\n          if (child.type === 'text' || child.type === 'cdata') {\n            cssText += child.value;\n          }\n        }\n        /**\n         * @type {?csstree.CssNode}\n         */\n        let cssAst = null;\n        try {\n          cssAst = csstree.parse(cssText, {\n            parseValue: false,\n            parseCustomProperty: false,\n          });\n        } catch {\n          return;\n        }\n        if (cssAst.type === 'StyleSheet') {\n          styles.push({ node, parentNode, cssAst });\n        }\n\n        // collect selectors\n        csstree.walk(cssAst, {\n          visit: 'Selector',\n          enter(node, item) {\n            const atrule = this.atrule;\n            const rule = this.rule;\n            if (rule == null) {\n              return;\n            }\n\n            // skip media queries not included into useMqs param\n            let mq = '';\n            if (atrule != null) {\n              mq = atrule.name;\n              if (atrule.prelude != null) {\n                mq += ` ${csstree.generate(atrule.prelude)}`;\n              }\n            }\n            if (useMqs.includes(mq) === false) {\n              return;\n            }\n\n            /**\n             * @type {Array<{\n             *   item: csstree.ListItem<csstree.CssNode>,\n             *   list: csstree.List<csstree.CssNode>\n             * }>}\n             */\n            const pseudos = [];\n            if (node.type === 'Selector') {\n              node.children.forEach((childNode, childItem, childList) => {\n                if (\n                  childNode.type === 'PseudoClassSelector' ||\n                  childNode.type === 'PseudoElementSelector'\n                ) {\n                  pseudos.push({ item: childItem, list: childList });\n                }\n              });\n            }\n\n            // skip pseudo classes and pseudo elements not includes into usePseudos param\n            const pseudoSelectors = csstree.generate({\n              type: 'Selector',\n              children: new csstree.List().fromArray(\n                pseudos.map((pseudo) => pseudo.item.data)\n              ),\n            });\n            if (usePseudos.includes(pseudoSelectors) === false) {\n              return;\n            }\n\n            // remove pseudo classes and elements to allow querySelector match elements\n            // TODO this is not very accurate since some pseudo classes like first-child\n            // are used for selection\n            for (const pseudo of pseudos) {\n              pseudo.list.remove(pseudo.item);\n            }\n\n            selectors.push({ node, item, rule });\n          },\n        });\n      },\n    },\n\n    root: {\n      exit: () => {\n        if (styles.length === 0) {\n          return;\n        }\n        // stable sort selectors\n        const sortedSelectors = [...selectors]\n          .sort((a, b) => {\n            const aSpecificity = specificity(a.item.data);\n            const bSpecificity = specificity(b.item.data);\n            return compareSpecificity(aSpecificity, bSpecificity);\n          })\n          .reverse();\n\n        for (const selector of sortedSelectors) {\n          // match selectors\n          const selectorText = csstree.generate(selector.item.data);\n          /** @type {Array<XastElement>} */\n          const matchedElements = [];\n          try {\n            for (const node of querySelectorAll(root, selectorText)) {\n              if (node.type === 'element') {\n                matchedElements.push(node);\n              }\n            }\n          } catch (selectError) {\n            continue;\n          }\n          // nothing selected\n          if (matchedElements.length === 0) {\n            continue;\n          }\n\n          // apply styles to matched elements\n          // skip selectors that match more than once if option onlyMatchedOnce is enabled\n          if (onlyMatchedOnce && matchedElements.length > 1) {\n            continue;\n          }\n\n          // apply <style/> to matched elements\n          for (const selectedEl of matchedElements) {\n            const styleDeclarationList = csstree.parse(\n              selectedEl.attributes.style ?? '',\n              {\n                context: 'declarationList',\n                parseValue: false,\n              }\n            );\n            if (styleDeclarationList.type !== 'DeclarationList') {\n              continue;\n            }\n            const styleDeclarationItems = new Map();\n            csstree.walk(styleDeclarationList, {\n              visit: 'Declaration',\n              enter(node, item) {\n                styleDeclarationItems.set(node.property.toLowerCase(), item);\n              },\n            });\n            // merge declarations\n            csstree.walk(selector.rule, {\n              visit: 'Declaration',\n              enter(ruleDeclaration) {\n                // existing inline styles have higher priority\n                // no inline styles, external styles,                                    external styles used\n                // inline styles,    external styles same   priority as inline styles,   inline   styles used\n                // inline styles,    external styles higher priority than inline styles, external styles used\n                const matchedItem = styleDeclarationItems.get(\n                  ruleDeclaration.property\n                );\n                const ruleDeclarationItem =\n                  styleDeclarationList.children.createItem(ruleDeclaration);\n                if (matchedItem == null) {\n                  styleDeclarationList.children.append(ruleDeclarationItem);\n                } else if (\n                  matchedItem.data.important !== true &&\n                  ruleDeclaration.important === true\n                ) {\n                  styleDeclarationList.children.replace(\n                    matchedItem,\n                    ruleDeclarationItem\n                  );\n                  styleDeclarationItems.set(\n                    ruleDeclaration.property,\n                    ruleDeclarationItem\n                  );\n                }\n              },\n            });\n\n            const newStyles = csstree.generate(styleDeclarationList);\n            if (newStyles.length !== 0) {\n              selectedEl.attributes.style = newStyles;\n            }\n          }\n\n          if (\n            removeMatchedSelectors &&\n            matchedElements.length !== 0 &&\n            selector.rule.prelude.type === 'SelectorList'\n          ) {\n            // clean up matching simple selectors if option removeMatchedSelectors is enabled\n            selector.rule.prelude.children.remove(selector.item);\n          }\n          selector.matchedElements = matchedElements;\n        }\n\n        // no further processing required\n        if (removeMatchedSelectors === false) {\n          return;\n        }\n\n        // clean up matched class + ID attribute values\n        for (const selector of sortedSelectors) {\n          if (selector.matchedElements == null) {\n            continue;\n          }\n\n          if (onlyMatchedOnce && selector.matchedElements.length > 1) {\n            // skip selectors that match more than once if option onlyMatchedOnce is enabled\n            continue;\n          }\n\n          for (const selectedEl of selector.matchedElements) {\n            // class\n            const classList = new Set(\n              selectedEl.attributes.class == null\n                ? null\n                : selectedEl.attributes.class.split(' ')\n            );\n\n            for (const child of selector.node.children) {\n              if (child.type === 'ClassSelector') {\n                classList.delete(child.name);\n              }\n            }\n\n            if (classList.size === 0) {\n              delete selectedEl.attributes.class;\n            } else {\n              selectedEl.attributes.class = Array.from(classList).join(' ');\n            }\n\n            // ID\n            const firstSubSelector = selector.node.children.first;\n            if (\n              firstSubSelector != null &&\n              firstSubSelector.type === 'IdSelector' &&\n              selectedEl.attributes.id === firstSubSelector.name\n            ) {\n              delete selectedEl.attributes.id;\n            }\n          }\n        }\n\n        for (const style of styles) {\n          csstree.walk(style.cssAst, {\n            visit: 'Rule',\n            enter: function (node, item, list) {\n              // clean up <style/> rulesets without any css selectors left\n              if (\n                node.type === 'Rule' &&\n                node.prelude.type === 'SelectorList' &&\n                node.prelude.children.isEmpty\n              ) {\n                list.remove(item);\n              }\n            },\n          });\n\n          // csstree v2 changed this type\n          if (style.cssAst.children.isEmpty) {\n            // remove emtpy style element\n            detachNodeFromParent(style.node, style.parentNode);\n          } else {\n            // update style element if any styles left\n            const firstChild = style.node.children[0];\n            if (firstChild.type === 'text' || firstChild.type === 'cdata') {\n              firstChild.value = csstree.generate(style.cssAst);\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"]}}