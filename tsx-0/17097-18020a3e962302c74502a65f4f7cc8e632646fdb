{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const csstree=require(\"css-tree\");const{referencesProps}=require(\"./_collections.js\");exports.name=\"prefixIds\";exports.description=\"prefix IDs\";const getBasename=__name(path=>{const matched=path.match(/[/\\\\]?([^/\\\\]+)$/);if(matched){return matched[1]}return\"\"},\"getBasename\");const escapeIdentifierName=__name(str=>{return str.replace(/[. ]/g,\"_\")},\"escapeIdentifierName\");const unquote=__name(string=>{if(string.startsWith('\"')&&string.endsWith('\"')||string.startsWith(\"'\")&&string.endsWith(\"'\")){return string.slice(1,-1)}return string},\"unquote\");const prefixId=__name((prefixGenerator,body)=>{const prefix=prefixGenerator(body);if(body.startsWith(prefix)){return body}return prefix+body},\"prefixId\");const prefixReference=__name((prefixGenerator,reference)=>{if(reference.startsWith(\"#\")){return\"#\"+prefixId(prefixGenerator,reference.slice(1))}return null},\"prefixReference\");const generatePrefix=__name((body,node,info,prefixGenerator,delim,history)=>{if(typeof prefixGenerator===\"function\"){let prefix=history.get(body);if(prefix!=null){return prefix}prefix=prefixGenerator(node,info)+delim;history.set(body,prefix);return prefix}if(typeof prefixGenerator===\"string\"){return prefixGenerator+delim}if(prefixGenerator===false){return\"\"}if(info.path!=null&&info.path.length>0){return escapeIdentifierName(getBasename(info.path))+delim}return\"prefix\"+delim},\"generatePrefix\");exports.fn=(_root,params,info)=>{const{delim=\"__\",prefix,prefixIds=true,prefixClassNames=true}=params;const prefixMap=new Map;return{element:{enter:node=>{const prefixGenerator=__name(id=>generatePrefix(id,node,info,prefix,delim,prefixMap),\"prefixGenerator\");if(node.name===\"style\"){if(node.children.length===0){return}let cssText=\"\";if(node.children[0].type===\"text\"||node.children[0].type===\"cdata\"){cssText=node.children[0].value}let cssAst=null;try{cssAst=csstree.parse(cssText,{parseValue:true,parseCustomProperty:false})}catch{return}csstree.walk(cssAst,node2=>{if(prefixIds&&node2.type===\"IdSelector\"||prefixClassNames&&node2.type===\"ClassSelector\"){node2.name=prefixId(prefixGenerator,node2.name);return}if(node2.type===\"Url\"&&node2.value.length>0){const prefixed=prefixReference(prefixGenerator,unquote(node2.value));if(prefixed!=null){node2.value=prefixed}}});if(node.children[0].type===\"text\"||node.children[0].type===\"cdata\"){node.children[0].value=csstree.generate(cssAst)}return}if(prefixIds&&node.attributes.id!=null&&node.attributes.id.length!==0){node.attributes.id=prefixId(prefixGenerator,node.attributes.id)}if(prefixClassNames&&node.attributes.class!=null&&node.attributes.class.length!==0){node.attributes.class=node.attributes.class.split(/\\s+/).map(name=>prefixId(prefixGenerator,name)).join(\" \")}for(const name of[\"href\",\"xlink:href\"]){if(node.attributes[name]!=null&&node.attributes[name].length!==0){const prefixed=prefixReference(prefixGenerator,node.attributes[name]);if(prefixed!=null){node.attributes[name]=prefixed}}}for(const name of referencesProps){if(node.attributes[name]!=null&&node.attributes[name].length!==0){node.attributes[name]=node.attributes[name].replace(/url\\((.*?)\\)/gi,(match,url)=>{const prefixed=prefixReference(prefixGenerator,url);if(prefixed==null){return match}return`url(${prefixed})`})}}for(const name of[\"begin\",\"end\"]){if(node.attributes[name]!=null&&node.attributes[name].length!==0){const parts=node.attributes[name].split(/\\s*;\\s+/).map(val=>{if(val.endsWith(\".end\")||val.endsWith(\".start\")){const[id,postfix]=val.split(\".\");return`${prefixId(prefixGenerator,id)}.${postfix}`}return val});node.attributes[name]=parts.join(\"; \")}}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["node"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/prefixIds.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types.js').PluginInfo} PluginInfo\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst csstree = require('css-tree');\nconst { referencesProps } = require('./_collections.js');\n\nexports.name = 'prefixIds';\nexports.description = 'prefix IDs';\n\n/**\n * extract basename from path\n * @type {(path: string) => string}\n */\nconst getBasename = (path) => {\n  // extract everything after latest slash or backslash\n  const matched = path.match(/[/\\\\]?([^/\\\\]+)$/);\n  if (matched) {\n    return matched[1];\n  }\n  return '';\n};\n\n/**\n * escapes a string for being used as ID\n * @type {(string: string) => string}\n */\nconst escapeIdentifierName = (str) => {\n  return str.replace(/[. ]/g, '_');\n};\n\n/**\n * @type {(string: string) => string}\n */\nconst unquote = (string) => {\n  if (\n    (string.startsWith('\"') && string.endsWith('\"')) ||\n    (string.startsWith(\"'\") && string.endsWith(\"'\"))\n  ) {\n    return string.slice(1, -1);\n  }\n  return string;\n};\n\n/**\n * Prefix the given string, unless it already starts with the generated prefix.\n *\n * @param {(id: string) => string} prefixGenerator Function to generate a prefix.\n * @param {string} body An arbitrary string.\n * @returns {string} The given string with a prefix prepended to it.\n */\nconst prefixId = (prefixGenerator, body) => {\n  const prefix = prefixGenerator(body);\n  if (body.startsWith(prefix)) {\n    return body;\n  }\n  return prefix + body;\n};\n\n/**\n * Insert the prefix in a reference string. A reference string is already\n * prefixed with #, so the prefix is inserted after the first character.\n *\n * @param {(id: string) => string} prefixGenerator Function to generate a prefix.\n * @param {string} reference An arbitrary string, should start with \"#\".\n * @returns {?string} The given string with a prefix inserted, or null if the string did not start with \"#\".\n */\nconst prefixReference = (prefixGenerator, reference) => {\n  if (reference.startsWith('#')) {\n    return '#' + prefixId(prefixGenerator, reference.slice(1));\n  }\n  return null;\n};\n\n/**\n * Generates a prefix for the given string.\n *\n * @param {string} body An arbitrary string.\n * @param {XastElement} node XML node that the identifier belongs to.\n * @param {PluginInfo} info\n * @param {((node: XastElement, info: PluginInfo) => string)|string|boolean|undefined} prefixGenerator Some way of obtaining a prefix.\n * @param {string} delim Content to insert between the prefix and original value.\n * @param {Map<string, string>} history Map of previously generated prefixes to IDs.\n * @returns {string} A generated prefix.\n */\nconst generatePrefix = (body, node, info, prefixGenerator, delim, history) => {\n  if (typeof prefixGenerator === 'function') {\n    let prefix = history.get(body);\n\n    if (prefix != null) {\n      return prefix;\n    }\n\n    prefix = prefixGenerator(node, info) + delim;\n    history.set(body, prefix);\n    return prefix;\n  }\n\n  if (typeof prefixGenerator === 'string') {\n    return prefixGenerator + delim;\n  }\n\n  if (prefixGenerator === false) {\n    return '';\n  }\n\n  if (info.path != null && info.path.length > 0) {\n    return escapeIdentifierName(getBasename(info.path)) + delim;\n  }\n\n  return 'prefix' + delim;\n};\n\n/**\n * Prefixes identifiers\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('./plugins-types').Plugin<'prefixIds'>}\n */\nexports.fn = (_root, params, info) => {\n  const {\n    delim = '__',\n    prefix,\n    prefixIds = true,\n    prefixClassNames = true,\n  } = params;\n\n  /** @type {Map<string, string>} */\n  const prefixMap = new Map();\n\n  return {\n    element: {\n      enter: (node) => {\n        /**\n         * @param {string} id A node identifier or class.\n         * @returns {string} Given string with a prefix inserted, or null if the string did not start with \"#\".\n         */\n        const prefixGenerator = (id) =>\n          generatePrefix(id, node, info, prefix, delim, prefixMap);\n\n        // prefix id/class selectors and url() references in styles\n        if (node.name === 'style') {\n          // skip empty <style/> elements\n          if (node.children.length === 0) {\n            return;\n          }\n\n          // parse styles\n          let cssText = '';\n          if (\n            node.children[0].type === 'text' ||\n            node.children[0].type === 'cdata'\n          ) {\n            cssText = node.children[0].value;\n          }\n          /**\n           * @type {?csstree.CssNode}\n           */\n          let cssAst = null;\n          try {\n            cssAst = csstree.parse(cssText, {\n              parseValue: true,\n              parseCustomProperty: false,\n            });\n          } catch {\n            return;\n          }\n\n          csstree.walk(cssAst, (node) => {\n            // #ID, .class selectors\n            if (\n              (prefixIds && node.type === 'IdSelector') ||\n              (prefixClassNames && node.type === 'ClassSelector')\n            ) {\n              node.name = prefixId(prefixGenerator, node.name);\n              return;\n            }\n            // url(...) references\n            // csstree v2 changed this type\n            // @ts-ignore\n            if (node.type === 'Url' && node.value.length > 0) {\n              const prefixed = prefixReference(\n                prefixGenerator,\n                // @ts-ignore\n                unquote(node.value)\n              );\n              if (prefixed != null) {\n                // @ts-ignore\n                node.value = prefixed;\n              }\n            }\n          });\n\n          // update styles\n          if (\n            node.children[0].type === 'text' ||\n            node.children[0].type === 'cdata'\n          ) {\n            node.children[0].value = csstree.generate(cssAst);\n          }\n          return;\n        }\n\n        // prefix an ID attribute value\n        if (\n          prefixIds &&\n          node.attributes.id != null &&\n          node.attributes.id.length !== 0\n        ) {\n          node.attributes.id = prefixId(prefixGenerator, node.attributes.id);\n        }\n\n        // prefix a class attribute value\n        if (\n          prefixClassNames &&\n          node.attributes.class != null &&\n          node.attributes.class.length !== 0\n        ) {\n          node.attributes.class = node.attributes.class\n            .split(/\\s+/)\n            .map((name) => prefixId(prefixGenerator, name))\n            .join(' ');\n        }\n\n        // prefix a href attribute value\n        // xlink:href is deprecated, must be still supported\n        for (const name of ['href', 'xlink:href']) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            const prefixed = prefixReference(\n              prefixGenerator,\n              node.attributes[name]\n            );\n            if (prefixed != null) {\n              node.attributes[name] = prefixed;\n            }\n          }\n        }\n\n        // prefix an URL attribute value\n        for (const name of referencesProps) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            node.attributes[name] = node.attributes[name].replace(\n              /url\\((.*?)\\)/gi,\n              (match, url) => {\n                const prefixed = prefixReference(prefixGenerator, url);\n                if (prefixed == null) {\n                  return match;\n                }\n                return `url(${prefixed})`;\n              }\n            );\n          }\n        }\n\n        // prefix begin/end attribute value\n        for (const name of ['begin', 'end']) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            const parts = node.attributes[name].split(/\\s*;\\s+/).map((val) => {\n              if (val.endsWith('.end') || val.endsWith('.start')) {\n                const [id, postfix] = val.split('.');\n                return `${prefixId(prefixGenerator, id)}.${postfix}`;\n              }\n              return val;\n            });\n            node.attributes[name] = parts.join('; ');\n          }\n        }\n      },\n    },\n  };\n};\n"]}}