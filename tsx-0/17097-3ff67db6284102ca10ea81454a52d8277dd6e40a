{"code":"(()=>{\n\"use strict\";const{removeLeadingZero}=require(\"../lib/svgo/tools\");exports.name=\"cleanupNumericValues\";exports.description=\"rounds numeric values to the fixed precision, removes default \\u2018px\\u2019 units\";const regNumericValues=/^([-+]?\\d*\\.?\\d+([eE][-+]?\\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;const absoluteLengths={cm:96/2.54,mm:96/25.4,in:96,pt:4/3,pc:16,px:1};exports.fn=(_root,params)=>{const{floatPrecision=3,leadingZero=true,defaultPx=true,convertToPx=true}=params;return{element:{enter:node=>{if(node.attributes.viewBox!=null){const nums=node.attributes.viewBox.split(/\\s,?\\s*|,\\s*/g);node.attributes.viewBox=nums.map(value=>{const num=Number(value);return Number.isNaN(num)?value:Number(num.toFixed(floatPrecision))}).join(\" \")}for(const[name,value]of Object.entries(node.attributes)){if(name===\"version\"){continue}const match=value.match(regNumericValues);if(match){let num=Number(Number(match[1]).toFixed(floatPrecision));let matchedUnit=match[3]||\"\";let units=matchedUnit;if(convertToPx&&units!==\"\"&&units in absoluteLengths){const pxNum=Number((absoluteLengths[units]*Number(match[1])).toFixed(floatPrecision));if(pxNum.toString().length<match[0].length){num=pxNum;units=\"px\"}}let str;if(leadingZero){str=removeLeadingZero(num)}else{str=num.toString()}if(defaultPx&&units===\"px\"){units=\"\"}node.attributes[name]=str+units}}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":";aAEA,KAAM,CAAE,iBAAkB,EAAI,QAAQ,mBAAmB,EAEzD,QAAQ,KAAO,uBACf,QAAQ,YACN,qFAEF,MAAM,iBACJ,qEAEF,MAAM,gBAAkB,CAEtB,GAAI,GAAK,KACT,GAAI,GAAK,KACT,GAAI,GACJ,GAAI,EAAI,EACR,GAAI,GACJ,GAAI,CACN,EAUA,QAAQ,GAAK,CAAC,MAAO,SAAW,CAC9B,KAAM,CACJ,eAAiB,EACjB,YAAc,KACd,UAAY,KACZ,YAAc,IAChB,EAAI,OAEJ,MAAO,CACL,QAAS,CACP,MAAQ,MAAS,CACf,GAAI,KAAK,WAAW,SAAW,KAAM,CACnC,MAAM,KAAO,KAAK,WAAW,QAAQ,MAAM,eAAe,EAC1D,KAAK,WAAW,QAAU,KACvB,IAAK,OAAU,CACd,MAAM,IAAM,OAAO,KAAK,EACxB,OAAO,OAAO,MAAM,GAAG,EACnB,MACA,OAAO,IAAI,QAAQ,cAAc,CAAC,CACxC,CAAC,EACA,KAAK,GAAG,CACb,CAEA,SAAW,CAAC,KAAM,KAAK,IAAK,OAAO,QAAQ,KAAK,UAAU,EAAG,CAE3D,GAAI,OAAS,UAAW,CACtB,QACF,CAEA,MAAM,MAAQ,MAAM,MAAM,gBAAgB,EAG1C,GAAI,MAAO,CAET,IAAI,IAAM,OAAO,OAAO,MAAM,CAAC,CAAC,EAAE,QAAQ,cAAc,CAAC,EAIzD,IAAI,YAAc,MAAM,CAAC,GAAK,GAI9B,IAAI,MAAQ,YAGZ,GAAI,aAAe,QAAU,IAAM,SAAS,gBAAiB,CAC3D,MAAM,MAAQ,QACX,gBAAgB,KAAK,EAAI,OAAO,MAAM,CAAC,CAAC,GAAG,QAC1C,cACF,CACF,EACA,GAAI,MAAM,SAAS,EAAE,OAAS,MAAM,CAAC,EAAE,OAAQ,CAC7C,IAAM,MACN,MAAQ,IACV,CACF,CAGA,IAAI,IACJ,GAAI,YAAa,CACf,IAAM,kBAAkB,GAAG,CAC7B,KAAO,CACL,IAAM,IAAI,SAAS,CACrB,CAGA,GAAI,WAAa,QAAU,KAAM,CAC/B,MAAQ,EACV,CAEA,KAAK,WAAW,IAAI,EAAI,IAAM,KAChC,CACF,CACF,CACF,CACF,CACF","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/cleanupNumericValues.js"],"sourcesContent":["'use strict';\n\nconst { removeLeadingZero } = require('../lib/svgo/tools');\n\nexports.name = 'cleanupNumericValues';\nexports.description =\n  'rounds numeric values to the fixed precision, removes default ‘px’ units';\n\nconst regNumericValues =\n  /^([-+]?\\d*\\.?\\d+([eE][-+]?\\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;\n\nconst absoluteLengths = {\n  // relative to px\n  cm: 96 / 2.54,\n  mm: 96 / 25.4,\n  in: 96,\n  pt: 4 / 3,\n  pc: 16,\n  px: 1,\n};\n\n/**\n * Round numeric values to the fixed precision,\n * remove default 'px' units.\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'cleanupNumericValues'>}\n */\nexports.fn = (_root, params) => {\n  const {\n    floatPrecision = 3,\n    leadingZero = true,\n    defaultPx = true,\n    convertToPx = true,\n  } = params;\n\n  return {\n    element: {\n      enter: (node) => {\n        if (node.attributes.viewBox != null) {\n          const nums = node.attributes.viewBox.split(/\\s,?\\s*|,\\s*/g);\n          node.attributes.viewBox = nums\n            .map((value) => {\n              const num = Number(value);\n              return Number.isNaN(num)\n                ? value\n                : Number(num.toFixed(floatPrecision));\n            })\n            .join(' ');\n        }\n\n        for (const [name, value] of Object.entries(node.attributes)) {\n          // The `version` attribute is a text string and cannot be rounded\n          if (name === 'version') {\n            continue;\n          }\n\n          const match = value.match(regNumericValues);\n\n          // if attribute value matches regNumericValues\n          if (match) {\n            // round it to the fixed precision\n            let num = Number(Number(match[1]).toFixed(floatPrecision));\n            /**\n             * @type {any}\n             */\n            let matchedUnit = match[3] || '';\n            /**\n             * @type{'' | keyof typeof absoluteLengths}\n             */\n            let units = matchedUnit;\n\n            // convert absolute values to pixels\n            if (convertToPx && units !== '' && units in absoluteLengths) {\n              const pxNum = Number(\n                (absoluteLengths[units] * Number(match[1])).toFixed(\n                  floatPrecision\n                )\n              );\n              if (pxNum.toString().length < match[0].length) {\n                num = pxNum;\n                units = 'px';\n              }\n            }\n\n            // and remove leading zero\n            let str;\n            if (leadingZero) {\n              str = removeLeadingZero(num);\n            } else {\n              str = num.toString();\n            }\n\n            // remove default 'px' units\n            if (defaultPx && units === 'px') {\n              units = '';\n            }\n\n            node.attributes[name] = str + units;\n          }\n        }\n      },\n    },\n  };\n};\n"]}}