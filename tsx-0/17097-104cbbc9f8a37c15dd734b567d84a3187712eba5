{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const proc=typeof process===\"object\"&&process?process:{stdout:null,stderr:null};const EE=require(\"events\");const Stream=require(\"stream\");const stringdecoder=require(\"string_decoder\");const SD=stringdecoder.StringDecoder;const EOF=Symbol(\"EOF\");const MAYBE_EMIT_END=Symbol(\"maybeEmitEnd\");const EMITTED_END=Symbol(\"emittedEnd\");const EMITTING_END=Symbol(\"emittingEnd\");const EMITTED_ERROR=Symbol(\"emittedError\");const CLOSED=Symbol(\"closed\");const READ=Symbol(\"read\");const FLUSH=Symbol(\"flush\");const FLUSHCHUNK=Symbol(\"flushChunk\");const ENCODING=Symbol(\"encoding\");const DECODER=Symbol(\"decoder\");const FLOWING=Symbol(\"flowing\");const PAUSED=Symbol(\"paused\");const RESUME=Symbol(\"resume\");const BUFFER=Symbol(\"buffer\");const PIPES=Symbol(\"pipes\");const BUFFERLENGTH=Symbol(\"bufferLength\");const BUFFERPUSH=Symbol(\"bufferPush\");const BUFFERSHIFT=Symbol(\"bufferShift\");const OBJECTMODE=Symbol(\"objectMode\");const DESTROYED=Symbol(\"destroyed\");const ERROR=Symbol(\"error\");const EMITDATA=Symbol(\"emitData\");const EMITEND=Symbol(\"emitEnd\");const EMITEND2=Symbol(\"emitEnd2\");const ASYNC=Symbol(\"async\");const ABORT=Symbol(\"abort\");const ABORTED=Symbol(\"aborted\");const SIGNAL=Symbol(\"signal\");const defer=__name(fn=>Promise.resolve().then(fn),\"defer\");const doIter=global._MP_NO_ITERATOR_SYMBOLS_!==\"1\";const ASYNCITERATOR=doIter&&Symbol.asyncIterator||Symbol(\"asyncIterator not implemented\");const ITERATOR=doIter&&Symbol.iterator||Symbol(\"iterator not implemented\");const isEndish=__name(ev=>ev===\"end\"||ev===\"finish\"||ev===\"prefinish\",\"isEndish\");const isArrayBuffer=__name(b=>b instanceof ArrayBuffer||typeof b===\"object\"&&b.constructor&&b.constructor.name===\"ArrayBuffer\"&&b.byteLength>=0,\"isArrayBuffer\");const isArrayBufferView=__name(b=>!Buffer.isBuffer(b)&&ArrayBuffer.isView(b),\"isArrayBufferView\");class Pipe{static{__name(this,\"Pipe\")}constructor(src,dest,opts){this.src=src;this.dest=dest;this.opts=opts;this.ondrain=()=>src[RESUME]();dest.on(\"drain\",this.ondrain)}unpipe(){this.dest.removeListener(\"drain\",this.ondrain)}proxyErrors(){}end(){this.unpipe();if(this.opts.end)this.dest.end()}}class PipeProxyErrors extends Pipe{static{__name(this,\"PipeProxyErrors\")}unpipe(){this.src.removeListener(\"error\",this.proxyErrors);super.unpipe()}constructor(src,dest,opts){super(src,dest,opts);this.proxyErrors=er=>dest.emit(\"error\",er);src.on(\"error\",this.proxyErrors)}}class Minipass extends Stream{static{__name(this,\"Minipass\")}constructor(options){super();this[FLOWING]=false;this[PAUSED]=false;this[PIPES]=[];this[BUFFER]=[];this[OBJECTMODE]=options&&options.objectMode||false;if(this[OBJECTMODE])this[ENCODING]=null;else this[ENCODING]=options&&options.encoding||null;if(this[ENCODING]===\"buffer\")this[ENCODING]=null;this[ASYNC]=options&&!!options.async||false;this[DECODER]=this[ENCODING]?new SD(this[ENCODING]):null;this[EOF]=false;this[EMITTED_END]=false;this[EMITTING_END]=false;this[CLOSED]=false;this[EMITTED_ERROR]=null;this.writable=true;this.readable=true;this[BUFFERLENGTH]=0;this[DESTROYED]=false;if(options&&options.debugExposeBuffer===true){Object.defineProperty(this,\"buffer\",{get:()=>this[BUFFER]})}if(options&&options.debugExposePipes===true){Object.defineProperty(this,\"pipes\",{get:()=>this[PIPES]})}this[SIGNAL]=options&&options.signal;this[ABORTED]=false;if(this[SIGNAL]){this[SIGNAL].addEventListener(\"abort\",()=>this[ABORT]());if(this[SIGNAL].aborted){this[ABORT]()}}}get bufferLength(){return this[BUFFERLENGTH]}get encoding(){return this[ENCODING]}set encoding(enc){if(this[OBJECTMODE])throw new Error(\"cannot set encoding in objectMode\");if(this[ENCODING]&&enc!==this[ENCODING]&&(this[DECODER]&&this[DECODER].lastNeed||this[BUFFERLENGTH]))throw new Error(\"cannot change encoding\");if(this[ENCODING]!==enc){this[DECODER]=enc?new SD(enc):null;if(this[BUFFER].length)this[BUFFER]=this[BUFFER].map(chunk=>this[DECODER].write(chunk))}this[ENCODING]=enc}setEncoding(enc){this.encoding=enc}get objectMode(){return this[OBJECTMODE]}set objectMode(om){this[OBJECTMODE]=this[OBJECTMODE]||!!om}get[\"async\"](){return this[ASYNC]}set[\"async\"](a){this[ASYNC]=this[ASYNC]||!!a}[ABORT](){this[ABORTED]=true;this.emit(\"abort\",this[SIGNAL].reason);this.destroy(this[SIGNAL].reason)}get aborted(){return this[ABORTED]}set aborted(_){}write(chunk,encoding,cb){if(this[ABORTED])return false;if(this[EOF])throw new Error(\"write after end\");if(this[DESTROYED]){this.emit(\"error\",Object.assign(new Error(\"Cannot call write after a stream was destroyed\"),{code:\"ERR_STREAM_DESTROYED\"}));return true}if(typeof encoding===\"function\")cb=encoding,encoding=\"utf8\";if(!encoding)encoding=\"utf8\";const fn=this[ASYNC]?defer:f=>f();if(!this[OBJECTMODE]&&!Buffer.isBuffer(chunk)){if(isArrayBufferView(chunk))chunk=Buffer.from(chunk.buffer,chunk.byteOffset,chunk.byteLength);else if(isArrayBuffer(chunk))chunk=Buffer.from(chunk);else if(typeof chunk!==\"string\")this.objectMode=true}if(this[OBJECTMODE]){if(this.flowing&&this[BUFFERLENGTH]!==0)this[FLUSH](true);if(this.flowing)this.emit(\"data\",chunk);else this[BUFFERPUSH](chunk);if(this[BUFFERLENGTH]!==0)this.emit(\"readable\");if(cb)fn(cb);return this.flowing}if(!chunk.length){if(this[BUFFERLENGTH]!==0)this.emit(\"readable\");if(cb)fn(cb);return this.flowing}if(typeof chunk===\"string\"&&!(encoding===this[ENCODING]&&!this[DECODER].lastNeed)){chunk=Buffer.from(chunk,encoding)}if(Buffer.isBuffer(chunk)&&this[ENCODING])chunk=this[DECODER].write(chunk);if(this.flowing&&this[BUFFERLENGTH]!==0)this[FLUSH](true);if(this.flowing)this.emit(\"data\",chunk);else this[BUFFERPUSH](chunk);if(this[BUFFERLENGTH]!==0)this.emit(\"readable\");if(cb)fn(cb);return this.flowing}read(n){if(this[DESTROYED])return null;if(this[BUFFERLENGTH]===0||n===0||n>this[BUFFERLENGTH]){this[MAYBE_EMIT_END]();return null}if(this[OBJECTMODE])n=null;if(this[BUFFER].length>1&&!this[OBJECTMODE]){if(this.encoding)this[BUFFER]=[this[BUFFER].join(\"\")];else this[BUFFER]=[Buffer.concat(this[BUFFER],this[BUFFERLENGTH])]}const ret=this[READ](n||null,this[BUFFER][0]);this[MAYBE_EMIT_END]();return ret}[READ](n,chunk){if(n===chunk.length||n===null)this[BUFFERSHIFT]();else{this[BUFFER][0]=chunk.slice(n);chunk=chunk.slice(0,n);this[BUFFERLENGTH]-=n}this.emit(\"data\",chunk);if(!this[BUFFER].length&&!this[EOF])this.emit(\"drain\");return chunk}end(chunk,encoding,cb){if(typeof chunk===\"function\")cb=chunk,chunk=null;if(typeof encoding===\"function\")cb=encoding,encoding=\"utf8\";if(chunk)this.write(chunk,encoding);if(cb)this.once(\"end\",cb);this[EOF]=true;this.writable=false;if(this.flowing||!this[PAUSED])this[MAYBE_EMIT_END]();return this}[RESUME](){if(this[DESTROYED])return;this[PAUSED]=false;this[FLOWING]=true;this.emit(\"resume\");if(this[BUFFER].length)this[FLUSH]();else if(this[EOF])this[MAYBE_EMIT_END]();else this.emit(\"drain\")}resume(){return this[RESUME]()}pause(){this[FLOWING]=false;this[PAUSED]=true}get destroyed(){return this[DESTROYED]}get flowing(){return this[FLOWING]}get paused(){return this[PAUSED]}[BUFFERPUSH](chunk){if(this[OBJECTMODE])this[BUFFERLENGTH]+=1;else this[BUFFERLENGTH]+=chunk.length;this[BUFFER].push(chunk)}[BUFFERSHIFT](){if(this[OBJECTMODE])this[BUFFERLENGTH]-=1;else this[BUFFERLENGTH]-=this[BUFFER][0].length;return this[BUFFER].shift()}[FLUSH](noDrain){do{}while(this[FLUSHCHUNK](this[BUFFERSHIFT]())&&this[BUFFER].length);if(!noDrain&&!this[BUFFER].length&&!this[EOF])this.emit(\"drain\")}[FLUSHCHUNK](chunk){this.emit(\"data\",chunk);return this.flowing}pipe(dest,opts){if(this[DESTROYED])return;const ended=this[EMITTED_END];opts=opts||{};if(dest===proc.stdout||dest===proc.stderr)opts.end=false;else opts.end=opts.end!==false;opts.proxyErrors=!!opts.proxyErrors;if(ended){if(opts.end)dest.end()}else{this[PIPES].push(!opts.proxyErrors?new Pipe(this,dest,opts):new PipeProxyErrors(this,dest,opts));if(this[ASYNC])defer(()=>this[RESUME]());else this[RESUME]()}return dest}unpipe(dest){const p=this[PIPES].find(p2=>p2.dest===dest);if(p){this[PIPES].splice(this[PIPES].indexOf(p),1);p.unpipe()}}addListener(ev,fn){return this.on(ev,fn)}on(ev,fn){const ret=super.on(ev,fn);if(ev===\"data\"&&!this[PIPES].length&&!this.flowing)this[RESUME]();else if(ev===\"readable\"&&this[BUFFERLENGTH]!==0)super.emit(\"readable\");else if(isEndish(ev)&&this[EMITTED_END]){super.emit(ev);this.removeAllListeners(ev)}else if(ev===\"error\"&&this[EMITTED_ERROR]){if(this[ASYNC])defer(()=>fn.call(this,this[EMITTED_ERROR]));else fn.call(this,this[EMITTED_ERROR])}return ret}get emittedEnd(){return this[EMITTED_END]}[MAYBE_EMIT_END](){if(!this[EMITTING_END]&&!this[EMITTED_END]&&!this[DESTROYED]&&this[BUFFER].length===0&&this[EOF]){this[EMITTING_END]=true;this.emit(\"end\");this.emit(\"prefinish\");this.emit(\"finish\");if(this[CLOSED])this.emit(\"close\");this[EMITTING_END]=false}}emit(ev,data,...extra){if(ev!==\"error\"&&ev!==\"close\"&&ev!==DESTROYED&&this[DESTROYED])return;else if(ev===\"data\"){return!this[OBJECTMODE]&&!data?false:this[ASYNC]?defer(()=>this[EMITDATA](data)):this[EMITDATA](data)}else if(ev===\"end\"){return this[EMITEND]()}else if(ev===\"close\"){this[CLOSED]=true;if(!this[EMITTED_END]&&!this[DESTROYED])return;const ret2=super.emit(\"close\");this.removeAllListeners(\"close\");return ret2}else if(ev===\"error\"){this[EMITTED_ERROR]=data;super.emit(ERROR,data);const ret2=!this[SIGNAL]||this.listeners(\"error\").length?super.emit(\"error\",data):false;this[MAYBE_EMIT_END]();return ret2}else if(ev===\"resume\"){const ret2=super.emit(\"resume\");this[MAYBE_EMIT_END]();return ret2}else if(ev===\"finish\"||ev===\"prefinish\"){const ret2=super.emit(ev);this.removeAllListeners(ev);return ret2}const ret=super.emit(ev,data,...extra);this[MAYBE_EMIT_END]();return ret}[EMITDATA](data){for(const p of this[PIPES]){if(p.dest.write(data)===false)this.pause()}const ret=super.emit(\"data\",data);this[MAYBE_EMIT_END]();return ret}[EMITEND](){if(this[EMITTED_END])return;this[EMITTED_END]=true;this.readable=false;if(this[ASYNC])defer(()=>this[EMITEND2]());else this[EMITEND2]()}[EMITEND2](){if(this[DECODER]){const data=this[DECODER].end();if(data){for(const p of this[PIPES]){p.dest.write(data)}super.emit(\"data\",data)}}for(const p of this[PIPES]){p.end()}const ret=super.emit(\"end\");this.removeAllListeners(\"end\");return ret}collect(){const buf=[];if(!this[OBJECTMODE])buf.dataLength=0;const p=this.promise();this.on(\"data\",c=>{buf.push(c);if(!this[OBJECTMODE])buf.dataLength+=c.length});return p.then(()=>buf)}concat(){return this[OBJECTMODE]?Promise.reject(new Error(\"cannot concat in objectMode\")):this.collect().then(buf=>this[OBJECTMODE]?Promise.reject(new Error(\"cannot concat in objectMode\")):this[ENCODING]?buf.join(\"\"):Buffer.concat(buf,buf.dataLength))}promise(){return new Promise((resolve,reject)=>{this.on(DESTROYED,()=>reject(new Error(\"stream destroyed\")));this.on(\"error\",er=>reject(er));this.on(\"end\",()=>resolve())})}[ASYNCITERATOR](){let stopped=false;const stop=__name(()=>{this.pause();stopped=true;return Promise.resolve({done:true})},\"stop\");const next=__name(()=>{if(stopped)return stop();const res=this.read();if(res!==null)return Promise.resolve({done:false,value:res});if(this[EOF])return stop();let resolve=null;let reject=null;const onerr=__name(er=>{this.removeListener(\"data\",ondata);this.removeListener(\"end\",onend);this.removeListener(DESTROYED,ondestroy);stop();reject(er)},\"onerr\");const ondata=__name(value=>{this.removeListener(\"error\",onerr);this.removeListener(\"end\",onend);this.removeListener(DESTROYED,ondestroy);this.pause();resolve({value,done:!!this[EOF]})},\"ondata\");const onend=__name(()=>{this.removeListener(\"error\",onerr);this.removeListener(\"data\",ondata);this.removeListener(DESTROYED,ondestroy);stop();resolve({done:true})},\"onend\");const ondestroy=__name(()=>onerr(new Error(\"stream destroyed\")),\"ondestroy\");return new Promise((res2,rej)=>{reject=rej;resolve=res2;this.once(DESTROYED,ondestroy);this.once(\"error\",onerr);this.once(\"end\",onend);this.once(\"data\",ondata)})},\"next\");return{next,throw:stop,return:stop,[ASYNCITERATOR](){return this}}}[ITERATOR](){let stopped=false;const stop=__name(()=>{this.pause();this.removeListener(ERROR,stop);this.removeListener(DESTROYED,stop);this.removeListener(\"end\",stop);stopped=true;return{done:true}},\"stop\");const next=__name(()=>{if(stopped)return stop();const value=this.read();return value===null?stop():{value}},\"next\");this.once(\"end\",stop);this.once(ERROR,stop);this.once(DESTROYED,stop);return{next,throw:stop,return:stop,[ITERATOR](){return this}}}destroy(er){if(this[DESTROYED]){if(er)this.emit(\"error\",er);else this.emit(DESTROYED);return this}this[DESTROYED]=true;this[BUFFER].length=0;this[BUFFERLENGTH]=0;if(typeof this.close===\"function\"&&!this[CLOSED])this.close();if(er)this.emit(\"error\",er);else this.emit(DESTROYED);return this}static isStream(s){return!!s&&(s instanceof Minipass||s instanceof Stream||s instanceof EE&&(typeof s.pipe===\"function\"||typeof s.write===\"function\"&&typeof s.end===\"function\"))}}exports.Minipass=Minipass;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["p","ret","res"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/minipass@5.0.0/node_modules/minipass/index.js"],"sourcesContent":["'use strict'\nconst proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nconst EE = require('events')\nconst Stream = require('stream')\nconst stringdecoder = require('string_decoder')\nconst SD = stringdecoder.StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1'\nconst ASYNCITERATOR =\n  (doIter && Symbol.asyncIterator) || Symbol('asyncIterator not implemented')\nconst ITERATOR =\n  (doIter && Symbol.iterator) || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBuffer = b =>\n  b instanceof ArrayBuffer ||\n  (typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors() {}\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nclass Minipass extends Stream {\n  constructor(options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this[PIPES] = []\n    this[BUFFER] = []\n    this[OBJECTMODE] = (options && options.objectMode) || false\n    if (this[OBJECTMODE]) this[ENCODING] = null\n    else this[ENCODING] = (options && options.encoding) || null\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null\n    this[ASYNC] = (options && !!options.async) || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n    this[SIGNAL] = options && options.signal\n    this[ABORTED] = false\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]())\n      if (this[SIGNAL].aborted) {\n        this[ABORT]()\n      }\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  get encoding() {\n    return this[ENCODING]\n  }\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode')\n\n    if (\n      this[ENCODING] &&\n      enc !== this[ENCODING] &&\n      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])\n    )\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this[BUFFER].length)\n        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om\n  }\n\n  get ['async']() {\n    return this[ASYNC]\n  }\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL].reason)\n    this.destroy(this[SIGNAL].reason)\n  }\n\n  get aborted() {\n    return this[ABORTED]\n  }\n  set aborted(_) {}\n\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n      if (this.flowing) this.emit('data', chunk)\n      else this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)\n    ) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this.flowing) this.emit('data', chunk)\n    else this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this.flowing\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')]\n      else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]()\n    else {\n      this[BUFFER][0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') (cb = chunk), (chunk = null)\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n    if (chunk) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  resume() {\n    return this[RESUME]()\n  }\n\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += chunk.length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else this[BUFFERLENGTH] -= this[BUFFER][0].length\n    return this[BUFFER].shift()\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length)\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk)\n    return this.flowing\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe(this, dest, opts)\n          : new PipeProxyErrors(this, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit(ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC]) defer(() => this[EMITEND2]())\n    else this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect() {\n    const buf = []\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE]) buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat() {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength)\n        )\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      stopped = true\n      return Promise.resolve({ done: true })\n    }\n    const next = () => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ASYNCITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      this.removeListener(ERROR, stop)\n      this.removeListener(DESTROYED, stop)\n      this.removeListener('end', stop)\n      stopped = true\n      return { done: true }\n    }\n\n    const next = () => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { value }\n    }\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream(s) {\n    return (\n      !!s &&\n      (s instanceof Minipass ||\n        s instanceof Stream ||\n        (s instanceof EE &&\n          // readable\n          (typeof s.pipe === 'function' ||\n            // writable\n            (typeof s.write === 'function' && typeof s.end === 'function'))))\n    )\n  }\n}\n\nexports.Minipass = Minipass\n"]}}