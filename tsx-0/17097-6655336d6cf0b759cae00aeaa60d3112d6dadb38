{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});var fs=require(\"fs\");var zlib=require(\"zlib\");var fd_slicer=require(\"fd-slicer\");var crc32=require(\"buffer-crc32\");var util=require(\"util\");var EventEmitter=require(\"events\").EventEmitter;var Transform=require(\"stream\").Transform;var PassThrough=require(\"stream\").PassThrough;var Writable=require(\"stream\").Writable;exports.open=open;exports.fromFd=fromFd;exports.fromBuffer=fromBuffer;exports.fromRandomAccessReader=fromRandomAccessReader;exports.dosDateTimeToDate=dosDateTimeToDate;exports.validateFileName=validateFileName;exports.ZipFile=ZipFile;exports.Entry=Entry;exports.RandomAccessReader=RandomAccessReader;function open(path,options,callback){if(typeof options===\"function\"){callback=options;options=null}if(options==null)options={};if(options.autoClose==null)options.autoClose=true;if(options.lazyEntries==null)options.lazyEntries=false;if(options.decodeStrings==null)options.decodeStrings=true;if(options.validateEntrySizes==null)options.validateEntrySizes=true;if(options.strictFileNames==null)options.strictFileNames=false;if(callback==null)callback=defaultCallback;fs.open(path,\"r\",function(err,fd){if(err)return callback(err);fromFd(fd,options,function(err2,zipfile){if(err2)fs.close(fd,defaultCallback);callback(err2,zipfile)})})}__name(open,\"open\");function fromFd(fd,options,callback){if(typeof options===\"function\"){callback=options;options=null}if(options==null)options={};if(options.autoClose==null)options.autoClose=false;if(options.lazyEntries==null)options.lazyEntries=false;if(options.decodeStrings==null)options.decodeStrings=true;if(options.validateEntrySizes==null)options.validateEntrySizes=true;if(options.strictFileNames==null)options.strictFileNames=false;if(callback==null)callback=defaultCallback;fs.fstat(fd,function(err,stats){if(err)return callback(err);var reader=fd_slicer.createFromFd(fd,{autoClose:true});fromRandomAccessReader(reader,stats.size,options,callback)})}__name(fromFd,\"fromFd\");function fromBuffer(buffer,options,callback){if(typeof options===\"function\"){callback=options;options=null}if(options==null)options={};options.autoClose=false;if(options.lazyEntries==null)options.lazyEntries=false;if(options.decodeStrings==null)options.decodeStrings=true;if(options.validateEntrySizes==null)options.validateEntrySizes=true;if(options.strictFileNames==null)options.strictFileNames=false;var reader=fd_slicer.createFromBuffer(buffer,{maxChunkSize:65536});fromRandomAccessReader(reader,buffer.length,options,callback)}__name(fromBuffer,\"fromBuffer\");function fromRandomAccessReader(reader,totalSize,options,callback){if(typeof options===\"function\"){callback=options;options=null}if(options==null)options={};if(options.autoClose==null)options.autoClose=true;if(options.lazyEntries==null)options.lazyEntries=false;if(options.decodeStrings==null)options.decodeStrings=true;var decodeStrings=!!options.decodeStrings;if(options.validateEntrySizes==null)options.validateEntrySizes=true;if(options.strictFileNames==null)options.strictFileNames=false;if(callback==null)callback=defaultCallback;if(typeof totalSize!==\"number\")throw new Error(\"expected totalSize parameter to be a number\");if(totalSize>Number.MAX_SAFE_INTEGER){throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\")}reader.ref();var eocdrWithoutCommentSize=22;var maxCommentSize=65535;var bufferSize=Math.min(eocdrWithoutCommentSize+maxCommentSize,totalSize);var buffer=newBuffer(bufferSize);var bufferReadStart=totalSize-buffer.length;readAndAssertNoEof(reader,buffer,0,bufferSize,bufferReadStart,function(err){if(err)return callback(err);for(var i=bufferSize-eocdrWithoutCommentSize;i>=0;i-=1){if(buffer.readUInt32LE(i)!==101010256)continue;var eocdrBuffer=buffer.slice(i);var diskNumber=eocdrBuffer.readUInt16LE(4);if(diskNumber!==0){return callback(new Error(\"multi-disk zip files are not supported: found disk number: \"+diskNumber))}var entryCount=eocdrBuffer.readUInt16LE(10);var centralDirectoryOffset=eocdrBuffer.readUInt32LE(16);var commentLength=eocdrBuffer.readUInt16LE(20);var expectedCommentLength=eocdrBuffer.length-eocdrWithoutCommentSize;if(commentLength!==expectedCommentLength){return callback(new Error(\"invalid comment length. expected: \"+expectedCommentLength+\". found: \"+commentLength))}var comment=decodeStrings?decodeBuffer(eocdrBuffer,22,eocdrBuffer.length,false):eocdrBuffer.slice(22);if(!(entryCount===65535||centralDirectoryOffset===4294967295)){return callback(null,new ZipFile(reader,centralDirectoryOffset,totalSize,entryCount,comment,options.autoClose,options.lazyEntries,decodeStrings,options.validateEntrySizes,options.strictFileNames))}var zip64EocdlBuffer=newBuffer(20);var zip64EocdlOffset=bufferReadStart+i-zip64EocdlBuffer.length;readAndAssertNoEof(reader,zip64EocdlBuffer,0,zip64EocdlBuffer.length,zip64EocdlOffset,function(err2){if(err2)return callback(err2);if(zip64EocdlBuffer.readUInt32LE(0)!==117853008){return callback(new Error(\"invalid zip64 end of central directory locator signature\"))}var zip64EocdrOffset=readUInt64LE(zip64EocdlBuffer,8);var zip64EocdrBuffer=newBuffer(56);readAndAssertNoEof(reader,zip64EocdrBuffer,0,zip64EocdrBuffer.length,zip64EocdrOffset,function(err3){if(err3)return callback(err3);if(zip64EocdrBuffer.readUInt32LE(0)!==101075792){return callback(new Error(\"invalid zip64 end of central directory record signature\"))}entryCount=readUInt64LE(zip64EocdrBuffer,32);centralDirectoryOffset=readUInt64LE(zip64EocdrBuffer,48);return callback(null,new ZipFile(reader,centralDirectoryOffset,totalSize,entryCount,comment,options.autoClose,options.lazyEntries,decodeStrings,options.validateEntrySizes,options.strictFileNames))})});return}callback(new Error(\"end of central directory record signature not found\"))})}__name(fromRandomAccessReader,\"fromRandomAccessReader\");util.inherits(ZipFile,EventEmitter);function ZipFile(reader,centralDirectoryOffset,fileSize,entryCount,comment,autoClose,lazyEntries,decodeStrings,validateEntrySizes,strictFileNames){var self=this;EventEmitter.call(self);self.reader=reader;self.reader.on(\"error\",function(err){emitError(self,err)});self.reader.once(\"close\",function(){self.emit(\"close\")});self.readEntryCursor=centralDirectoryOffset;self.fileSize=fileSize;self.entryCount=entryCount;self.comment=comment;self.entriesRead=0;self.autoClose=!!autoClose;self.lazyEntries=!!lazyEntries;self.decodeStrings=!!decodeStrings;self.validateEntrySizes=!!validateEntrySizes;self.strictFileNames=!!strictFileNames;self.isOpen=true;self.emittedError=false;if(!self.lazyEntries)self._readEntry()}__name(ZipFile,\"ZipFile\");ZipFile.prototype.close=function(){if(!this.isOpen)return;this.isOpen=false;this.reader.unref()};function emitErrorAndAutoClose(self,err){if(self.autoClose)self.close();emitError(self,err)}__name(emitErrorAndAutoClose,\"emitErrorAndAutoClose\");function emitError(self,err){if(self.emittedError)return;self.emittedError=true;self.emit(\"error\",err)}__name(emitError,\"emitError\");ZipFile.prototype.readEntry=function(){if(!this.lazyEntries)throw new Error(\"readEntry() called without lazyEntries:true\");this._readEntry()};ZipFile.prototype._readEntry=function(){var self=this;if(self.entryCount===self.entriesRead){setImmediate(function(){if(self.autoClose)self.close();if(self.emittedError)return;self.emit(\"end\")});return}if(self.emittedError)return;var buffer=newBuffer(46);readAndAssertNoEof(self.reader,buffer,0,buffer.length,self.readEntryCursor,function(err){if(err)return emitErrorAndAutoClose(self,err);if(self.emittedError)return;var entry=new Entry;var signature=buffer.readUInt32LE(0);if(signature!==33639248)return emitErrorAndAutoClose(self,new Error(\"invalid central directory file header signature: 0x\"+signature.toString(16)));entry.versionMadeBy=buffer.readUInt16LE(4);entry.versionNeededToExtract=buffer.readUInt16LE(6);entry.generalPurposeBitFlag=buffer.readUInt16LE(8);entry.compressionMethod=buffer.readUInt16LE(10);entry.lastModFileTime=buffer.readUInt16LE(12);entry.lastModFileDate=buffer.readUInt16LE(14);entry.crc32=buffer.readUInt32LE(16);entry.compressedSize=buffer.readUInt32LE(20);entry.uncompressedSize=buffer.readUInt32LE(24);entry.fileNameLength=buffer.readUInt16LE(28);entry.extraFieldLength=buffer.readUInt16LE(30);entry.fileCommentLength=buffer.readUInt16LE(32);entry.internalFileAttributes=buffer.readUInt16LE(36);entry.externalFileAttributes=buffer.readUInt32LE(38);entry.relativeOffsetOfLocalHeader=buffer.readUInt32LE(42);if(entry.generalPurposeBitFlag&64)return emitErrorAndAutoClose(self,new Error(\"strong encryption is not supported\"));self.readEntryCursor+=46;buffer=newBuffer(entry.fileNameLength+entry.extraFieldLength+entry.fileCommentLength);readAndAssertNoEof(self.reader,buffer,0,buffer.length,self.readEntryCursor,function(err2){if(err2)return emitErrorAndAutoClose(self,err2);if(self.emittedError)return;var isUtf8=(entry.generalPurposeBitFlag&2048)!==0;entry.fileName=self.decodeStrings?decodeBuffer(buffer,0,entry.fileNameLength,isUtf8):buffer.slice(0,entry.fileNameLength);var fileCommentStart=entry.fileNameLength+entry.extraFieldLength;var extraFieldBuffer=buffer.slice(entry.fileNameLength,fileCommentStart);entry.extraFields=[];var i=0;while(i<extraFieldBuffer.length-3){var headerId=extraFieldBuffer.readUInt16LE(i+0);var dataSize=extraFieldBuffer.readUInt16LE(i+2);var dataStart=i+4;var dataEnd=dataStart+dataSize;if(dataEnd>extraFieldBuffer.length)return emitErrorAndAutoClose(self,new Error(\"extra field length exceeds extra field buffer size\"));var dataBuffer=newBuffer(dataSize);extraFieldBuffer.copy(dataBuffer,0,dataStart,dataEnd);entry.extraFields.push({id:headerId,data:dataBuffer});i=dataEnd}entry.fileComment=self.decodeStrings?decodeBuffer(buffer,fileCommentStart,fileCommentStart+entry.fileCommentLength,isUtf8):buffer.slice(fileCommentStart,fileCommentStart+entry.fileCommentLength);entry.comment=entry.fileComment;self.readEntryCursor+=buffer.length;self.entriesRead+=1;if(entry.uncompressedSize===4294967295||entry.compressedSize===4294967295||entry.relativeOffsetOfLocalHeader===4294967295){var zip64EiefBuffer=null;for(var i=0;i<entry.extraFields.length;i++){var extraField=entry.extraFields[i];if(extraField.id===1){zip64EiefBuffer=extraField.data;break}}if(zip64EiefBuffer==null){return emitErrorAndAutoClose(self,new Error(\"expected zip64 extended information extra field\"))}var index=0;if(entry.uncompressedSize===4294967295){if(index+8>zip64EiefBuffer.length){return emitErrorAndAutoClose(self,new Error(\"zip64 extended information extra field does not include uncompressed size\"))}entry.uncompressedSize=readUInt64LE(zip64EiefBuffer,index);index+=8}if(entry.compressedSize===4294967295){if(index+8>zip64EiefBuffer.length){return emitErrorAndAutoClose(self,new Error(\"zip64 extended information extra field does not include compressed size\"))}entry.compressedSize=readUInt64LE(zip64EiefBuffer,index);index+=8}if(entry.relativeOffsetOfLocalHeader===4294967295){if(index+8>zip64EiefBuffer.length){return emitErrorAndAutoClose(self,new Error(\"zip64 extended information extra field does not include relative header offset\"))}entry.relativeOffsetOfLocalHeader=readUInt64LE(zip64EiefBuffer,index);index+=8}}if(self.decodeStrings){for(var i=0;i<entry.extraFields.length;i++){var extraField=entry.extraFields[i];if(extraField.id===28789){if(extraField.data.length<6){continue}if(extraField.data.readUInt8(0)!==1){continue}var oldNameCrc32=extraField.data.readUInt32LE(1);if(crc32.unsigned(buffer.slice(0,entry.fileNameLength))!==oldNameCrc32){continue}entry.fileName=decodeBuffer(extraField.data,5,extraField.data.length,true);break}}}if(self.validateEntrySizes&&entry.compressionMethod===0){var expectedCompressedSize=entry.uncompressedSize;if(entry.isEncrypted()){expectedCompressedSize+=12}if(entry.compressedSize!==expectedCompressedSize){var msg=\"compressed/uncompressed size mismatch for stored file: \"+entry.compressedSize+\" != \"+entry.uncompressedSize;return emitErrorAndAutoClose(self,new Error(msg))}}if(self.decodeStrings){if(!self.strictFileNames){entry.fileName=entry.fileName.replace(/\\\\/g,\"/\")}var errorMessage=validateFileName(entry.fileName,self.validateFileNameOptions);if(errorMessage!=null)return emitErrorAndAutoClose(self,new Error(errorMessage))}self.emit(\"entry\",entry);if(!self.lazyEntries)self._readEntry()})})};ZipFile.prototype.openReadStream=function(entry,options,callback){var self=this;var relativeStart=0;var relativeEnd=entry.compressedSize;if(callback==null){callback=options;options={}}else{if(options.decrypt!=null){if(!entry.isEncrypted()){throw new Error(\"options.decrypt can only be specified for encrypted entries\")}if(options.decrypt!==false)throw new Error(\"invalid options.decrypt value: \"+options.decrypt);if(entry.isCompressed()){if(options.decompress!==false)throw new Error(\"entry is encrypted and compressed, and options.decompress !== false\")}}if(options.decompress!=null){if(!entry.isCompressed()){throw new Error(\"options.decompress can only be specified for compressed entries\")}if(!(options.decompress===false||options.decompress===true)){throw new Error(\"invalid options.decompress value: \"+options.decompress)}}if(options.start!=null||options.end!=null){if(entry.isCompressed()&&options.decompress!==false){throw new Error(\"start/end range not allowed for compressed entry without options.decompress === false\")}if(entry.isEncrypted()&&options.decrypt!==false){throw new Error(\"start/end range not allowed for encrypted entry without options.decrypt === false\")}}if(options.start!=null){relativeStart=options.start;if(relativeStart<0)throw new Error(\"options.start < 0\");if(relativeStart>entry.compressedSize)throw new Error(\"options.start > entry.compressedSize\")}if(options.end!=null){relativeEnd=options.end;if(relativeEnd<0)throw new Error(\"options.end < 0\");if(relativeEnd>entry.compressedSize)throw new Error(\"options.end > entry.compressedSize\");if(relativeEnd<relativeStart)throw new Error(\"options.end < options.start\")}}if(!self.isOpen)return callback(new Error(\"closed\"));if(entry.isEncrypted()){if(options.decrypt!==false)return callback(new Error(\"entry is encrypted, and options.decrypt !== false\"))}self.reader.ref();var buffer=newBuffer(30);readAndAssertNoEof(self.reader,buffer,0,buffer.length,entry.relativeOffsetOfLocalHeader,function(err){try{if(err)return callback(err);var signature=buffer.readUInt32LE(0);if(signature!==67324752){return callback(new Error(\"invalid local file header signature: 0x\"+signature.toString(16)))}var fileNameLength=buffer.readUInt16LE(26);var extraFieldLength=buffer.readUInt16LE(28);var localFileHeaderEnd=entry.relativeOffsetOfLocalHeader+buffer.length+fileNameLength+extraFieldLength;var decompress;if(entry.compressionMethod===0){decompress=false}else if(entry.compressionMethod===8){decompress=options.decompress!=null?options.decompress:true}else{return callback(new Error(\"unsupported compression method: \"+entry.compressionMethod))}var fileDataStart=localFileHeaderEnd;var fileDataEnd=fileDataStart+entry.compressedSize;if(entry.compressedSize!==0){if(fileDataEnd>self.fileSize){return callback(new Error(\"file data overflows file bounds: \"+fileDataStart+\" + \"+entry.compressedSize+\" > \"+self.fileSize))}}var readStream=self.reader.createReadStream({start:fileDataStart+relativeStart,end:fileDataStart+relativeEnd});var endpointStream=readStream;if(decompress){var destroyed=false;var inflateFilter=zlib.createInflateRaw();readStream.on(\"error\",function(err2){setImmediate(function(){if(!destroyed)inflateFilter.emit(\"error\",err2)})});readStream.pipe(inflateFilter);if(self.validateEntrySizes){endpointStream=new AssertByteCountStream(entry.uncompressedSize);inflateFilter.on(\"error\",function(err2){setImmediate(function(){if(!destroyed)endpointStream.emit(\"error\",err2)})});inflateFilter.pipe(endpointStream)}else{endpointStream=inflateFilter}endpointStream.destroy=function(){destroyed=true;if(inflateFilter!==endpointStream)inflateFilter.unpipe(endpointStream);readStream.unpipe(inflateFilter);readStream.destroy()}}callback(null,endpointStream)}finally{self.reader.unref()}})};function Entry(){}__name(Entry,\"Entry\");Entry.prototype.getLastModDate=function(){return dosDateTimeToDate(this.lastModFileDate,this.lastModFileTime)};Entry.prototype.isEncrypted=function(){return(this.generalPurposeBitFlag&1)!==0};Entry.prototype.isCompressed=function(){return this.compressionMethod===8};function dosDateTimeToDate(date,time){var day=date&31;var month=(date>>5&15)-1;var year=(date>>9&127)+1980;var millisecond=0;var second=(time&31)*2;var minute=time>>5&63;var hour=time>>11&31;return new Date(year,month,day,hour,minute,second,millisecond)}__name(dosDateTimeToDate,\"dosDateTimeToDate\");function validateFileName(fileName){if(fileName.indexOf(\"\\\\\")!==-1){return\"invalid characters in fileName: \"+fileName}if(/^[a-zA-Z]:/.test(fileName)||/^\\//.test(fileName)){return\"absolute path: \"+fileName}if(fileName.split(\"/\").indexOf(\"..\")!==-1){return\"invalid relative path: \"+fileName}return null}__name(validateFileName,\"validateFileName\");function readAndAssertNoEof(reader,buffer,offset,length,position,callback){if(length===0){return setImmediate(function(){callback(null,newBuffer(0))})}reader.read(buffer,offset,length,position,function(err,bytesRead){if(err)return callback(err);if(bytesRead<length){return callback(new Error(\"unexpected EOF\"))}callback()})}__name(readAndAssertNoEof,\"readAndAssertNoEof\");util.inherits(AssertByteCountStream,Transform);function AssertByteCountStream(byteCount){Transform.call(this);this.actualByteCount=0;this.expectedByteCount=byteCount}__name(AssertByteCountStream,\"AssertByteCountStream\");AssertByteCountStream.prototype._transform=function(chunk,encoding,cb){this.actualByteCount+=chunk.length;if(this.actualByteCount>this.expectedByteCount){var msg=\"too many bytes in the stream. expected \"+this.expectedByteCount+\". got at least \"+this.actualByteCount;return cb(new Error(msg))}cb(null,chunk)};AssertByteCountStream.prototype._flush=function(cb){if(this.actualByteCount<this.expectedByteCount){var msg=\"not enough bytes in the stream. expected \"+this.expectedByteCount+\". got only \"+this.actualByteCount;return cb(new Error(msg))}cb()};util.inherits(RandomAccessReader,EventEmitter);function RandomAccessReader(){EventEmitter.call(this);this.refCount=0}__name(RandomAccessReader,\"RandomAccessReader\");RandomAccessReader.prototype.ref=function(){this.refCount+=1};RandomAccessReader.prototype.unref=function(){var self=this;self.refCount-=1;if(self.refCount>0)return;if(self.refCount<0)throw new Error(\"invalid unref\");self.close(onCloseDone);function onCloseDone(err){if(err)return self.emit(\"error\",err);self.emit(\"close\")}__name(onCloseDone,\"onCloseDone\")};RandomAccessReader.prototype.createReadStream=function(options){var start=options.start;var end=options.end;if(start===end){var emptyStream=new PassThrough;setImmediate(function(){emptyStream.end()});return emptyStream}var stream=this._readStreamForRange(start,end);var destroyed=false;var refUnrefFilter=new RefUnrefFilter(this);stream.on(\"error\",function(err){setImmediate(function(){if(!destroyed)refUnrefFilter.emit(\"error\",err)})});refUnrefFilter.destroy=function(){stream.unpipe(refUnrefFilter);refUnrefFilter.unref();stream.destroy()};var byteCounter=new AssertByteCountStream(end-start);refUnrefFilter.on(\"error\",function(err){setImmediate(function(){if(!destroyed)byteCounter.emit(\"error\",err)})});byteCounter.destroy=function(){destroyed=true;refUnrefFilter.unpipe(byteCounter);refUnrefFilter.destroy()};return stream.pipe(refUnrefFilter).pipe(byteCounter)};RandomAccessReader.prototype._readStreamForRange=function(start,end){throw new Error(\"not implemented\")};RandomAccessReader.prototype.read=function(buffer,offset,length,position,callback){var readStream=this.createReadStream({start:position,end:position+length});var writeStream=new Writable;var written=0;writeStream._write=function(chunk,encoding,cb){chunk.copy(buffer,offset+written,0,chunk.length);written+=chunk.length;cb()};writeStream.on(\"finish\",callback);readStream.on(\"error\",function(error){callback(error)});readStream.pipe(writeStream)};RandomAccessReader.prototype.close=function(callback){setImmediate(callback)};util.inherits(RefUnrefFilter,PassThrough);function RefUnrefFilter(context){PassThrough.call(this);this.context=context;this.context.ref();this.unreffedYet=false}__name(RefUnrefFilter,\"RefUnrefFilter\");RefUnrefFilter.prototype._flush=function(cb){this.unref();cb()};RefUnrefFilter.prototype.unref=function(cb){if(this.unreffedYet)return;this.unreffedYet=true;this.context.unref()};var cp437=\"\\0\\u263A\\u263B\\u2665\\u2666\\u2663\\u2660\\u2022\\u25D8\\u25CB\\u25D9\\u2642\\u2640\\u266A\\u266B\\u263C\\u25BA\\u25C4\\u2195\\u203C\\xB6\\xA7\\u25AC\\u21A8\\u2191\\u2193\\u2192\\u2190\\u221F\\u2194\\u25B2\\u25BC !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\u2302\\xC7\\xFC\\xE9\\xE2\\xE4\\xE0\\xE5\\xE7\\xEA\\xEB\\xE8\\xEF\\xEE\\xEC\\xC4\\xC5\\xC9\\xE6\\xC6\\xF4\\xF6\\xF2\\xFB\\xF9\\xFF\\xD6\\xDC\\xA2\\xA3\\xA5\\u20A7\\u0192\\xE1\\xED\\xF3\\xFA\\xF1\\xD1\\xAA\\xBA\\xBF\\u2310\\xAC\\xBD\\xBC\\xA1\\xAB\\xBB\\u2591\\u2592\\u2593\\u2502\\u2524\\u2561\\u2562\\u2556\\u2555\\u2563\\u2551\\u2557\\u255D\\u255C\\u255B\\u2510\\u2514\\u2534\\u252C\\u251C\\u2500\\u253C\\u255E\\u255F\\u255A\\u2554\\u2569\\u2566\\u2560\\u2550\\u256C\\u2567\\u2568\\u2564\\u2565\\u2559\\u2558\\u2552\\u2553\\u256B\\u256A\\u2518\\u250C\\u2588\\u2584\\u258C\\u2590\\u2580\\u03B1\\xDF\\u0393\\u03C0\\u03A3\\u03C3\\xB5\\u03C4\\u03A6\\u0398\\u03A9\\u03B4\\u221E\\u03C6\\u03B5\\u2229\\u2261\\xB1\\u2265\\u2264\\u2320\\u2321\\xF7\\u2248\\xB0\\u2219\\xB7\\u221A\\u207F\\xB2\\u25A0\\xA0\";function decodeBuffer(buffer,start,end,isUtf8){if(isUtf8){return buffer.toString(\"utf8\",start,end)}else{var result=\"\";for(var i=start;i<end;i++){result+=cp437[buffer[i]]}return result}}__name(decodeBuffer,\"decodeBuffer\");function readUInt64LE(buffer,offset){var lower32=buffer.readUInt32LE(offset);var upper32=buffer.readUInt32LE(offset+4);return upper32*4294967296+lower32}__name(readUInt64LE,\"readUInt64LE\");var newBuffer;if(typeof Buffer.allocUnsafe===\"function\"){newBuffer=__name(function(len){return Buffer.allocUnsafe(len)},\"newBuffer\")}else{newBuffer=__name(function(len){return new Buffer(len)},\"newBuffer\")}function defaultCallback(err){if(err)throw err}__name(defaultCallback,\"defaultCallback\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["err"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/yauzl@2.10.0/node_modules/yauzl/index.js"],"sourcesContent":["var fs = require(\"fs\");\nvar zlib = require(\"zlib\");\nvar fd_slicer = require(\"fd-slicer\");\nvar crc32 = require(\"buffer-crc32\");\nvar util = require(\"util\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar Transform = require(\"stream\").Transform;\nvar PassThrough = require(\"stream\").PassThrough;\nvar Writable = require(\"stream\").Writable;\n\nexports.open = open;\nexports.fromFd = fromFd;\nexports.fromBuffer = fromBuffer;\nexports.fromRandomAccessReader = fromRandomAccessReader;\nexports.dosDateTimeToDate = dosDateTimeToDate;\nexports.validateFileName = validateFileName;\nexports.ZipFile = ZipFile;\nexports.Entry = Entry;\nexports.RandomAccessReader = RandomAccessReader;\n\nfunction open(path, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.open(path, \"r\", function(err, fd) {\n    if (err) return callback(err);\n    fromFd(fd, options, function(err, zipfile) {\n      if (err) fs.close(fd, defaultCallback);\n      callback(err, zipfile);\n    });\n  });\n}\n\nfunction fromFd(fd, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.fstat(fd, function(err, stats) {\n    if (err) return callback(err);\n    var reader = fd_slicer.createFromFd(fd, {autoClose: true});\n    fromRandomAccessReader(reader, stats.size, options, callback);\n  });\n}\n\nfunction fromBuffer(buffer, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87\n  var reader = fd_slicer.createFromBuffer(buffer, {maxChunkSize: 0x10000});\n  fromRandomAccessReader(reader, buffer.length, options, callback);\n}\n\nfunction fromRandomAccessReader(reader, totalSize, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  var decodeStrings = !!options.decodeStrings;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  if (typeof totalSize !== \"number\") throw new Error(\"expected totalSize parameter to be a number\");\n  if (totalSize > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\");\n  }\n\n  // the matching unref() call is in zipfile.close()\n  reader.ref();\n\n  // eocdr means End of Central Directory Record.\n  // search backwards for the eocdr signature.\n  // the last field of the eocdr is a variable-length comment.\n  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.\n  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.\n  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.\n  var eocdrWithoutCommentSize = 22;\n  var maxCommentSize = 0xffff; // 2-byte size\n  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);\n  var buffer = newBuffer(bufferSize);\n  var bufferReadStart = totalSize - buffer.length;\n  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {\n    if (err) return callback(err);\n    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {\n      if (buffer.readUInt32LE(i) !== 0x06054b50) continue;\n      // found eocdr\n      var eocdrBuffer = buffer.slice(i);\n\n      // 0 - End of central directory signature = 0x06054b50\n      // 4 - Number of this disk\n      var diskNumber = eocdrBuffer.readUInt16LE(4);\n      if (diskNumber !== 0) {\n        return callback(new Error(\"multi-disk zip files are not supported: found disk number: \" + diskNumber));\n      }\n      // 6 - Disk where central directory starts\n      // 8 - Number of central directory records on this disk\n      // 10 - Total number of central directory records\n      var entryCount = eocdrBuffer.readUInt16LE(10);\n      // 12 - Size of central directory (bytes)\n      // 16 - Offset of start of central directory, relative to start of archive\n      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);\n      // 20 - Comment length\n      var commentLength = eocdrBuffer.readUInt16LE(20);\n      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;\n      if (commentLength !== expectedCommentLength) {\n        return callback(new Error(\"invalid comment length. expected: \" + expectedCommentLength + \". found: \" + commentLength));\n      }\n      // 22 - Comment\n      // the encoding is always cp437.\n      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false)\n                                  : eocdrBuffer.slice(22);\n\n      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {\n        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n      }\n\n      // ZIP64 format\n\n      // ZIP64 Zip64 end of central directory locator\n      var zip64EocdlBuffer = newBuffer(20);\n      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;\n      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {\n        if (err) return callback(err);\n\n        // 0 - zip64 end of central dir locator signature = 0x07064b50\n        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {\n          return callback(new Error(\"invalid zip64 end of central directory locator signature\"));\n        }\n        // 4 - number of the disk with the start of the zip64 end of central directory\n        // 8 - relative offset of the zip64 end of central directory record\n        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);\n        // 16 - total number of disks\n\n        // ZIP64 end of central directory record\n        var zip64EocdrBuffer = newBuffer(56);\n        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {\n          if (err) return callback(err);\n\n          // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {\n            return callback(new Error(\"invalid zip64 end of central directory record signature\"));\n          }\n          // 4 - size of zip64 end of central directory record                8 bytes\n          // 12 - version made by                                             2 bytes\n          // 14 - version needed to extract                                   2 bytes\n          // 16 - number of this disk                                         4 bytes\n          // 20 - number of the disk with the start of the central directory  4 bytes\n          // 24 - total number of entries in the central directory on this disk         8 bytes\n          // 32 - total number of entries in the central directory            8 bytes\n          entryCount = readUInt64LE(zip64EocdrBuffer, 32);\n          // 40 - size of the central directory                               8 bytes\n          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);\n          // 56 - zip64 extensible data sector                                (variable size)\n          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n        });\n      });\n      return;\n    }\n    callback(new Error(\"end of central directory record signature not found\"));\n  });\n}\n\nutil.inherits(ZipFile, EventEmitter);\nfunction ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {\n  var self = this;\n  EventEmitter.call(self);\n  self.reader = reader;\n  // forward close events\n  self.reader.on(\"error\", function(err) {\n    // error closing the fd\n    emitError(self, err);\n  });\n  self.reader.once(\"close\", function() {\n    self.emit(\"close\");\n  });\n  self.readEntryCursor = centralDirectoryOffset;\n  self.fileSize = fileSize;\n  self.entryCount = entryCount;\n  self.comment = comment;\n  self.entriesRead = 0;\n  self.autoClose = !!autoClose;\n  self.lazyEntries = !!lazyEntries;\n  self.decodeStrings = !!decodeStrings;\n  self.validateEntrySizes = !!validateEntrySizes;\n  self.strictFileNames = !!strictFileNames;\n  self.isOpen = true;\n  self.emittedError = false;\n\n  if (!self.lazyEntries) self._readEntry();\n}\nZipFile.prototype.close = function() {\n  if (!this.isOpen) return;\n  this.isOpen = false;\n  this.reader.unref();\n};\n\nfunction emitErrorAndAutoClose(self, err) {\n  if (self.autoClose) self.close();\n  emitError(self, err);\n}\nfunction emitError(self, err) {\n  if (self.emittedError) return;\n  self.emittedError = true;\n  self.emit(\"error\", err);\n}\n\nZipFile.prototype.readEntry = function() {\n  if (!this.lazyEntries) throw new Error(\"readEntry() called without lazyEntries:true\");\n  this._readEntry();\n};\nZipFile.prototype._readEntry = function() {\n  var self = this;\n  if (self.entryCount === self.entriesRead) {\n    // done with metadata\n    setImmediate(function() {\n      if (self.autoClose) self.close();\n      if (self.emittedError) return;\n      self.emit(\"end\");\n    });\n    return;\n  }\n  if (self.emittedError) return;\n  var buffer = newBuffer(46);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n    if (err) return emitErrorAndAutoClose(self, err);\n    if (self.emittedError) return;\n    var entry = new Entry();\n    // 0 - Central directory file header signature\n    var signature = buffer.readUInt32LE(0);\n    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error(\"invalid central directory file header signature: 0x\" + signature.toString(16)));\n    // 4 - Version made by\n    entry.versionMadeBy = buffer.readUInt16LE(4);\n    // 6 - Version needed to extract (minimum)\n    entry.versionNeededToExtract = buffer.readUInt16LE(6);\n    // 8 - General purpose bit flag\n    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);\n    // 10 - Compression method\n    entry.compressionMethod = buffer.readUInt16LE(10);\n    // 12 - File last modification time\n    entry.lastModFileTime = buffer.readUInt16LE(12);\n    // 14 - File last modification date\n    entry.lastModFileDate = buffer.readUInt16LE(14);\n    // 16 - CRC-32\n    entry.crc32 = buffer.readUInt32LE(16);\n    // 20 - Compressed size\n    entry.compressedSize = buffer.readUInt32LE(20);\n    // 24 - Uncompressed size\n    entry.uncompressedSize = buffer.readUInt32LE(24);\n    // 28 - File name length (n)\n    entry.fileNameLength = buffer.readUInt16LE(28);\n    // 30 - Extra field length (m)\n    entry.extraFieldLength = buffer.readUInt16LE(30);\n    // 32 - File comment length (k)\n    entry.fileCommentLength = buffer.readUInt16LE(32);\n    // 34 - Disk number where file starts\n    // 36 - Internal file attributes\n    entry.internalFileAttributes = buffer.readUInt16LE(36);\n    // 38 - External file attributes\n    entry.externalFileAttributes = buffer.readUInt32LE(38);\n    // 42 - Relative offset of local file header\n    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);\n\n    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error(\"strong encryption is not supported\"));\n\n    self.readEntryCursor += 46;\n\n    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);\n    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n      if (err) return emitErrorAndAutoClose(self, err);\n      if (self.emittedError) return;\n      // 46 - File name\n      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;\n      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8)\n                                          : buffer.slice(0, entry.fileNameLength);\n\n      // 46+n - Extra field\n      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;\n      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);\n      entry.extraFields = [];\n      var i = 0;\n      while (i < extraFieldBuffer.length - 3) {\n        var headerId = extraFieldBuffer.readUInt16LE(i + 0);\n        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);\n        var dataStart = i + 4;\n        var dataEnd = dataStart + dataSize;\n        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error(\"extra field length exceeds extra field buffer size\"));\n        var dataBuffer = newBuffer(dataSize);\n        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);\n        entry.extraFields.push({\n          id: headerId,\n          data: dataBuffer,\n        });\n        i = dataEnd;\n      }\n\n      // 46+n+m - File comment\n      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8)\n                                             : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);\n      // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47\n      entry.comment = entry.fileComment;\n\n      self.readEntryCursor += buffer.length;\n      self.entriesRead += 1;\n\n      if (entry.uncompressedSize            === 0xffffffff ||\n          entry.compressedSize              === 0xffffffff ||\n          entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        // ZIP64 format\n        // find the Zip64 Extended Information Extra Field\n        var zip64EiefBuffer = null;\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n          if (extraField.id === 0x0001) {\n            zip64EiefBuffer = extraField.data;\n            break;\n          }\n        }\n        if (zip64EiefBuffer == null) {\n          return emitErrorAndAutoClose(self, new Error(\"expected zip64 extended information extra field\"));\n        }\n        var index = 0;\n        // 0 - Original Size          8 bytes\n        if (entry.uncompressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include uncompressed size\"));\n          }\n          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 8 - Compressed Size        8 bytes\n        if (entry.compressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include compressed size\"));\n          }\n          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 16 - Relative Header Offset 8 bytes\n        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include relative header offset\"));\n          }\n          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 24 - Disk Start Number      4 bytes\n      }\n\n      // check for Info-ZIP Unicode Path Extra Field (0x7075)\n      // see https://github.com/thejoshwolfe/yauzl/issues/33\n      if (self.decodeStrings) {\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n          if (extraField.id === 0x7075) {\n            if (extraField.data.length < 6) {\n              // too short to be meaningful\n              continue;\n            }\n            // Version       1 byte      version of this extra field, currently 1\n            if (extraField.data.readUInt8(0) !== 1) {\n              // > Changes may not be backward compatible so this extra\n              // > field should not be used if the version is not recognized.\n              continue;\n            }\n            // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n            var oldNameCrc32 = extraField.data.readUInt32LE(1);\n            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {\n              // > If the CRC check fails, this UTF-8 Path Extra Field should be\n              // > ignored and the File Name field in the header should be used instead.\n              continue;\n            }\n            // UnicodeName   Variable    UTF-8 version of the entry File Name\n            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);\n            break;\n          }\n        }\n      }\n\n      // validate file size\n      if (self.validateEntrySizes && entry.compressionMethod === 0) {\n        var expectedCompressedSize = entry.uncompressedSize;\n        if (entry.isEncrypted()) {\n          // traditional encryption prefixes the file data with a header\n          expectedCompressedSize += 12;\n        }\n        if (entry.compressedSize !== expectedCompressedSize) {\n          var msg = \"compressed/uncompressed size mismatch for stored file: \" + entry.compressedSize + \" != \" + entry.uncompressedSize;\n          return emitErrorAndAutoClose(self, new Error(msg));\n        }\n      }\n\n      if (self.decodeStrings) {\n        if (!self.strictFileNames) {\n          // allow backslash\n          entry.fileName = entry.fileName.replace(/\\\\/g, \"/\");\n        }\n        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);\n        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));\n      }\n      self.emit(\"entry\", entry);\n\n      if (!self.lazyEntries) self._readEntry();\n    });\n  });\n};\n\nZipFile.prototype.openReadStream = function(entry, options, callback) {\n  var self = this;\n  // parameter validation\n  var relativeStart = 0;\n  var relativeEnd = entry.compressedSize;\n  if (callback == null) {\n    callback = options;\n    options = {};\n  } else {\n    // validate options that the caller has no excuse to get wrong\n    if (options.decrypt != null) {\n      if (!entry.isEncrypted()) {\n        throw new Error(\"options.decrypt can only be specified for encrypted entries\");\n      }\n      if (options.decrypt !== false) throw new Error(\"invalid options.decrypt value: \" + options.decrypt);\n      if (entry.isCompressed()) {\n        if (options.decompress !== false) throw new Error(\"entry is encrypted and compressed, and options.decompress !== false\");\n      }\n    }\n    if (options.decompress != null) {\n      if (!entry.isCompressed()) {\n        throw new Error(\"options.decompress can only be specified for compressed entries\");\n      }\n      if (!(options.decompress === false || options.decompress === true)) {\n        throw new Error(\"invalid options.decompress value: \" + options.decompress);\n      }\n    }\n    if (options.start != null || options.end != null) {\n      if (entry.isCompressed() && options.decompress !== false) {\n        throw new Error(\"start/end range not allowed for compressed entry without options.decompress === false\");\n      }\n      if (entry.isEncrypted() && options.decrypt !== false) {\n        throw new Error(\"start/end range not allowed for encrypted entry without options.decrypt === false\");\n      }\n    }\n    if (options.start != null) {\n      relativeStart = options.start;\n      if (relativeStart < 0) throw new Error(\"options.start < 0\");\n      if (relativeStart > entry.compressedSize) throw new Error(\"options.start > entry.compressedSize\");\n    }\n    if (options.end != null) {\n      relativeEnd = options.end;\n      if (relativeEnd < 0) throw new Error(\"options.end < 0\");\n      if (relativeEnd > entry.compressedSize) throw new Error(\"options.end > entry.compressedSize\");\n      if (relativeEnd < relativeStart) throw new Error(\"options.end < options.start\");\n    }\n  }\n  // any further errors can either be caused by the zipfile,\n  // or were introduced in a minor version of yauzl,\n  // so should be passed to the client rather than thrown.\n  if (!self.isOpen) return callback(new Error(\"closed\"));\n  if (entry.isEncrypted()) {\n    if (options.decrypt !== false) return callback(new Error(\"entry is encrypted, and options.decrypt !== false\"));\n  }\n  // make sure we don't lose the fd before we open the actual read stream\n  self.reader.ref();\n  var buffer = newBuffer(30);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {\n    try {\n      if (err) return callback(err);\n      // 0 - Local file header signature = 0x04034b50\n      var signature = buffer.readUInt32LE(0);\n      if (signature !== 0x04034b50) {\n        return callback(new Error(\"invalid local file header signature: 0x\" + signature.toString(16)));\n      }\n      // all this should be redundant\n      // 4 - Version needed to extract (minimum)\n      // 6 - General purpose bit flag\n      // 8 - Compression method\n      // 10 - File last modification time\n      // 12 - File last modification date\n      // 14 - CRC-32\n      // 18 - Compressed size\n      // 22 - Uncompressed size\n      // 26 - File name length (n)\n      var fileNameLength = buffer.readUInt16LE(26);\n      // 28 - Extra field length (m)\n      var extraFieldLength = buffer.readUInt16LE(28);\n      // 30 - File name\n      // 30+n - Extra field\n      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n      var decompress;\n      if (entry.compressionMethod === 0) {\n        // 0 - The file is stored (no compression)\n        decompress = false;\n      } else if (entry.compressionMethod === 8) {\n        // 8 - The file is Deflated\n        decompress = options.decompress != null ? options.decompress : true;\n      } else {\n        return callback(new Error(\"unsupported compression method: \" + entry.compressionMethod));\n      }\n      var fileDataStart = localFileHeaderEnd;\n      var fileDataEnd = fileDataStart + entry.compressedSize;\n      if (entry.compressedSize !== 0) {\n        // bounds check now, because the read streams will probably not complain loud enough.\n        // since we're dealing with an unsigned offset plus an unsigned size,\n        // we only have 1 thing to check for.\n        if (fileDataEnd > self.fileSize) {\n          return callback(new Error(\"file data overflows file bounds: \" +\n              fileDataStart + \" + \" + entry.compressedSize + \" > \" + self.fileSize));\n        }\n      }\n      var readStream = self.reader.createReadStream({\n        start: fileDataStart + relativeStart,\n        end: fileDataStart + relativeEnd,\n      });\n      var endpointStream = readStream;\n      if (decompress) {\n        var destroyed = false;\n        var inflateFilter = zlib.createInflateRaw();\n        readStream.on(\"error\", function(err) {\n          // setImmediate here because errors can be emitted during the first call to pipe()\n          setImmediate(function() {\n            if (!destroyed) inflateFilter.emit(\"error\", err);\n          });\n        });\n        readStream.pipe(inflateFilter);\n\n        if (self.validateEntrySizes) {\n          endpointStream = new AssertByteCountStream(entry.uncompressedSize);\n          inflateFilter.on(\"error\", function(err) {\n            // forward zlib errors to the client-visible stream\n            setImmediate(function() {\n              if (!destroyed) endpointStream.emit(\"error\", err);\n            });\n          });\n          inflateFilter.pipe(endpointStream);\n        } else {\n          // the zlib filter is the client-visible stream\n          endpointStream = inflateFilter;\n        }\n        // this is part of yauzl's API, so implement this function on the client-visible stream\n        endpointStream.destroy = function() {\n          destroyed = true;\n          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);\n          readStream.unpipe(inflateFilter);\n          // TODO: the inflateFilter may cause a memory leak. see Issue #27.\n          readStream.destroy();\n        };\n      }\n      callback(null, endpointStream);\n    } finally {\n      self.reader.unref();\n    }\n  });\n};\n\nfunction Entry() {\n}\nEntry.prototype.getLastModDate = function() {\n  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);\n};\nEntry.prototype.isEncrypted = function() {\n  return (this.generalPurposeBitFlag & 0x1) !== 0;\n};\nEntry.prototype.isCompressed = function() {\n  return this.compressionMethod === 8;\n};\n\nfunction dosDateTimeToDate(date, time) {\n  var day = date & 0x1f; // 1-31\n  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  var millisecond = 0;\n  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n  var minute = time >> 5 & 0x3f; // 0-59\n  var hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nfunction validateFileName(fileName) {\n  if (fileName.indexOf(\"\\\\\") !== -1) {\n    return \"invalid characters in fileName: \" + fileName;\n  }\n  if (/^[a-zA-Z]:/.test(fileName) || /^\\//.test(fileName)) {\n    return \"absolute path: \" + fileName;\n  }\n  if (fileName.split(\"/\").indexOf(\"..\") !== -1) {\n    return \"invalid relative path: \" + fileName;\n  }\n  // all good\n  return null;\n}\n\nfunction readAndAssertNoEof(reader, buffer, offset, length, position, callback) {\n  if (length === 0) {\n    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file\n    return setImmediate(function() { callback(null, newBuffer(0)); });\n  }\n  reader.read(buffer, offset, length, position, function(err, bytesRead) {\n    if (err) return callback(err);\n    if (bytesRead < length) {\n      return callback(new Error(\"unexpected EOF\"));\n    }\n    callback();\n  });\n}\n\nutil.inherits(AssertByteCountStream, Transform);\nfunction AssertByteCountStream(byteCount) {\n  Transform.call(this);\n  this.actualByteCount = 0;\n  this.expectedByteCount = byteCount;\n}\nAssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {\n  this.actualByteCount += chunk.length;\n  if (this.actualByteCount > this.expectedByteCount) {\n    var msg = \"too many bytes in the stream. expected \" + this.expectedByteCount + \". got at least \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb(null, chunk);\n};\nAssertByteCountStream.prototype._flush = function(cb) {\n  if (this.actualByteCount < this.expectedByteCount) {\n    var msg = \"not enough bytes in the stream. expected \" + this.expectedByteCount + \". got only \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb();\n};\n\nutil.inherits(RandomAccessReader, EventEmitter);\nfunction RandomAccessReader() {\n  EventEmitter.call(this);\n  this.refCount = 0;\n}\nRandomAccessReader.prototype.ref = function() {\n  this.refCount += 1;\n};\nRandomAccessReader.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  self.close(onCloseDone);\n\n  function onCloseDone(err) {\n    if (err) return self.emit('error', err);\n    self.emit('close');\n  }\n};\nRandomAccessReader.prototype.createReadStream = function(options) {\n  var start = options.start;\n  var end = options.end;\n  if (start === end) {\n    var emptyStream = new PassThrough();\n    setImmediate(function() {\n      emptyStream.end();\n    });\n    return emptyStream;\n  }\n  var stream = this._readStreamForRange(start, end);\n\n  var destroyed = false;\n  var refUnrefFilter = new RefUnrefFilter(this);\n  stream.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) refUnrefFilter.emit(\"error\", err);\n    });\n  });\n  refUnrefFilter.destroy = function() {\n    stream.unpipe(refUnrefFilter);\n    refUnrefFilter.unref();\n    stream.destroy();\n  };\n\n  var byteCounter = new AssertByteCountStream(end - start);\n  refUnrefFilter.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) byteCounter.emit(\"error\", err);\n    });\n  });\n  byteCounter.destroy = function() {\n    destroyed = true;\n    refUnrefFilter.unpipe(byteCounter);\n    refUnrefFilter.destroy();\n  };\n\n  return stream.pipe(refUnrefFilter).pipe(byteCounter);\n};\nRandomAccessReader.prototype._readStreamForRange = function(start, end) {\n  throw new Error(\"not implemented\");\n};\nRandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {\n  var readStream = this.createReadStream({start: position, end: position + length});\n  var writeStream = new Writable();\n  var written = 0;\n  writeStream._write = function(chunk, encoding, cb) {\n    chunk.copy(buffer, offset + written, 0, chunk.length);\n    written += chunk.length;\n    cb();\n  };\n  writeStream.on(\"finish\", callback);\n  readStream.on(\"error\", function(error) {\n    callback(error);\n  });\n  readStream.pipe(writeStream);\n};\nRandomAccessReader.prototype.close = function(callback) {\n  setImmediate(callback);\n};\n\nutil.inherits(RefUnrefFilter, PassThrough);\nfunction RefUnrefFilter(context) {\n  PassThrough.call(this);\n  this.context = context;\n  this.context.ref();\n  this.unreffedYet = false;\n}\nRefUnrefFilter.prototype._flush = function(cb) {\n  this.unref();\n  cb();\n};\nRefUnrefFilter.prototype.unref = function(cb) {\n  if (this.unreffedYet) return;\n  this.unreffedYet = true;\n  this.context.unref();\n};\n\nvar cp437 = '\\u0000 !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';\nfunction decodeBuffer(buffer, start, end, isUtf8) {\n  if (isUtf8) {\n    return buffer.toString(\"utf8\", start, end);\n  } else {\n    var result = \"\";\n    for (var i = start; i < end; i++) {\n      result += cp437[buffer[i]];\n    }\n    return result;\n  }\n}\n\nfunction readUInt64LE(buffer, offset) {\n  // there is no native function for this, because we can't actually store 64-bit integers precisely.\n  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.\n  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.\n  var lower32 = buffer.readUInt32LE(offset);\n  var upper32 = buffer.readUInt32LE(offset + 4);\n  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.\n  return upper32 * 0x100000000 + lower32;\n  // as long as we're bounds checking the result of this function against the total file size,\n  // we'll catch any overflow errors, because we already made sure the total file size was within reason.\n}\n\n// Node 10 deprecated new Buffer().\nvar newBuffer;\nif (typeof Buffer.allocUnsafe === \"function\") {\n  newBuffer = function(len) {\n    return Buffer.allocUnsafe(len);\n  };\n} else {\n  newBuffer = function(len) {\n    return new Buffer(len);\n  };\n}\n\nfunction defaultCallback(err) {\n  if (err) throw err;\n}\n"]}}