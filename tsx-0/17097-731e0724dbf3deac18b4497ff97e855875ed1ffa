{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{Minipass}=require(\"minipass\");const normPath=require(\"./normalize-windows-path.js\");const SLURP=Symbol(\"slurp\");module.exports=class ReadEntry extends Minipass{static{__name(this,\"ReadEntry\")}constructor(header,ex,gex){super();this.pause();this.extended=ex;this.globalExtended=gex;this.header=header;this.startBlockSize=512*Math.ceil(header.size/512);this.blockRemain=this.startBlockSize;this.remain=header.size;this.type=header.type;this.meta=false;this.ignore=false;switch(this.type){case\"File\":case\"OldFile\":case\"Link\":case\"SymbolicLink\":case\"CharacterDevice\":case\"BlockDevice\":case\"Directory\":case\"FIFO\":case\"ContiguousFile\":case\"GNUDumpDir\":break;case\"NextFileHasLongLinkpath\":case\"NextFileHasLongPath\":case\"OldGnuLongPath\":case\"GlobalExtendedHeader\":case\"ExtendedHeader\":case\"OldExtendedHeader\":this.meta=true;break;default:this.ignore=true}this.path=normPath(header.path);this.mode=header.mode;if(this.mode){this.mode=this.mode&4095}this.uid=header.uid;this.gid=header.gid;this.uname=header.uname;this.gname=header.gname;this.size=header.size;this.mtime=header.mtime;this.atime=header.atime;this.ctime=header.ctime;this.linkpath=normPath(header.linkpath);this.uname=header.uname;this.gname=header.gname;if(ex){this[SLURP](ex)}if(gex){this[SLURP](gex,true)}}write(data){const writeLen=data.length;if(writeLen>this.blockRemain){throw new Error(\"writing more to entry than is appropriate\")}const r=this.remain;const br=this.blockRemain;this.remain=Math.max(0,r-writeLen);this.blockRemain=Math.max(0,br-writeLen);if(this.ignore){return true}if(r>=writeLen){return super.write(data)}return super.write(data.slice(0,r))}[SLURP](ex,global){for(const k in ex){if(ex[k]!==null&&ex[k]!==void 0&&!(global&&k===\"path\")){this[k]=k===\"path\"||k===\"linkpath\"?normPath(ex[k]):ex[k]}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,KAAM,CAAE,QAAS,EAAI,QAAQ,UAAU,EACvC,MAAM,SAAW,QAAQ,6BAA6B,EAEtD,MAAM,MAAQ,OAAO,OAAO,EAC5B,OAAO,QAAU,MAAM,kBAAkB,QAAS,CALlD,MAKkD,0BAChD,YAAa,OAAQ,GAAI,IAAK,CAC5B,MAAM,EAIN,KAAK,MAAM,EACX,KAAK,SAAW,GAChB,KAAK,eAAiB,IACtB,KAAK,OAAS,OACd,KAAK,eAAiB,IAAM,KAAK,KAAK,OAAO,KAAO,GAAG,EACvD,KAAK,YAAc,KAAK,eACxB,KAAK,OAAS,OAAO,KACrB,KAAK,KAAO,OAAO,KACnB,KAAK,KAAO,MACZ,KAAK,OAAS,MACd,OAAQ,KAAK,KAAM,CACjB,IAAK,OACL,IAAK,UACL,IAAK,OACL,IAAK,eACL,IAAK,kBACL,IAAK,cACL,IAAK,YACL,IAAK,OACL,IAAK,iBACL,IAAK,aACH,MAEF,IAAK,0BACL,IAAK,sBACL,IAAK,iBACL,IAAK,uBACL,IAAK,iBACL,IAAK,oBACH,KAAK,KAAO,KACZ,MAIF,QACE,KAAK,OAAS,IAClB,CAEA,KAAK,KAAO,SAAS,OAAO,IAAI,EAChC,KAAK,KAAO,OAAO,KACnB,GAAI,KAAK,KAAM,CACb,KAAK,KAAO,KAAK,KAAO,IAC1B,CACA,KAAK,IAAM,OAAO,IAClB,KAAK,IAAM,OAAO,IAClB,KAAK,MAAQ,OAAO,MACpB,KAAK,MAAQ,OAAO,MACpB,KAAK,KAAO,OAAO,KACnB,KAAK,MAAQ,OAAO,MACpB,KAAK,MAAQ,OAAO,MACpB,KAAK,MAAQ,OAAO,MACpB,KAAK,SAAW,SAAS,OAAO,QAAQ,EACxC,KAAK,MAAQ,OAAO,MACpB,KAAK,MAAQ,OAAO,MAEpB,GAAI,GAAI,CACN,KAAK,KAAK,EAAE,EAAE,CAChB,CACA,GAAI,IAAK,CACP,KAAK,KAAK,EAAE,IAAK,IAAI,CACvB,CACF,CAEA,MAAO,KAAM,CACX,MAAM,SAAW,KAAK,OACtB,GAAI,SAAW,KAAK,YAAa,CAC/B,MAAM,IAAI,MAAM,2CAA2C,CAC7D,CAEA,MAAM,EAAI,KAAK,OACf,MAAM,GAAK,KAAK,YAChB,KAAK,OAAS,KAAK,IAAI,EAAG,EAAI,QAAQ,EACtC,KAAK,YAAc,KAAK,IAAI,EAAG,GAAK,QAAQ,EAC5C,GAAI,KAAK,OAAQ,CACf,MAAO,KACT,CAEA,GAAI,GAAK,SAAU,CACjB,OAAO,MAAM,MAAM,IAAI,CACzB,CAGA,OAAO,MAAM,MAAM,KAAK,MAAM,EAAG,CAAC,CAAC,CACrC,CAEA,CAAC,KAAK,EAAG,GAAI,OAAQ,CACnB,UAAW,KAAK,GAAI,CAGlB,GAAI,GAAG,CAAC,IAAM,MAAQ,GAAG,CAAC,IAAM,QAC5B,EAAE,QAAU,IAAM,QAAS,CAC7B,KAAK,CAAC,EAAI,IAAM,QAAU,IAAM,WAAa,SAAS,GAAG,CAAC,CAAC,EAAI,GAAG,CAAC,CACrE,CACF,CACF,CACF","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/read-entry.js"],"sourcesContent":["'use strict'\nconst { Minipass } = require('minipass')\nconst normPath = require('./normalize-windows-path.js')\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends Minipass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = normPath(header.path)\n    this.mode = header.mode\n    if (this.mode) {\n      this.mode = this.mode & 0o7777\n    }\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = normPath(header.linkpath)\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) {\n      this[SLURP](ex)\n    }\n    if (gex) {\n      this[SLURP](gex, true)\n    }\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore) {\n      return true\n    }\n\n    if (r >= writeLen) {\n      return super.write(data)\n    }\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]\n      }\n    }\n  }\n}\n"]}}