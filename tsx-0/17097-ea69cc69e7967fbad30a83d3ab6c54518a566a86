{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{parsePathData,stringifyPathData}=require(\"../lib/path.js\");var prevCtrlPoint;const path2js=__name(path=>{if(path.pathJS)return path.pathJS;const pathData=[];const newPathData=parsePathData(path.attributes.d);for(const{command,args}of newPathData){pathData.push({command,args})}if(pathData.length&&pathData[0].command==\"m\"){pathData[0].command=\"M\"}path.pathJS=pathData;return pathData},\"path2js\");exports.path2js=path2js;const convertRelativeToAbsolute=__name(data=>{const newData=[];let start=[0,0];let cursor=[0,0];for(let{command,args}of data){args=args.slice();if(command===\"m\"){args[0]+=cursor[0];args[1]+=cursor[1];command=\"M\"}if(command===\"M\"){cursor[0]=args[0];cursor[1]=args[1];start[0]=cursor[0];start[1]=cursor[1]}if(command===\"h\"){args[0]+=cursor[0];command=\"H\"}if(command===\"H\"){cursor[0]=args[0]}if(command===\"v\"){args[0]+=cursor[1];command=\"V\"}if(command===\"V\"){cursor[1]=args[0]}if(command===\"l\"){args[0]+=cursor[0];args[1]+=cursor[1];command=\"L\"}if(command===\"L\"){cursor[0]=args[0];cursor[1]=args[1]}if(command===\"c\"){args[0]+=cursor[0];args[1]+=cursor[1];args[2]+=cursor[0];args[3]+=cursor[1];args[4]+=cursor[0];args[5]+=cursor[1];command=\"C\"}if(command===\"C\"){cursor[0]=args[4];cursor[1]=args[5]}if(command===\"s\"){args[0]+=cursor[0];args[1]+=cursor[1];args[2]+=cursor[0];args[3]+=cursor[1];command=\"S\"}if(command===\"S\"){cursor[0]=args[2];cursor[1]=args[3]}if(command===\"q\"){args[0]+=cursor[0];args[1]+=cursor[1];args[2]+=cursor[0];args[3]+=cursor[1];command=\"Q\"}if(command===\"Q\"){cursor[0]=args[2];cursor[1]=args[3]}if(command===\"t\"){args[0]+=cursor[0];args[1]+=cursor[1];command=\"T\"}if(command===\"T\"){cursor[0]=args[0];cursor[1]=args[1]}if(command===\"a\"){args[5]+=cursor[0];args[6]+=cursor[1];command=\"A\"}if(command===\"A\"){cursor[0]=args[5];cursor[1]=args[6]}if(command===\"z\"||command===\"Z\"){cursor[0]=start[0];cursor[1]=start[1];command=\"z\"}newData.push({command,args})}return newData},\"convertRelativeToAbsolute\");exports.js2path=function(path,data,params){path.pathJS=data;const pathData=[];for(const item of data){if(pathData.length!==0&&(item.command===\"M\"||item.command===\"m\")){const last=pathData[pathData.length-1];if(last.command===\"M\"||last.command===\"m\"){pathData.pop()}}pathData.push({command:item.command,args:item.args})}path.attributes.d=stringifyPathData({pathData,precision:params.floatPrecision,disableSpaceAfterFlags:params.noSpaceAfterFlags})};function set(dest,source){dest[0]=source[source.length-2];dest[1]=source[source.length-1];return dest}__name(set,\"set\");exports.intersects=function(path1,path2){const points1=gatherPoints(convertRelativeToAbsolute(path1));const points2=gatherPoints(convertRelativeToAbsolute(path2));if(points1.maxX<=points2.minX||points2.maxX<=points1.minX||points1.maxY<=points2.minY||points2.maxY<=points1.minY||points1.list.every(set1=>{return points2.list.every(set2=>{return set1.list[set1.maxX][0]<=set2.list[set2.minX][0]||set2.list[set2.maxX][0]<=set1.list[set1.minX][0]||set1.list[set1.maxY][1]<=set2.list[set2.minY][1]||set2.list[set2.maxY][1]<=set1.list[set1.minY][1]})}))return false;const hullNest1=points1.list.map(convexHull);const hullNest2=points2.list.map(convexHull);return hullNest1.some(function(hull1){if(hull1.list.length<3)return false;return hullNest2.some(function(hull2){if(hull2.list.length<3)return false;var simplex=[getSupport(hull1,hull2,[1,0])],direction=minus(simplex[0]);var iterations=1e4;while(true){if(iterations--==0){console.error(\"Error: infinite loop while processing mergePaths plugin.\");return true}simplex.push(getSupport(hull1,hull2,direction));if(dot(direction,simplex[simplex.length-1])<=0)return false;if(processSimplex(simplex,direction))return true}})});function getSupport(a,b,direction){return sub(supportPoint(a,direction),supportPoint(b,minus(direction)))}__name(getSupport,\"getSupport\");function supportPoint(polygon,direction){var index=direction[1]>=0?direction[0]<0?polygon.maxY:polygon.maxX:direction[0]<0?polygon.minX:polygon.minY,max=-Infinity,value;while((value=dot(polygon.list[index],direction))>max){max=value;index=++index%polygon.list.length}return polygon.list[(index||polygon.list.length)-1]}__name(supportPoint,\"supportPoint\")};function processSimplex(simplex,direction){if(simplex.length==2){let a=simplex[1],b=simplex[0],AO=minus(simplex[1]),AB=sub(b,a);if(dot(AO,AB)>0){set(direction,orth(AB,a))}else{set(direction,AO);simplex.shift()}}else{let a=simplex[2],b=simplex[1],c=simplex[0],AB=sub(b,a),AC=sub(c,a),AO=minus(a),ACB=orth(AB,AC),ABC=orth(AC,AB);if(dot(ACB,AO)>0){if(dot(AB,AO)>0){set(direction,ACB);simplex.shift()}else{set(direction,AO);simplex.splice(0,2)}}else if(dot(ABC,AO)>0){if(dot(AC,AO)>0){set(direction,ABC);simplex.splice(1,1)}else{set(direction,AO);simplex.splice(0,2)}}else return true}return false}__name(processSimplex,\"processSimplex\");function minus(v){return[-v[0],-v[1]]}__name(minus,\"minus\");function sub(v1,v2){return[v1[0]-v2[0],v1[1]-v2[1]]}__name(sub,\"sub\");function dot(v1,v2){return v1[0]*v2[0]+v1[1]*v2[1]}__name(dot,\"dot\");function orth(v,from){var o=[-v[1],v[0]];return dot(o,minus(from))<0?minus(o):o}__name(orth,\"orth\");function gatherPoints(pathData){const points={list:[],minX:0,minY:0,maxX:0,maxY:0};const addPoint=__name((path,point)=>{if(!path.list.length||point[1]>path.list[path.maxY][1]){path.maxY=path.list.length;points.maxY=points.list.length?Math.max(point[1],points.maxY):point[1]}if(!path.list.length||point[0]>path.list[path.maxX][0]){path.maxX=path.list.length;points.maxX=points.list.length?Math.max(point[0],points.maxX):point[0]}if(!path.list.length||point[1]<path.list[path.minY][1]){path.minY=path.list.length;points.minY=points.list.length?Math.min(point[1],points.minY):point[1]}if(!path.list.length||point[0]<path.list[path.minX][0]){path.minX=path.list.length;points.minX=points.list.length?Math.min(point[0],points.minX):point[0]}path.list.push(point)},\"addPoint\");for(let i=0;i<pathData.length;i+=1){const pathDataItem=pathData[i];let subPath=points.list.length===0?{list:[],minX:0,minY:0,maxX:0,maxY:0}:points.list[points.list.length-1];let prev=i===0?null:pathData[i-1];let basePoint=subPath.list.length===0?null:subPath.list[subPath.list.length-1];let data=pathDataItem.args;let ctrlPoint=basePoint;const toAbsolute=__name((n,i2)=>n+(basePoint==null?0:basePoint[i2%2]),\"toAbsolute\");switch(pathDataItem.command){case\"M\":subPath={list:[],minX:0,minY:0,maxX:0,maxY:0};points.list.push(subPath);break;case\"H\":if(basePoint!=null){addPoint(subPath,[data[0],basePoint[1]])}break;case\"V\":if(basePoint!=null){addPoint(subPath,[basePoint[0],data[0]])}break;case\"Q\":addPoint(subPath,data.slice(0,2));prevCtrlPoint=[data[2]-data[0],data[3]-data[1]];break;case\"T\":if(basePoint!=null&&prev!=null&&(prev.command==\"Q\"||prev.command==\"T\")){ctrlPoint=[basePoint[0]+prevCtrlPoint[0],basePoint[1]+prevCtrlPoint[1]];addPoint(subPath,ctrlPoint);prevCtrlPoint=[data[0]-ctrlPoint[0],data[1]-ctrlPoint[1]]}break;case\"C\":if(basePoint!=null){addPoint(subPath,[.5*(basePoint[0]+data[0]),.5*(basePoint[1]+data[1])])}addPoint(subPath,[.5*(data[0]+data[2]),.5*(data[1]+data[3])]);addPoint(subPath,[.5*(data[2]+data[4]),.5*(data[3]+data[5])]);prevCtrlPoint=[data[4]-data[2],data[5]-data[3]];break;case\"S\":if(basePoint!=null&&prev!=null&&(prev.command==\"C\"||prev.command==\"S\")){addPoint(subPath,[basePoint[0]+.5*prevCtrlPoint[0],basePoint[1]+.5*prevCtrlPoint[1]]);ctrlPoint=[basePoint[0]+prevCtrlPoint[0],basePoint[1]+prevCtrlPoint[1]]}if(ctrlPoint!=null){addPoint(subPath,[.5*(ctrlPoint[0]+data[0]),.5*(ctrlPoint[1]+data[1])])}addPoint(subPath,[.5*(data[0]+data[2]),.5*(data[1]+data[3])]);prevCtrlPoint=[data[2]-data[0],data[3]-data[1]];break;case\"A\":if(basePoint!=null){var curves=a2c.apply(0,basePoint.concat(data));for(var cData;(cData=curves.splice(0,6).map(toAbsolute)).length;){if(basePoint!=null){addPoint(subPath,[.5*(basePoint[0]+cData[0]),.5*(basePoint[1]+cData[1])])}addPoint(subPath,[.5*(cData[0]+cData[2]),.5*(cData[1]+cData[3])]);addPoint(subPath,[.5*(cData[2]+cData[4]),.5*(cData[3]+cData[5])]);if(curves.length)addPoint(subPath,basePoint=cData.slice(-2))}}break}if(data.length>=2)addPoint(subPath,data.slice(-2))}return points}__name(gatherPoints,\"gatherPoints\");function convexHull(points){points.list.sort(function(a,b){return a[0]==b[0]?a[1]-b[1]:a[0]-b[0]});var lower=[],minY=0,bottom=0;for(let i=0;i<points.list.length;i++){while(lower.length>=2&&cross(lower[lower.length-2],lower[lower.length-1],points.list[i])<=0){lower.pop()}if(points.list[i][1]<points.list[minY][1]){minY=i;bottom=lower.length}lower.push(points.list[i])}var upper=[],maxY=points.list.length-1,top=0;for(let i=points.list.length;i--;){while(upper.length>=2&&cross(upper[upper.length-2],upper[upper.length-1],points.list[i])<=0){upper.pop()}if(points.list[i][1]>points.list[maxY][1]){maxY=i;top=upper.length}upper.push(points.list[i])}upper.pop();lower.pop();const hullList=lower.concat(upper);const hull={list:hullList,minX:0,maxX:lower.length,minY:bottom,maxY:(lower.length+top)%hullList.length};return hull}__name(convexHull,\"convexHull\");function cross(o,a,b){return(a[0]-o[0])*(b[1]-o[1])-(a[1]-o[1])*(b[0]-o[0])}__name(cross,\"cross\");const a2c=__name((x1,y1,rx,ry,angle,large_arc_flag,sweep_flag,x2,y2,recursive)=>{const _120=Math.PI*120/180;const rad=Math.PI/180*(+angle||0);let res=[];const rotateX=__name((x3,y3,rad2)=>{return x3*Math.cos(rad2)-y3*Math.sin(rad2)},\"rotateX\");const rotateY=__name((x3,y3,rad2)=>{return x3*Math.sin(rad2)+y3*Math.cos(rad2)},\"rotateY\");if(!recursive){x1=rotateX(x1,y1,-rad);y1=rotateY(x1,y1,-rad);x2=rotateX(x2,y2,-rad);y2=rotateY(x2,y2,-rad);var x=(x1-x2)/2,y=(y1-y2)/2;var h=x*x/(rx*rx)+y*y/(ry*ry);if(h>1){h=Math.sqrt(h);rx=h*rx;ry=h*ry}var rx2=rx*rx;var ry2=ry*ry;var k=(large_arc_flag==sweep_flag?-1:1)*Math.sqrt(Math.abs((rx2*ry2-rx2*y*y-ry2*x*x)/(rx2*y*y+ry2*x*x)));var cx=k*rx*y/ry+(x1+x2)/2;var cy=k*-ry*x/rx+(y1+y2)/2;var f1=Math.asin(Number(((y1-cy)/ry).toFixed(9)));var f2=Math.asin(Number(((y2-cy)/ry).toFixed(9)));f1=x1<cx?Math.PI-f1:f1;f2=x2<cx?Math.PI-f2:f2;f1<0&&(f1=Math.PI*2+f1);f2<0&&(f2=Math.PI*2+f2);if(sweep_flag&&f1>f2){f1=f1-Math.PI*2}if(!sweep_flag&&f2>f1){f2=f2-Math.PI*2}}else{f1=recursive[0];f2=recursive[1];cx=recursive[2];cy=recursive[3]}var df=f2-f1;if(Math.abs(df)>_120){var f2old=f2,x2old=x2,y2old=y2;f2=f1+_120*(sweep_flag&&f2>f1?1:-1);x2=cx+rx*Math.cos(f2);y2=cy+ry*Math.sin(f2);res=a2c(x2,y2,rx,ry,angle,0,sweep_flag,x2old,y2old,[f2,f2old,cx,cy])}df=f2-f1;var c1=Math.cos(f1),s1=Math.sin(f1),c2=Math.cos(f2),s2=Math.sin(f2),t=Math.tan(df/4),hx=4/3*rx*t,hy=4/3*ry*t,m=[-hx*s1,hy*c1,x2+hx*s2-x1,y2-hy*c2-y1,x2-x1,y2-y1];if(recursive){return m.concat(res)}else{res=m.concat(res);var newres=[];for(var i=0,n=res.length;i<n;i++){newres[i]=i%2?rotateY(res[i-1],res[i],rad):rotateX(res[i],res[i+1],rad)}return newres}},\"a2c\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["i","x","y","rad"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/_path.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { parsePathData, stringifyPathData } = require('../lib/path.js');\n\n/**\n * @type {[number, number]}\n */\nvar prevCtrlPoint;\n\n/**\n * Convert path string to JS representation.\n *\n * @type {(path: XastElement) => Array<PathDataItem>}\n */\nconst path2js = (path) => {\n  // @ts-ignore legacy\n  if (path.pathJS) return path.pathJS;\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const pathData = []; // JS representation of the path data\n  const newPathData = parsePathData(path.attributes.d);\n  for (const { command, args } of newPathData) {\n    pathData.push({ command, args });\n  }\n  // First moveto is actually absolute. Subsequent coordinates were separated above.\n  if (pathData.length && pathData[0].command == 'm') {\n    pathData[0].command = 'M';\n  }\n  // @ts-ignore legacy\n  path.pathJS = pathData;\n  return pathData;\n};\nexports.path2js = path2js;\n\n/**\n * Convert relative Path data to absolute.\n *\n * @type {(data: Array<PathDataItem>) => Array<PathDataItem>}\n *\n */\nconst convertRelativeToAbsolute = (data) => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const newData = [];\n  let start = [0, 0];\n  let cursor = [0, 0];\n\n  for (let { command, args } of data) {\n    args = args.slice();\n\n    // moveto (x y)\n    if (command === 'm') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'M';\n    }\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n\n    // horizontal lineto (x)\n    if (command === 'h') {\n      args[0] += cursor[0];\n      command = 'H';\n    }\n    if (command === 'H') {\n      cursor[0] = args[0];\n    }\n\n    // vertical lineto (y)\n    if (command === 'v') {\n      args[0] += cursor[1];\n      command = 'V';\n    }\n    if (command === 'V') {\n      cursor[1] = args[0];\n    }\n\n    // lineto (x y)\n    if (command === 'l') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'L';\n    }\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'c') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      args[4] += cursor[0];\n      args[5] += cursor[1];\n      command = 'C';\n    }\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 's') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'S';\n    }\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'q') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'Q';\n    }\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 't') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'T';\n    }\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'a') {\n      args[5] += cursor[0];\n      args[6] += cursor[1];\n      command = 'A';\n    }\n    if (command === 'A') {\n      cursor[0] = args[5];\n      cursor[1] = args[6];\n    }\n\n    // closepath\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n      command = 'z';\n    }\n\n    newData.push({ command, args });\n  }\n  return newData;\n};\n\n/**\n * @typedef {{ floatPrecision?: number, noSpaceAfterFlags?: boolean }} Js2PathParams\n */\n\n/**\n * Convert path array to string.\n *\n * @type {(path: XastElement, data: Array<PathDataItem>, params: Js2PathParams) => void}\n */\nexports.js2path = function (path, data, params) {\n  // @ts-ignore legacy\n  path.pathJS = data;\n\n  const pathData = [];\n  for (const item of data) {\n    // remove moveto commands which are followed by moveto commands\n    if (\n      pathData.length !== 0 &&\n      (item.command === 'M' || item.command === 'm')\n    ) {\n      const last = pathData[pathData.length - 1];\n      if (last.command === 'M' || last.command === 'm') {\n        pathData.pop();\n      }\n    }\n    pathData.push({\n      command: item.command,\n      args: item.args,\n    });\n  }\n\n  path.attributes.d = stringifyPathData({\n    pathData,\n    precision: params.floatPrecision,\n    disableSpaceAfterFlags: params.noSpaceAfterFlags,\n  });\n};\n\n/**\n * @type {(dest: Array<number>, source: Array<number>) => Array<number>}\n */\nfunction set(dest, source) {\n  dest[0] = source[source.length - 2];\n  dest[1] = source[source.length - 1];\n  return dest;\n}\n\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * https://web.archive.org/web/20180822200027/http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @type {(path1: Array<PathDataItem>, path2: Array<PathDataItem>) => boolean}\n */\nexports.intersects = function (path1, path2) {\n  // Collect points of every subpath.\n  const points1 = gatherPoints(convertRelativeToAbsolute(path1));\n  const points2 = gatherPoints(convertRelativeToAbsolute(path2));\n\n  // Axis-aligned bounding box check.\n  if (\n    points1.maxX <= points2.minX ||\n    points2.maxX <= points1.minX ||\n    points1.maxY <= points2.minY ||\n    points2.maxY <= points1.minY ||\n    points1.list.every((set1) => {\n      return points2.list.every((set2) => {\n        return (\n          set1.list[set1.maxX][0] <= set2.list[set2.minX][0] ||\n          set2.list[set2.maxX][0] <= set1.list[set1.minX][0] ||\n          set1.list[set1.maxY][1] <= set2.list[set2.minY][1] ||\n          set2.list[set2.maxY][1] <= set1.list[set1.minY][1]\n        );\n      });\n    })\n  )\n    return false;\n\n  // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n  const hullNest1 = points1.list.map(convexHull);\n  const hullNest2 = points2.list.map(convexHull);\n\n  // Check intersection of every subpath of the first path with every subpath of the second.\n  return hullNest1.some(function (hull1) {\n    if (hull1.list.length < 3) return false;\n\n    return hullNest2.some(function (hull2) {\n      if (hull2.list.length < 3) return false;\n\n      var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex\n        direction = minus(simplex[0]); // set the direction to point towards the origin\n\n      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        // eslint-disable-next-line no-constant-condition\n        if (iterations-- == 0) {\n          console.error(\n            'Error: infinite loop while processing mergePaths plugin.'\n          );\n          return true; // true is the safe value that means “do nothing with paths”\n        }\n        // add a new point\n        simplex.push(getSupport(hull1, hull2, direction));\n        // see if the new point was on the correct side of the origin\n        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;\n        // process the simplex\n        if (processSimplex(simplex, direction)) return true;\n      }\n    });\n  });\n\n  /**\n   * @type {(a: Point, b: Point, direction: Array<number>) => Array<number>}\n   */\n  function getSupport(a, b, direction) {\n    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n  }\n\n  // Computes farthest polygon point in particular direction.\n  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n  /**\n   * @type {(polygon: Point, direction: Array<number>) => Array<number>}\n   */\n  function supportPoint(polygon, direction) {\n    var index =\n        direction[1] >= 0\n          ? direction[0] < 0\n            ? polygon.maxY\n            : polygon.maxX\n          : direction[0] < 0\n          ? polygon.minX\n          : polygon.minY,\n      max = -Infinity,\n      value;\n    while ((value = dot(polygon.list[index], direction)) > max) {\n      max = value;\n      index = ++index % polygon.list.length;\n    }\n    return polygon.list[(index || polygon.list.length) - 1];\n  }\n};\n\n/**\n * @type {(simplex: Array<Array<number>>, direction: Array<number>) => boolean}\n */\nfunction processSimplex(simplex, direction) {\n  // we only need to handle to 1-simplex and 2-simplex\n  if (simplex.length == 2) {\n    // 1-simplex\n    let a = simplex[1],\n      b = simplex[0],\n      AO = minus(simplex[1]),\n      AB = sub(b, a);\n    // AO is in the same direction as AB\n    if (dot(AO, AB) > 0) {\n      // get the vector perpendicular to AB facing O\n      set(direction, orth(AB, a));\n    } else {\n      set(direction, AO);\n      // only A remains in the simplex\n      simplex.shift();\n    }\n  } else {\n    // 2-simplex\n    let a = simplex[2], // [a, b, c] = simplex\n      b = simplex[1],\n      c = simplex[0],\n      AB = sub(b, a),\n      AC = sub(c, a),\n      AO = minus(a),\n      ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C\n      ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n    if (dot(ACB, AO) > 0) {\n      if (dot(AB, AO) > 0) {\n        // region 4\n        set(direction, ACB);\n        simplex.shift(); // simplex = [b, a]\n      } else {\n        // region 5\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else if (dot(ABC, AO) > 0) {\n      if (dot(AC, AO) > 0) {\n        // region 6\n        set(direction, ABC);\n        simplex.splice(1, 1); // simplex = [c, a]\n      } else {\n        // region 5 (again)\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } // region 7\n    else return true;\n  }\n  return false;\n}\n\n/**\n * @type {(v: Array<number>) => Array<number>}\n */\nfunction minus(v) {\n  return [-v[0], -v[1]];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => number}\n */\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\nfunction orth(v, from) {\n  var o = [-v[1], v[0]];\n  return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n\n/**\n * @typedef {{\n *   list: Array<Array<number>>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Point\n */\n\n/**\n * @typedef {{\n *   list: Array<Point>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Points\n */\n\n/**\n * @type {(pathData: Array<PathDataItem>) => Points}\n */\nfunction gatherPoints(pathData) {\n  /**\n   * @type {Points}\n   */\n  const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };\n\n  // Writes data about the extreme points on each axle\n  /**\n   * @type {(path: Point, point: Array<number>) => void}\n   */\n  const addPoint = (path, point) => {\n    if (!path.list.length || point[1] > path.list[path.maxY][1]) {\n      path.maxY = path.list.length;\n      points.maxY = points.list.length\n        ? Math.max(point[1], points.maxY)\n        : point[1];\n    }\n    if (!path.list.length || point[0] > path.list[path.maxX][0]) {\n      path.maxX = path.list.length;\n      points.maxX = points.list.length\n        ? Math.max(point[0], points.maxX)\n        : point[0];\n    }\n    if (!path.list.length || point[1] < path.list[path.minY][1]) {\n      path.minY = path.list.length;\n      points.minY = points.list.length\n        ? Math.min(point[1], points.minY)\n        : point[1];\n    }\n    if (!path.list.length || point[0] < path.list[path.minX][0]) {\n      path.minX = path.list.length;\n      points.minX = points.list.length\n        ? Math.min(point[0], points.minX)\n        : point[0];\n    }\n    path.list.push(point);\n  };\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathDataItem = pathData[i];\n    let subPath =\n      points.list.length === 0\n        ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 }\n        : points.list[points.list.length - 1];\n    let prev = i === 0 ? null : pathData[i - 1];\n    let basePoint =\n      subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];\n    let data = pathDataItem.args;\n    let ctrlPoint = basePoint;\n\n    /**\n     * @type {(n: number, i: number) => number}\n     * TODO fix null hack\n     */\n    const toAbsolute = (n, i) => n + (basePoint == null ? 0 : basePoint[i % 2]);\n\n    switch (pathDataItem.command) {\n      case 'M':\n        subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };\n        points.list.push(subPath);\n        break;\n\n      case 'H':\n        if (basePoint != null) {\n          addPoint(subPath, [data[0], basePoint[1]]);\n        }\n        break;\n\n      case 'V':\n        if (basePoint != null) {\n          addPoint(subPath, [basePoint[0], data[0]]);\n        }\n        break;\n\n      case 'Q':\n        addPoint(subPath, data.slice(0, 2));\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n        break;\n\n      case 'T':\n        if (\n          basePoint != null &&\n          prev != null &&\n          (prev.command == 'Q' || prev.command == 'T')\n        ) {\n          ctrlPoint = [\n            basePoint[0] + prevCtrlPoint[0],\n            basePoint[1] + prevCtrlPoint[1],\n          ];\n          addPoint(subPath, ctrlPoint);\n          prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n        }\n        break;\n\n      case 'C':\n        if (basePoint != null) {\n          // Approximate quibic Bezier curve with middle points between control points\n          addPoint(subPath, [\n            0.5 * (basePoint[0] + data[0]),\n            0.5 * (basePoint[1] + data[1]),\n          ]);\n        }\n        addPoint(subPath, [\n          0.5 * (data[0] + data[2]),\n          0.5 * (data[1] + data[3]),\n        ]);\n        addPoint(subPath, [\n          0.5 * (data[2] + data[4]),\n          0.5 * (data[3] + data[5]),\n        ]);\n        prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n        break;\n\n      case 'S':\n        if (\n          basePoint != null &&\n          prev != null &&\n          (prev.command == 'C' || prev.command == 'S')\n        ) {\n          addPoint(subPath, [\n            basePoint[0] + 0.5 * prevCtrlPoint[0],\n            basePoint[1] + 0.5 * prevCtrlPoint[1],\n          ]);\n          ctrlPoint = [\n            basePoint[0] + prevCtrlPoint[0],\n            basePoint[1] + prevCtrlPoint[1],\n          ];\n        }\n        if (ctrlPoint != null) {\n          addPoint(subPath, [\n            0.5 * (ctrlPoint[0] + data[0]),\n            0.5 * (ctrlPoint[1] + data[1]),\n          ]);\n        }\n        addPoint(subPath, [\n          0.5 * (data[0] + data[2]),\n          0.5 * (data[1] + data[3]),\n        ]);\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n        break;\n\n      case 'A':\n        if (basePoint != null) {\n          // Convert the arc to bezier curves and use the same approximation\n          // @ts-ignore no idea what's going on here\n          var curves = a2c.apply(0, basePoint.concat(data));\n          for (\n            var cData;\n            (cData = curves.splice(0, 6).map(toAbsolute)).length;\n\n          ) {\n            if (basePoint != null) {\n              addPoint(subPath, [\n                0.5 * (basePoint[0] + cData[0]),\n                0.5 * (basePoint[1] + cData[1]),\n              ]);\n            }\n            addPoint(subPath, [\n              0.5 * (cData[0] + cData[2]),\n              0.5 * (cData[1] + cData[3]),\n            ]);\n            addPoint(subPath, [\n              0.5 * (cData[2] + cData[4]),\n              0.5 * (cData[3] + cData[5]),\n            ]);\n            if (curves.length) addPoint(subPath, (basePoint = cData.slice(-2)));\n          }\n        }\n        break;\n    }\n\n    // Save final command coordinates\n    if (data.length >= 2) addPoint(subPath, data.slice(-2));\n  }\n\n  return points;\n}\n\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @type {(points: Point) => Point}\n */\nfunction convexHull(points) {\n  points.list.sort(function (a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n\n  var lower = [],\n    minY = 0,\n    bottom = 0;\n  for (let i = 0; i < points.list.length; i++) {\n    while (\n      lower.length >= 2 &&\n      cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <=\n        0\n    ) {\n      lower.pop();\n    }\n    if (points.list[i][1] < points.list[minY][1]) {\n      minY = i;\n      bottom = lower.length;\n    }\n    lower.push(points.list[i]);\n  }\n\n  var upper = [],\n    maxY = points.list.length - 1,\n    top = 0;\n  for (let i = points.list.length; i--; ) {\n    while (\n      upper.length >= 2 &&\n      cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <=\n        0\n    ) {\n      upper.pop();\n    }\n    if (points.list[i][1] > points.list[maxY][1]) {\n      maxY = i;\n      top = upper.length;\n    }\n    upper.push(points.list[i]);\n  }\n\n  // last points are equal to starting points of the other part\n  upper.pop();\n  lower.pop();\n\n  const hullList = lower.concat(upper);\n\n  /**\n   * @type {Point}\n   */\n  const hull = {\n    list: hullList,\n    minX: 0, // by sorting\n    maxX: lower.length,\n    minY: bottom,\n    maxY: (lower.length + top) % hullList.length,\n  };\n\n  return hull;\n}\n\n/**\n * @type {(o: Array<number>, a: Array<number>, b: Array<number>) => number}\n */\nfunction cross(o, a, b) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\n/**\n * Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n *\n * @type {(\n *  x1: number,\n *  y1: number,\n *  rx: number,\n *  ry: number,\n *  angle: number,\n *  large_arc_flag: number,\n *  sweep_flag: number,\n *  x2: number,\n *  y2: number,\n *  recursive: Array<number>\n * ) => Array<number>}\n */\nconst a2c = (\n  x1,\n  y1,\n  rx,\n  ry,\n  angle,\n  large_arc_flag,\n  sweep_flag,\n  x2,\n  y2,\n  recursive\n) => {\n  // for more information of where this Math came from visit:\n  // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const _120 = (Math.PI * 120) / 180;\n  const rad = (Math.PI / 180) * (+angle || 0);\n  /**\n   * @type {Array<number>}\n   */\n  let res = [];\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n  const rotateX = (x, y, rad) => {\n    return x * Math.cos(rad) - y * Math.sin(rad);\n  };\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n  const rotateY = (x, y, rad) => {\n    return x * Math.sin(rad) + y * Math.cos(rad);\n  };\n  if (!recursive) {\n    x1 = rotateX(x1, y1, -rad);\n    y1 = rotateY(x1, y1, -rad);\n    x2 = rotateX(x2, y2, -rad);\n    y2 = rotateY(x2, y2, -rad);\n    var x = (x1 - x2) / 2,\n      y = (y1 - y2) / 2;\n    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k =\n      (large_arc_flag == sweep_flag ? -1 : 1) *\n      Math.sqrt(\n        Math.abs(\n          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)\n        )\n      );\n    var cx = (k * rx * y) / ry + (x1 + x2) / 2;\n    var cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n    var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));\n    var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n  var df = f2 - f1;\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n      x2old = x2,\n      y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [\n      f2,\n      f2old,\n      cx,\n      cy,\n    ]);\n  }\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n    s1 = Math.sin(f1),\n    c2 = Math.cos(f2),\n    s2 = Math.sin(f2),\n    t = Math.tan(df / 4),\n    hx = (4 / 3) * rx * t,\n    hy = (4 / 3) * ry * t,\n    m = [\n      -hx * s1,\n      hy * c1,\n      x2 + hx * s2 - x1,\n      y2 - hy * c2 - y1,\n      x2 - x1,\n      y2 - y1,\n    ];\n  if (recursive) {\n    return m.concat(res);\n  } else {\n    res = m.concat(res);\n    var newres = [];\n    for (var i = 0, n = res.length; i < n; i++) {\n      newres[i] =\n        i % 2\n          ? rotateY(res[i - 1], res[i], rad)\n          : rotateX(res[i], res[i + 1], rad);\n    }\n    return newres;\n  }\n};\n"]}}