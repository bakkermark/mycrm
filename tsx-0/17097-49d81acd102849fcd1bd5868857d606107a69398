{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});;(function(sax){sax.parser=function(strict,opt){return new SAXParser(strict,opt)};sax.SAXParser=SAXParser;sax.MAX_BUFFER_LENGTH=64*1024;var buffers=[\"comment\",\"sgmlDecl\",\"textNode\",\"tagName\",\"doctype\",\"procInstName\",\"procInstBody\",\"entity\",\"attribName\",\"attribValue\",\"cdata\",\"script\"];sax.EVENTS=[\"text\",\"processinginstruction\",\"sgmldeclaration\",\"doctype\",\"comment\",\"opentagstart\",\"attribute\",\"opentag\",\"closetag\",\"opencdata\",\"cdata\",\"closecdata\",\"error\",\"end\",\"ready\",\"script\",\"opennamespace\",\"closenamespace\"];function SAXParser(strict,opt){if(!(this instanceof SAXParser)){return new SAXParser(strict,opt)}var parser=this;clearBuffers(parser);parser.q=parser.c=\"\";parser.bufferCheckPosition=sax.MAX_BUFFER_LENGTH;parser.opt=opt||{};parser.opt.lowercase=parser.opt.lowercase||parser.opt.lowercasetags;parser.looseCase=parser.opt.lowercase?\"toLowerCase\":\"toUpperCase\";parser.tags=[];parser.closed=parser.closedRoot=parser.sawRoot=false;parser.tag=parser.error=null;parser.strict=!!strict;parser.noscript=!!(strict||parser.opt.noscript);parser.state=S.BEGIN;parser.strictEntities=parser.opt.strictEntities;parser.ENTITIES=parser.strictEntities?Object.create(sax.XML_ENTITIES):Object.create(sax.ENTITIES);parser.attribList=[];if(parser.opt.xmlns){parser.ns=Object.create(rootNS)}parser.trackPosition=parser.opt.position!==false;if(parser.trackPosition){parser.position=parser.line=parser.column=0}emit(parser,\"onready\")}__name(SAXParser,\"SAXParser\");if(!Object.create){Object.create=function(o){function F(){}__name(F,\"F\");F.prototype=o;var newf=new F;return newf}}if(!Object.keys){Object.keys=function(o){var a=[];for(var i in o)if(o.hasOwnProperty(i))a.push(i);return a}}function checkBufferLength(parser){var maxAllowed=Math.max(sax.MAX_BUFFER_LENGTH,10);var maxActual=0;for(var i=0,l=buffers.length;i<l;i++){var len=parser[buffers[i]].length;if(len>maxAllowed){switch(buffers[i]){case\"textNode\":closeText(parser);break;case\"cdata\":emitNode(parser,\"oncdata\",parser.cdata);parser.cdata=\"\";break;case\"script\":emitNode(parser,\"onscript\",parser.script);parser.script=\"\";break;default:error(parser,\"Max buffer length exceeded: \"+buffers[i])}}maxActual=Math.max(maxActual,len)}var m=sax.MAX_BUFFER_LENGTH-maxActual;parser.bufferCheckPosition=m+parser.position}__name(checkBufferLength,\"checkBufferLength\");function clearBuffers(parser){for(var i=0,l=buffers.length;i<l;i++){parser[buffers[i]]=\"\"}}__name(clearBuffers,\"clearBuffers\");function flushBuffers(parser){closeText(parser);if(parser.cdata!==\"\"){emitNode(parser,\"oncdata\",parser.cdata);parser.cdata=\"\"}if(parser.script!==\"\"){emitNode(parser,\"onscript\",parser.script);parser.script=\"\"}}__name(flushBuffers,\"flushBuffers\");SAXParser.prototype={end:function(){end(this)},write,resume:function(){this.error=null;return this},close:function(){return this.write(null)},flush:function(){flushBuffers(this)}};var CDATA=\"[CDATA[\";var DOCTYPE=\"DOCTYPE\";var XML_NAMESPACE=\"http://www.w3.org/XML/1998/namespace\";var XMLNS_NAMESPACE=\"http://www.w3.org/2000/xmlns/\";var rootNS={xml:XML_NAMESPACE,xmlns:XMLNS_NAMESPACE};var nameStart=/[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;var nameBody=/[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;var entityStart=/[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;var entityBody=/[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;function isWhitespace(c){return c===\" \"||c===\"\\n\"||c===\"\\r\"||c===\"\t\"}__name(isWhitespace,\"isWhitespace\");function isQuote(c){return c==='\"'||c===\"'\"}__name(isQuote,\"isQuote\");function isAttribEnd(c){return c===\">\"||isWhitespace(c)}__name(isAttribEnd,\"isAttribEnd\");function isMatch(regex,c){return regex.test(c)}__name(isMatch,\"isMatch\");function notMatch(regex,c){return!isMatch(regex,c)}__name(notMatch,\"notMatch\");var S=0;sax.STATE={BEGIN:S++,BEGIN_WHITESPACE:S++,TEXT:S++,TEXT_ENTITY:S++,OPEN_WAKA:S++,SGML_DECL:S++,SGML_DECL_QUOTED:S++,DOCTYPE:S++,DOCTYPE_QUOTED:S++,DOCTYPE_DTD:S++,DOCTYPE_DTD_QUOTED:S++,COMMENT_STARTING:S++,COMMENT:S++,COMMENT_ENDING:S++,COMMENT_ENDED:S++,CDATA:S++,CDATA_ENDING:S++,CDATA_ENDING_2:S++,PROC_INST:S++,PROC_INST_BODY:S++,PROC_INST_ENDING:S++,OPEN_TAG:S++,OPEN_TAG_SLASH:S++,ATTRIB:S++,ATTRIB_NAME:S++,ATTRIB_NAME_SAW_WHITE:S++,ATTRIB_VALUE:S++,ATTRIB_VALUE_QUOTED:S++,ATTRIB_VALUE_CLOSED:S++,ATTRIB_VALUE_UNQUOTED:S++,ATTRIB_VALUE_ENTITY_Q:S++,ATTRIB_VALUE_ENTITY_U:S++,CLOSE_TAG:S++,CLOSE_TAG_SAW_WHITE:S++,SCRIPT:S++,SCRIPT_ENDING:S++};sax.XML_ENTITIES={\"amp\":\"&\",\"gt\":\">\",\"lt\":\"<\",\"quot\":'\"',\"apos\":\"'\"};sax.ENTITIES={\"amp\":\"&\",\"gt\":\">\",\"lt\":\"<\",\"quot\":'\"',\"apos\":\"'\",\"AElig\":198,\"Aacute\":193,\"Acirc\":194,\"Agrave\":192,\"Aring\":197,\"Atilde\":195,\"Auml\":196,\"Ccedil\":199,\"ETH\":208,\"Eacute\":201,\"Ecirc\":202,\"Egrave\":200,\"Euml\":203,\"Iacute\":205,\"Icirc\":206,\"Igrave\":204,\"Iuml\":207,\"Ntilde\":209,\"Oacute\":211,\"Ocirc\":212,\"Ograve\":210,\"Oslash\":216,\"Otilde\":213,\"Ouml\":214,\"THORN\":222,\"Uacute\":218,\"Ucirc\":219,\"Ugrave\":217,\"Uuml\":220,\"Yacute\":221,\"aacute\":225,\"acirc\":226,\"aelig\":230,\"agrave\":224,\"aring\":229,\"atilde\":227,\"auml\":228,\"ccedil\":231,\"eacute\":233,\"ecirc\":234,\"egrave\":232,\"eth\":240,\"euml\":235,\"iacute\":237,\"icirc\":238,\"igrave\":236,\"iuml\":239,\"ntilde\":241,\"oacute\":243,\"ocirc\":244,\"ograve\":242,\"oslash\":248,\"otilde\":245,\"ouml\":246,\"szlig\":223,\"thorn\":254,\"uacute\":250,\"ucirc\":251,\"ugrave\":249,\"uuml\":252,\"yacute\":253,\"yuml\":255,\"copy\":169,\"reg\":174,\"nbsp\":160,\"iexcl\":161,\"cent\":162,\"pound\":163,\"curren\":164,\"yen\":165,\"brvbar\":166,\"sect\":167,\"uml\":168,\"ordf\":170,\"laquo\":171,\"not\":172,\"shy\":173,\"macr\":175,\"deg\":176,\"plusmn\":177,\"sup1\":185,\"sup2\":178,\"sup3\":179,\"acute\":180,\"micro\":181,\"para\":182,\"middot\":183,\"cedil\":184,\"ordm\":186,\"raquo\":187,\"frac14\":188,\"frac12\":189,\"frac34\":190,\"iquest\":191,\"times\":215,\"divide\":247,\"OElig\":338,\"oelig\":339,\"Scaron\":352,\"scaron\":353,\"Yuml\":376,\"fnof\":402,\"circ\":710,\"tilde\":732,\"Alpha\":913,\"Beta\":914,\"Gamma\":915,\"Delta\":916,\"Epsilon\":917,\"Zeta\":918,\"Eta\":919,\"Theta\":920,\"Iota\":921,\"Kappa\":922,\"Lambda\":923,\"Mu\":924,\"Nu\":925,\"Xi\":926,\"Omicron\":927,\"Pi\":928,\"Rho\":929,\"Sigma\":931,\"Tau\":932,\"Upsilon\":933,\"Phi\":934,\"Chi\":935,\"Psi\":936,\"Omega\":937,\"alpha\":945,\"beta\":946,\"gamma\":947,\"delta\":948,\"epsilon\":949,\"zeta\":950,\"eta\":951,\"theta\":952,\"iota\":953,\"kappa\":954,\"lambda\":955,\"mu\":956,\"nu\":957,\"xi\":958,\"omicron\":959,\"pi\":960,\"rho\":961,\"sigmaf\":962,\"sigma\":963,\"tau\":964,\"upsilon\":965,\"phi\":966,\"chi\":967,\"psi\":968,\"omega\":969,\"thetasym\":977,\"upsih\":978,\"piv\":982,\"ensp\":8194,\"emsp\":8195,\"thinsp\":8201,\"zwnj\":8204,\"zwj\":8205,\"lrm\":8206,\"rlm\":8207,\"ndash\":8211,\"mdash\":8212,\"lsquo\":8216,\"rsquo\":8217,\"sbquo\":8218,\"ldquo\":8220,\"rdquo\":8221,\"bdquo\":8222,\"dagger\":8224,\"Dagger\":8225,\"bull\":8226,\"hellip\":8230,\"permil\":8240,\"prime\":8242,\"Prime\":8243,\"lsaquo\":8249,\"rsaquo\":8250,\"oline\":8254,\"frasl\":8260,\"euro\":8364,\"image\":8465,\"weierp\":8472,\"real\":8476,\"trade\":8482,\"alefsym\":8501,\"larr\":8592,\"uarr\":8593,\"rarr\":8594,\"darr\":8595,\"harr\":8596,\"crarr\":8629,\"lArr\":8656,\"uArr\":8657,\"rArr\":8658,\"dArr\":8659,\"hArr\":8660,\"forall\":8704,\"part\":8706,\"exist\":8707,\"empty\":8709,\"nabla\":8711,\"isin\":8712,\"notin\":8713,\"ni\":8715,\"prod\":8719,\"sum\":8721,\"minus\":8722,\"lowast\":8727,\"radic\":8730,\"prop\":8733,\"infin\":8734,\"ang\":8736,\"and\":8743,\"or\":8744,\"cap\":8745,\"cup\":8746,\"int\":8747,\"there4\":8756,\"sim\":8764,\"cong\":8773,\"asymp\":8776,\"ne\":8800,\"equiv\":8801,\"le\":8804,\"ge\":8805,\"sub\":8834,\"sup\":8835,\"nsub\":8836,\"sube\":8838,\"supe\":8839,\"oplus\":8853,\"otimes\":8855,\"perp\":8869,\"sdot\":8901,\"lceil\":8968,\"rceil\":8969,\"lfloor\":8970,\"rfloor\":8971,\"lang\":9001,\"rang\":9002,\"loz\":9674,\"spades\":9824,\"clubs\":9827,\"hearts\":9829,\"diams\":9830};Object.keys(sax.ENTITIES).forEach(function(key){var e=sax.ENTITIES[key];var s2=typeof e===\"number\"?String.fromCharCode(e):e;sax.ENTITIES[key]=s2});for(var s in sax.STATE){sax.STATE[sax.STATE[s]]=s}S=sax.STATE;function emit(parser,event,data){parser[event]&&parser[event](data)}__name(emit,\"emit\");function emitNode(parser,nodeType,data){if(parser.textNode)closeText(parser);emit(parser,nodeType,data)}__name(emitNode,\"emitNode\");function closeText(parser){parser.textNode=textopts(parser.opt,parser.textNode);if(parser.textNode)emit(parser,\"ontext\",parser.textNode);parser.textNode=\"\"}__name(closeText,\"closeText\");function textopts(opt,text){if(opt.trim)text=text.trim();if(opt.normalize)text=text.replace(/\\s+/g,\" \");return text}__name(textopts,\"textopts\");function error(parser,reason){closeText(parser);const message=reason+\"\\nLine: \"+parser.line+\"\\nColumn: \"+parser.column+\"\\nChar: \"+parser.c;const error2=new Error(message);error2.reason=reason;error2.line=parser.line;error2.column=parser.column;parser.error=error2;emit(parser,\"onerror\",error2);return parser}__name(error,\"error\");function end(parser){if(parser.sawRoot&&!parser.closedRoot)strictFail(parser,\"Unclosed root tag\");if(parser.state!==S.BEGIN&&parser.state!==S.BEGIN_WHITESPACE&&parser.state!==S.TEXT){error(parser,\"Unexpected end\")}closeText(parser);parser.c=\"\";parser.closed=true;emit(parser,\"onend\");SAXParser.call(parser,parser.strict,parser.opt);return parser}__name(end,\"end\");function strictFail(parser,message){if(typeof parser!==\"object\"||!(parser instanceof SAXParser)){throw new Error(\"bad call to strictFail\")}if(parser.strict){error(parser,message)}}__name(strictFail,\"strictFail\");function newTag(parser){if(!parser.strict)parser.tagName=parser.tagName[parser.looseCase]();var parent=parser.tags[parser.tags.length-1]||parser;var tag=parser.tag={name:parser.tagName,attributes:{}};if(parser.opt.xmlns){tag.ns=parent.ns}parser.attribList.length=0;emitNode(parser,\"onopentagstart\",tag)}__name(newTag,\"newTag\");function qname(name,attribute){var i=name.indexOf(\":\");var qualName=i<0?[\"\",name]:name.split(\":\");var prefix=qualName[0];var local=qualName[1];if(attribute&&name===\"xmlns\"){prefix=\"xmlns\";local=\"\"}return{prefix,local}}__name(qname,\"qname\");function attrib(parser){if(!parser.strict){parser.attribName=parser.attribName[parser.looseCase]()}if(parser.attribList.indexOf(parser.attribName)!==-1||parser.tag.attributes.hasOwnProperty(parser.attribName)){parser.attribName=parser.attribValue=\"\";return}if(parser.opt.xmlns){var qn=qname(parser.attribName,true);var prefix=qn.prefix;var local=qn.local;if(prefix===\"xmlns\"){if(local===\"xml\"&&parser.attribValue!==XML_NAMESPACE){strictFail(parser,\"xml: prefix must be bound to \"+XML_NAMESPACE+\"\\nActual: \"+parser.attribValue)}else if(local===\"xmlns\"&&parser.attribValue!==XMLNS_NAMESPACE){strictFail(parser,\"xmlns: prefix must be bound to \"+XMLNS_NAMESPACE+\"\\nActual: \"+parser.attribValue)}else{var tag=parser.tag;var parent=parser.tags[parser.tags.length-1]||parser;if(tag.ns===parent.ns){tag.ns=Object.create(parent.ns)}tag.ns[local]=parser.attribValue}}parser.attribList.push([parser.attribName,parser.attribValue])}else{parser.tag.attributes[parser.attribName]=parser.attribValue;emitNode(parser,\"onattribute\",{name:parser.attribName,value:parser.attribValue})}parser.attribName=parser.attribValue=\"\"}__name(attrib,\"attrib\");function openTag(parser,selfClosing){if(parser.opt.xmlns){var tag=parser.tag;var qn=qname(parser.tagName);tag.prefix=qn.prefix;tag.local=qn.local;tag.uri=tag.ns[qn.prefix]||\"\";if(tag.prefix&&!tag.uri){strictFail(parser,\"Unbound namespace prefix: \"+JSON.stringify(parser.tagName));tag.uri=qn.prefix}var parent=parser.tags[parser.tags.length-1]||parser;if(tag.ns&&parent.ns!==tag.ns){Object.keys(tag.ns).forEach(function(p){emitNode(parser,\"onopennamespace\",{prefix:p,uri:tag.ns[p]})})}for(var i=0,l=parser.attribList.length;i<l;i++){var nv=parser.attribList[i];var name=nv[0];var value=nv[1];var qualName=qname(name,true);var prefix=qualName.prefix;var local=qualName.local;var uri=prefix===\"\"?\"\":tag.ns[prefix]||\"\";var a={name,value,prefix,local,uri};if(prefix&&prefix!==\"xmlns\"&&!uri){strictFail(parser,\"Unbound namespace prefix: \"+JSON.stringify(prefix));a.uri=prefix}parser.tag.attributes[name]=a;emitNode(parser,\"onattribute\",a)}parser.attribList.length=0}parser.tag.isSelfClosing=!!selfClosing;parser.sawRoot=true;parser.tags.push(parser.tag);emitNode(parser,\"onopentag\",parser.tag);if(!selfClosing){if(!parser.noscript&&parser.tagName.toLowerCase()===\"script\"){parser.state=S.SCRIPT}else{parser.state=S.TEXT}parser.tag=null;parser.tagName=\"\"}parser.attribName=parser.attribValue=\"\";parser.attribList.length=0}__name(openTag,\"openTag\");function closeTag(parser){if(!parser.tagName){strictFail(parser,\"Weird empty close tag.\");parser.textNode+=\"</>\";parser.state=S.TEXT;return}if(parser.script){if(parser.tagName!==\"script\"){parser.script+=\"</\"+parser.tagName+\">\";parser.tagName=\"\";parser.state=S.SCRIPT;return}emitNode(parser,\"onscript\",parser.script);parser.script=\"\"}var t=parser.tags.length;var tagName=parser.tagName;if(!parser.strict){tagName=tagName[parser.looseCase]()}var closeTo=tagName;while(t--){var close=parser.tags[t];if(close.name!==closeTo){strictFail(parser,\"Unexpected close tag\")}else{break}}if(t<0){strictFail(parser,\"Unmatched closing tag: \"+parser.tagName);parser.textNode+=\"</\"+parser.tagName+\">\";parser.state=S.TEXT;return}parser.tagName=tagName;var s2=parser.tags.length;while(s2-- >t){var tag=parser.tag=parser.tags.pop();parser.tagName=parser.tag.name;emitNode(parser,\"onclosetag\",parser.tagName);var x={};for(var i in tag.ns){x[i]=tag.ns[i]}var parent=parser.tags[parser.tags.length-1]||parser;if(parser.opt.xmlns&&tag.ns!==parent.ns){Object.keys(tag.ns).forEach(function(p){var n=tag.ns[p];emitNode(parser,\"onclosenamespace\",{prefix:p,uri:n})})}}if(t===0)parser.closedRoot=true;parser.tagName=parser.attribValue=parser.attribName=\"\";parser.attribList.length=0;parser.state=S.TEXT}__name(closeTag,\"closeTag\");function parseEntity(parser){var entity=parser.entity;var entityLC=entity.toLowerCase();var num;var numStr=\"\";if(parser.ENTITIES[entity]){return parser.ENTITIES[entity]}if(parser.ENTITIES[entityLC]){return parser.ENTITIES[entityLC]}entity=entityLC;if(entity.charAt(0)===\"#\"){if(entity.charAt(1)===\"x\"){entity=entity.slice(2);num=parseInt(entity,16);numStr=num.toString(16)}else{entity=entity.slice(1);num=parseInt(entity,10);numStr=num.toString(10)}}entity=entity.replace(/^0+/,\"\");if(isNaN(num)||numStr.toLowerCase()!==entity){strictFail(parser,\"Invalid character entity\");return\"&\"+parser.entity+\";\"}return String.fromCodePoint(num)}__name(parseEntity,\"parseEntity\");function beginWhiteSpace(parser,c){if(c===\"<\"){parser.state=S.OPEN_WAKA;parser.startTagPosition=parser.position}else if(!isWhitespace(c)){strictFail(parser,\"Non-whitespace before first tag.\");parser.textNode=c;parser.state=S.TEXT}}__name(beginWhiteSpace,\"beginWhiteSpace\");function charAt(chunk,i){var result=\"\";if(i<chunk.length){result=chunk.charAt(i)}return result}__name(charAt,\"charAt\");function write(chunk){var parser=this;if(this.error){throw this.error}if(parser.closed){return error(parser,\"Cannot write after close. Assign an onready handler.\")}if(chunk===null){return end(parser)}if(typeof chunk===\"object\"){chunk=chunk.toString()}var i=0;var c=\"\";while(true){c=charAt(chunk,i++);parser.c=c;if(!c){break}if(parser.trackPosition){parser.position++;if(c===\"\\n\"){parser.line++;parser.column=0}else{parser.column++}}switch(parser.state){case S.BEGIN:parser.state=S.BEGIN_WHITESPACE;if(c===\"\\uFEFF\"){continue}beginWhiteSpace(parser,c);continue;case S.BEGIN_WHITESPACE:beginWhiteSpace(parser,c);continue;case S.TEXT:if(parser.sawRoot&&!parser.closedRoot){var starti=i-1;while(c&&c!==\"<\"&&c!==\"&\"){c=charAt(chunk,i++);if(c&&parser.trackPosition){parser.position++;if(c===\"\\n\"){parser.line++;parser.column=0}else{parser.column++}}}parser.textNode+=chunk.substring(starti,i-1)}if(c===\"<\"&&!(parser.sawRoot&&parser.closedRoot&&!parser.strict)){parser.state=S.OPEN_WAKA;parser.startTagPosition=parser.position}else{if(!isWhitespace(c)&&(!parser.sawRoot||parser.closedRoot)){strictFail(parser,\"Text data outside of root node.\")}if(c===\"&\"){parser.state=S.TEXT_ENTITY}else{parser.textNode+=c}}continue;case S.SCRIPT:if(c===\"<\"){parser.state=S.SCRIPT_ENDING}else{parser.script+=c}continue;case S.SCRIPT_ENDING:if(c===\"/\"){parser.state=S.CLOSE_TAG}else{parser.script+=\"<\"+c;parser.state=S.SCRIPT}continue;case S.OPEN_WAKA:if(c===\"!\"){parser.state=S.SGML_DECL;parser.sgmlDecl=\"\"}else if(isWhitespace(c)){}else if(isMatch(nameStart,c)){parser.state=S.OPEN_TAG;parser.tagName=c}else if(c===\"/\"){parser.state=S.CLOSE_TAG;parser.tagName=\"\"}else if(c===\"?\"){parser.state=S.PROC_INST;parser.procInstName=parser.procInstBody=\"\"}else{strictFail(parser,\"Unencoded <\");if(parser.startTagPosition+1<parser.position){var pad=parser.position-parser.startTagPosition;c=new Array(pad).join(\" \")+c}parser.textNode+=\"<\"+c;parser.state=S.TEXT}continue;case S.SGML_DECL:if((parser.sgmlDecl+c).toUpperCase()===CDATA){emitNode(parser,\"onopencdata\");parser.state=S.CDATA;parser.sgmlDecl=\"\";parser.cdata=\"\"}else if(parser.sgmlDecl+c===\"--\"){parser.state=S.COMMENT;parser.comment=\"\";parser.sgmlDecl=\"\"}else if((parser.sgmlDecl+c).toUpperCase()===DOCTYPE){parser.state=S.DOCTYPE;if(parser.doctype||parser.sawRoot){strictFail(parser,\"Inappropriately located doctype declaration\")}parser.doctype=\"\";parser.sgmlDecl=\"\"}else if(c===\">\"){emitNode(parser,\"onsgmldeclaration\",parser.sgmlDecl);parser.sgmlDecl=\"\";parser.state=S.TEXT}else if(isQuote(c)){parser.state=S.SGML_DECL_QUOTED;parser.sgmlDecl+=c}else{parser.sgmlDecl+=c}continue;case S.SGML_DECL_QUOTED:if(c===parser.q){parser.state=S.SGML_DECL;parser.q=\"\"}parser.sgmlDecl+=c;continue;case S.DOCTYPE:if(c===\">\"){parser.state=S.TEXT;emitNode(parser,\"ondoctype\",parser.doctype);parser.doctype=true}else{parser.doctype+=c;if(c===\"[\"){parser.state=S.DOCTYPE_DTD}else if(isQuote(c)){parser.state=S.DOCTYPE_QUOTED;parser.q=c}}continue;case S.DOCTYPE_QUOTED:parser.doctype+=c;if(c===parser.q){parser.q=\"\";parser.state=S.DOCTYPE}continue;case S.DOCTYPE_DTD:parser.doctype+=c;if(c===\"]\"){parser.state=S.DOCTYPE}else if(isQuote(c)){parser.state=S.DOCTYPE_DTD_QUOTED;parser.q=c}continue;case S.DOCTYPE_DTD_QUOTED:parser.doctype+=c;if(c===parser.q){parser.state=S.DOCTYPE_DTD;parser.q=\"\"}continue;case S.COMMENT:if(c===\"-\"){parser.state=S.COMMENT_ENDING}else{parser.comment+=c}continue;case S.COMMENT_ENDING:if(c===\"-\"){parser.state=S.COMMENT_ENDED;parser.comment=textopts(parser.opt,parser.comment);if(parser.comment){emitNode(parser,\"oncomment\",parser.comment)}parser.comment=\"\"}else{parser.comment+=\"-\"+c;parser.state=S.COMMENT}continue;case S.COMMENT_ENDED:if(c!==\">\"){strictFail(parser,\"Malformed comment\");parser.comment+=\"--\"+c;parser.state=S.COMMENT}else{parser.state=S.TEXT}continue;case S.CDATA:if(c===\"]\"){parser.state=S.CDATA_ENDING}else{parser.cdata+=c}continue;case S.CDATA_ENDING:if(c===\"]\"){parser.state=S.CDATA_ENDING_2}else{parser.cdata+=\"]\"+c;parser.state=S.CDATA}continue;case S.CDATA_ENDING_2:if(c===\">\"){if(parser.cdata){emitNode(parser,\"oncdata\",parser.cdata)}emitNode(parser,\"onclosecdata\");parser.cdata=\"\";parser.state=S.TEXT}else if(c===\"]\"){parser.cdata+=\"]\"}else{parser.cdata+=\"]]\"+c;parser.state=S.CDATA}continue;case S.PROC_INST:if(c===\"?\"){parser.state=S.PROC_INST_ENDING}else if(isWhitespace(c)){parser.state=S.PROC_INST_BODY}else{parser.procInstName+=c}continue;case S.PROC_INST_BODY:if(!parser.procInstBody&&isWhitespace(c)){continue}else if(c===\"?\"){parser.state=S.PROC_INST_ENDING}else{parser.procInstBody+=c}continue;case S.PROC_INST_ENDING:if(c===\">\"){emitNode(parser,\"onprocessinginstruction\",{name:parser.procInstName,body:parser.procInstBody});parser.procInstName=parser.procInstBody=\"\";parser.state=S.TEXT}else{parser.procInstBody+=\"?\"+c;parser.state=S.PROC_INST_BODY}continue;case S.OPEN_TAG:if(isMatch(nameBody,c)){parser.tagName+=c}else{newTag(parser);if(c===\">\"){openTag(parser)}else if(c===\"/\"){parser.state=S.OPEN_TAG_SLASH}else{if(!isWhitespace(c)){strictFail(parser,\"Invalid character in tag name\")}parser.state=S.ATTRIB}}continue;case S.OPEN_TAG_SLASH:if(c===\">\"){openTag(parser,true);closeTag(parser)}else{strictFail(parser,\"Forward-slash in opening tag not followed by >\");parser.state=S.ATTRIB}continue;case S.ATTRIB:if(isWhitespace(c)){continue}else if(c===\">\"){openTag(parser)}else if(c===\"/\"){parser.state=S.OPEN_TAG_SLASH}else if(isMatch(nameStart,c)){parser.attribName=c;parser.attribValue=\"\";parser.state=S.ATTRIB_NAME}else{strictFail(parser,\"Invalid attribute name\")}continue;case S.ATTRIB_NAME:if(c===\"=\"){parser.state=S.ATTRIB_VALUE}else if(c===\">\"){strictFail(parser,\"Attribute without value\");parser.attribValue=parser.attribName;attrib(parser);openTag(parser)}else if(isWhitespace(c)){parser.state=S.ATTRIB_NAME_SAW_WHITE}else if(isMatch(nameBody,c)){parser.attribName+=c}else{strictFail(parser,\"Invalid attribute name\")}continue;case S.ATTRIB_NAME_SAW_WHITE:if(c===\"=\"){parser.state=S.ATTRIB_VALUE}else if(isWhitespace(c)){continue}else{strictFail(parser,\"Attribute without value\");parser.tag.attributes[parser.attribName]=\"\";parser.attribValue=\"\";emitNode(parser,\"onattribute\",{name:parser.attribName,value:\"\"});parser.attribName=\"\";if(c===\">\"){openTag(parser)}else if(isMatch(nameStart,c)){parser.attribName=c;parser.state=S.ATTRIB_NAME}else{strictFail(parser,\"Invalid attribute name\");parser.state=S.ATTRIB}}continue;case S.ATTRIB_VALUE:if(isWhitespace(c)){continue}else if(isQuote(c)){parser.q=c;parser.state=S.ATTRIB_VALUE_QUOTED}else{strictFail(parser,\"Unquoted attribute value\");parser.state=S.ATTRIB_VALUE_UNQUOTED;parser.attribValue=c}continue;case S.ATTRIB_VALUE_QUOTED:if(c!==parser.q){if(c===\"&\"){parser.state=S.ATTRIB_VALUE_ENTITY_Q}else{parser.attribValue+=c}continue}attrib(parser);parser.q=\"\";parser.state=S.ATTRIB_VALUE_CLOSED;continue;case S.ATTRIB_VALUE_CLOSED:if(isWhitespace(c)){parser.state=S.ATTRIB}else if(c===\">\"){openTag(parser)}else if(c===\"/\"){parser.state=S.OPEN_TAG_SLASH}else if(isMatch(nameStart,c)){strictFail(parser,\"No whitespace between attributes\");parser.attribName=c;parser.attribValue=\"\";parser.state=S.ATTRIB_NAME}else{strictFail(parser,\"Invalid attribute name\")}continue;case S.ATTRIB_VALUE_UNQUOTED:if(!isAttribEnd(c)){if(c===\"&\"){parser.state=S.ATTRIB_VALUE_ENTITY_U}else{parser.attribValue+=c}continue}attrib(parser);if(c===\">\"){openTag(parser)}else{parser.state=S.ATTRIB}continue;case S.CLOSE_TAG:if(!parser.tagName){if(isWhitespace(c)){continue}else if(notMatch(nameStart,c)){if(parser.script){parser.script+=\"</\"+c;parser.state=S.SCRIPT}else{strictFail(parser,\"Invalid tagname in closing tag.\")}}else{parser.tagName=c}}else if(c===\">\"){closeTag(parser)}else if(isMatch(nameBody,c)){parser.tagName+=c}else if(parser.script){parser.script+=\"</\"+parser.tagName;parser.tagName=\"\";parser.state=S.SCRIPT}else{if(!isWhitespace(c)){strictFail(parser,\"Invalid tagname in closing tag\")}parser.state=S.CLOSE_TAG_SAW_WHITE}continue;case S.CLOSE_TAG_SAW_WHITE:if(isWhitespace(c)){continue}if(c===\">\"){closeTag(parser)}else{strictFail(parser,\"Invalid characters in closing tag\")}continue;case S.TEXT_ENTITY:case S.ATTRIB_VALUE_ENTITY_Q:case S.ATTRIB_VALUE_ENTITY_U:var returnState;var buffer;switch(parser.state){case S.TEXT_ENTITY:returnState=S.TEXT;buffer=\"textNode\";break;case S.ATTRIB_VALUE_ENTITY_Q:returnState=S.ATTRIB_VALUE_QUOTED;buffer=\"attribValue\";break;case S.ATTRIB_VALUE_ENTITY_U:returnState=S.ATTRIB_VALUE_UNQUOTED;buffer=\"attribValue\";break}if(c===\";\"){var parsedEntity=parseEntity(parser);if(parser.state===S.TEXT_ENTITY&&!sax.ENTITIES[parser.entity]&&parsedEntity!==\"&\"+parser.entity+\";\"){chunk=chunk.slice(0,i)+parsedEntity+chunk.slice(i)}else{parser[buffer]+=parsedEntity}parser.entity=\"\";parser.state=returnState}else if(isMatch(parser.entity.length?entityBody:entityStart,c)){parser.entity+=c}else{strictFail(parser,\"Invalid character in entity name\");parser[buffer]+=\"&\"+parser.entity+c;parser.entity=\"\";parser.state=returnState}continue;default:throw new Error(parser,\"Unknown state: \"+parser.state)}}if(parser.position>=parser.bufferCheckPosition){checkBufferLength(parser)}return parser}__name(write,\"write\")})(typeof exports===\"undefined\"?exports.sax={}:exports);\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["s","error"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/@trysound+sax@0.2.0/node_modules/@trysound/sax/lib/sax.js"],"sourcesContent":[";(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'opentagstart',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  function isWhitespace (c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n  }\n\n  function isQuote (c) {\n    return c === '\"' || c === '\\''\n  }\n\n  function isAttribEnd (c) {\n    return c === '>' || isWhitespace(c)\n  }\n\n  function isMatch (regex, c) {\n    return regex.test(c)\n  }\n\n  function notMatch (regex, c) {\n    return !isMatch(regex, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, reason) {\n    closeText(parser)\n    const message = reason +\n      '\\nLine: ' + parser.line +\n      '\\nColumn: ' + parser.column +\n      '\\nChar: ' + parser.c\n    const error = new Error(message)\n    error.reason = reason\n    error.line = parser.line\n    error.column = parser.column\n    parser.error = error\n    emit(parser, 'onerror', error)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n    emitNode(parser, 'onopentagstart', tag)\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function charAt (chunk, i) {\n    var result = ''\n    if (i < chunk.length) {\n      result = chunk.charAt(i)\n    }\n    return result\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    if (typeof chunk === 'object') {\n      chunk = chunk.toString()\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = charAt(chunk, i++)\n      parser.c = c\n\n      if (!c) {\n        break\n      }\n\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (isWhitespace(c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue\n          } else if (isQuote(c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            var parsedEntity = parseEntity(parser)\n\n            // Custom entities can contain tags, so we potentially need to parse the result\n            if (parser.state === S.TEXT_ENTITY && !sax.ENTITIES[parser.entity] && parsedEntity !== '&' + parser.entity + ';') {\n              chunk = chunk.slice(0, i) + parsedEntity + chunk.slice(i)\n            } else {\n              parser[buffer] += parsedEntity\n            }\n\n            parser.entity = ''\n            parser.state = returnState\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n"]}}