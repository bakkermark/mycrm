{"code":"(()=>{\n\"use strict\";const{visit,visitSkip,detachNodeFromParent}=require(\"../lib/xast.js\");const{collectStylesheet,computeStyle}=require(\"../lib/style.js\");const{hasScripts}=require(\"../lib/svgo/tools.js\");const{elemsGroups}=require(\"./_collections.js\");exports.name=\"removeUselessStrokeAndFill\";exports.description=\"removes useless stroke and fill attributes\";exports.fn=(root,params)=>{const{stroke:removeStroke=true,fill:removeFill=true,removeNone=false}=params;let hasStyleOrScript=false;visit(root,{element:{enter:node=>{if(node.name===\"style\"||hasScripts(node)){hasStyleOrScript=true}}}});if(hasStyleOrScript){return null}const stylesheet=collectStylesheet(root);return{element:{enter:(node,parentNode)=>{if(node.attributes.id!=null){return visitSkip}if(elemsGroups.shape.includes(node.name)==false){return}const computedStyle=computeStyle(stylesheet,node);const stroke=computedStyle.stroke;const strokeOpacity=computedStyle[\"stroke-opacity\"];const strokeWidth=computedStyle[\"stroke-width\"];const markerEnd=computedStyle[\"marker-end\"];const fill=computedStyle.fill;const fillOpacity=computedStyle[\"fill-opacity\"];const computedParentStyle=parentNode.type===\"element\"?computeStyle(stylesheet,parentNode):null;const parentStroke=computedParentStyle==null?null:computedParentStyle.stroke;if(removeStroke){if(stroke==null||stroke.type===\"static\"&&stroke.value==\"none\"||strokeOpacity!=null&&strokeOpacity.type===\"static\"&&strokeOpacity.value===\"0\"||strokeWidth!=null&&strokeWidth.type===\"static\"&&strokeWidth.value===\"0\"){if(strokeWidth!=null&&strokeWidth.type===\"static\"&&strokeWidth.value===\"0\"||markerEnd==null){for(const name of Object.keys(node.attributes)){if(name.startsWith(\"stroke\")){delete node.attributes[name]}}if(parentStroke!=null&&parentStroke.type===\"static\"&&parentStroke.value!==\"none\"){node.attributes.stroke=\"none\"}}}}if(removeFill){if(fill!=null&&fill.type===\"static\"&&fill.value===\"none\"||fillOpacity!=null&&fillOpacity.type===\"static\"&&fillOpacity.value===\"0\"){for(const name of Object.keys(node.attributes)){if(name.startsWith(\"fill-\")){delete node.attributes[name]}}if(fill==null||fill.type===\"static\"&&fill.value!==\"none\"){node.attributes.fill=\"none\"}}}if(removeNone){if((stroke==null||node.attributes.stroke===\"none\")&&(fill!=null&&fill.type===\"static\"&&fill.value===\"none\"||node.attributes.fill===\"none\")){detachNodeFromParent(node,parentNode)}}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":";aAEA,KAAM,CAAE,MAAO,UAAW,oBAAqB,EAAI,QAAQ,gBAAgB,EAC3E,KAAM,CAAE,kBAAmB,YAAa,EAAI,QAAQ,iBAAiB,EACrE,KAAM,CAAE,UAAW,EAAI,QAAQ,sBAAsB,EACrD,KAAM,CAAE,WAAY,EAAI,QAAQ,mBAAmB,EAEnD,QAAQ,KAAO,6BACf,QAAQ,YAAc,6CAStB,QAAQ,GAAK,CAAC,KAAM,SAAW,CAC7B,KAAM,CACJ,OAAQ,aAAe,KACvB,KAAM,WAAa,KACnB,WAAa,KACf,EAAI,OAGJ,IAAI,iBAAmB,MACvB,MAAM,KAAM,CACV,QAAS,CACP,MAAQ,MAAS,CACf,GAAI,KAAK,OAAS,SAAW,WAAW,IAAI,EAAG,CAC7C,iBAAmB,IACrB,CACF,CACF,CACF,CAAC,EACD,GAAI,iBAAkB,CACpB,OAAO,IACT,CAEA,MAAM,WAAa,kBAAkB,IAAI,EAEzC,MAAO,CACL,QAAS,CACP,MAAO,CAAC,KAAM,aAAe,CAE3B,GAAI,KAAK,WAAW,IAAM,KAAM,CAC9B,OAAO,SACT,CACA,GAAI,YAAY,MAAM,SAAS,KAAK,IAAI,GAAK,MAAO,CAClD,MACF,CACA,MAAM,cAAgB,aAAa,WAAY,IAAI,EACnD,MAAM,OAAS,cAAc,OAC7B,MAAM,cAAgB,cAAc,gBAAgB,EACpD,MAAM,YAAc,cAAc,cAAc,EAChD,MAAM,UAAY,cAAc,YAAY,EAC5C,MAAM,KAAO,cAAc,KAC3B,MAAM,YAAc,cAAc,cAAc,EAChD,MAAM,oBACJ,WAAW,OAAS,UAChB,aAAa,WAAY,UAAU,EACnC,KACN,MAAM,aACJ,qBAAuB,KAAO,KAAO,oBAAoB,OAG3D,GAAI,aAAc,CAChB,GACE,QAAU,MACT,OAAO,OAAS,UAAY,OAAO,OAAS,QAC5C,eAAiB,MAChB,cAAc,OAAS,UACvB,cAAc,QAAU,KACzB,aAAe,MACd,YAAY,OAAS,UACrB,YAAY,QAAU,IACxB,CAGA,GACG,aAAe,MACd,YAAY,OAAS,UACrB,YAAY,QAAU,KACxB,WAAa,KACb,CACA,UAAW,QAAQ,OAAO,KAAK,KAAK,UAAU,EAAG,CAC/C,GAAI,KAAK,WAAW,QAAQ,EAAG,CAC7B,OAAO,KAAK,WAAW,IAAI,CAC7B,CACF,CAEA,GACE,cAAgB,MAChB,aAAa,OAAS,UACtB,aAAa,QAAU,OACvB,CACA,KAAK,WAAW,OAAS,MAC3B,CACF,CACF,CACF,CAGA,GAAI,WAAY,CACd,GACG,MAAQ,MAAQ,KAAK,OAAS,UAAY,KAAK,QAAU,QACzD,aAAe,MACd,YAAY,OAAS,UACrB,YAAY,QAAU,IACxB,CACA,UAAW,QAAQ,OAAO,KAAK,KAAK,UAAU,EAAG,CAC/C,GAAI,KAAK,WAAW,OAAO,EAAG,CAC5B,OAAO,KAAK,WAAW,IAAI,CAC7B,CACF,CACA,GACE,MAAQ,MACP,KAAK,OAAS,UAAY,KAAK,QAAU,OAC1C,CACA,KAAK,WAAW,KAAO,MACzB,CACF,CACF,CAEA,GAAI,WAAY,CACd,IACG,QAAU,MAAQ,KAAK,WAAW,SAAW,UAC5C,MAAQ,MACR,KAAK,OAAS,UACd,KAAK,QAAU,QACf,KAAK,WAAW,OAAS,QAC3B,CACA,qBAAqB,KAAM,UAAU,CACvC,CACF,CACF,CACF,CACF,CACF","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/removeUselessStrokeAndFill.js"],"sourcesContent":["'use strict';\n\nconst { visit, visitSkip, detachNodeFromParent } = require('../lib/xast.js');\nconst { collectStylesheet, computeStyle } = require('../lib/style.js');\nconst { hasScripts } = require('../lib/svgo/tools.js');\nconst { elemsGroups } = require('./_collections.js');\n\nexports.name = 'removeUselessStrokeAndFill';\nexports.description = 'removes useless stroke and fill attributes';\n\n/**\n * Remove useless stroke and fill attrs.\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'removeUselessStrokeAndFill'>}\n */\nexports.fn = (root, params) => {\n  const {\n    stroke: removeStroke = true,\n    fill: removeFill = true,\n    removeNone = false,\n  } = params;\n\n  // style and script elements deoptimise this plugin\n  let hasStyleOrScript = false;\n  visit(root, {\n    element: {\n      enter: (node) => {\n        if (node.name === 'style' || hasScripts(node)) {\n          hasStyleOrScript = true;\n        }\n      },\n    },\n  });\n  if (hasStyleOrScript) {\n    return null;\n  }\n\n  const stylesheet = collectStylesheet(root);\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // id attribute deoptimise the whole subtree\n        if (node.attributes.id != null) {\n          return visitSkip;\n        }\n        if (elemsGroups.shape.includes(node.name) == false) {\n          return;\n        }\n        const computedStyle = computeStyle(stylesheet, node);\n        const stroke = computedStyle.stroke;\n        const strokeOpacity = computedStyle['stroke-opacity'];\n        const strokeWidth = computedStyle['stroke-width'];\n        const markerEnd = computedStyle['marker-end'];\n        const fill = computedStyle.fill;\n        const fillOpacity = computedStyle['fill-opacity'];\n        const computedParentStyle =\n          parentNode.type === 'element'\n            ? computeStyle(stylesheet, parentNode)\n            : null;\n        const parentStroke =\n          computedParentStyle == null ? null : computedParentStyle.stroke;\n\n        // remove stroke*\n        if (removeStroke) {\n          if (\n            stroke == null ||\n            (stroke.type === 'static' && stroke.value == 'none') ||\n            (strokeOpacity != null &&\n              strokeOpacity.type === 'static' &&\n              strokeOpacity.value === '0') ||\n            (strokeWidth != null &&\n              strokeWidth.type === 'static' &&\n              strokeWidth.value === '0')\n          ) {\n            // stroke-width may affect the size of marker-end\n            // marker is not visible when stroke-width is 0\n            if (\n              (strokeWidth != null &&\n                strokeWidth.type === 'static' &&\n                strokeWidth.value === '0') ||\n              markerEnd == null\n            ) {\n              for (const name of Object.keys(node.attributes)) {\n                if (name.startsWith('stroke')) {\n                  delete node.attributes[name];\n                }\n              }\n              // set explicit none to not inherit from parent\n              if (\n                parentStroke != null &&\n                parentStroke.type === 'static' &&\n                parentStroke.value !== 'none'\n              ) {\n                node.attributes.stroke = 'none';\n              }\n            }\n          }\n        }\n\n        // remove fill*\n        if (removeFill) {\n          if (\n            (fill != null && fill.type === 'static' && fill.value === 'none') ||\n            (fillOpacity != null &&\n              fillOpacity.type === 'static' &&\n              fillOpacity.value === '0')\n          ) {\n            for (const name of Object.keys(node.attributes)) {\n              if (name.startsWith('fill-')) {\n                delete node.attributes[name];\n              }\n            }\n            if (\n              fill == null ||\n              (fill.type === 'static' && fill.value !== 'none')\n            ) {\n              node.attributes.fill = 'none';\n            }\n          }\n        }\n\n        if (removeNone) {\n          if (\n            (stroke == null || node.attributes.stroke === 'none') &&\n            ((fill != null &&\n              fill.type === 'static' &&\n              fill.value === 'none') ||\n              node.attributes.fill === 'none')\n          ) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      },\n    },\n  };\n};\n"]}}