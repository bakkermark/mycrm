{"code":"(()=>{\n\"use strict\";const{collectStylesheet}=require(\"../lib/style\");const{detachNodeFromParent,querySelectorAll}=require(\"../lib/xast\");exports.name=\"reusePaths\";exports.description=\"Finds <path> elements with the same d, fill, and stroke, and converts them to <use> elements referencing a single <path> def.\";exports.fn=root=>{const stylesheet=collectStylesheet(root);const paths=new Map;let svgDefs;const hrefs=new Set;return{element:{enter:(node,parentNode)=>{if(node.name===\"path\"&&node.attributes.d!=null){const d=node.attributes.d;const fill=node.attributes.fill||\"\";const stroke=node.attributes.stroke||\"\";const key=d+\";s:\"+stroke+\";f:\"+fill;let list=paths.get(key);if(list==null){list=[];paths.set(key,list)}list.push(node)}if(svgDefs==null&&node.name===\"defs\"&&parentNode.type===\"element\"&&parentNode.name===\"svg\"){svgDefs=node}if(node.name===\"use\"){for(const name of[\"href\",\"xlink:href\"]){const href=node.attributes[name];if(href!=null&&href.startsWith(\"#\")&&href.length>1){hrefs.add(href.slice(1))}}}},exit:(node,parentNode)=>{if(node.name===\"svg\"&&parentNode.type===\"root\"){let defsTag=svgDefs;if(defsTag==null){defsTag={type:\"element\",name:\"defs\",attributes:{},children:[]};Object.defineProperty(defsTag,\"parentNode\",{writable:true,value:node})}let index=0;for(const list of paths.values()){if(list.length>1){const reusablePath={type:\"element\",name:\"path\",attributes:{},children:[]};for(const attr of[\"fill\",\"stroke\",\"d\"]){if(list[0].attributes[attr]!=null){reusablePath.attributes[attr]=list[0].attributes[attr]}}const originalId=list[0].attributes.id;if(originalId==null||hrefs.has(originalId)||stylesheet.rules.some(rule=>rule.selector===`#${originalId}`)){reusablePath.attributes.id=\"reuse-\"+index++}else{reusablePath.attributes.id=originalId;delete list[0].attributes.id}Object.defineProperty(reusablePath,\"parentNode\",{writable:true,value:defsTag});defsTag.children.push(reusablePath);for(const pathNode of list){delete pathNode.attributes.d;delete pathNode.attributes.stroke;delete pathNode.attributes.fill;if(defsTag.children.includes(pathNode)&&pathNode.children.length===0){if(Object.keys(pathNode.attributes).length===0){detachNodeFromParent(pathNode,defsTag);continue}if(Object.keys(pathNode.attributes).length===1&&pathNode.attributes.id!=null){detachNodeFromParent(pathNode,defsTag);const selector=`[xlink\\\\:href=#${pathNode.attributes.id}], [href=#${pathNode.attributes.id}]`;for(const child of querySelectorAll(node,selector)){if(child.type!==\"element\"){continue}for(const name of[\"href\",\"xlink:href\"]){if(child.attributes[name]!=null){child.attributes[name]=\"#\"+reusablePath.attributes.id}}}continue}}pathNode.name=\"use\";pathNode.attributes[\"xlink:href\"]=\"#\"+reusablePath.attributes.id}}}if(defsTag.children.length!==0){if(node.attributes[\"xmlns:xlink\"]==null){node.attributes[\"xmlns:xlink\"]=\"http://www.w3.org/1999/xlink\"}if(svgDefs==null){node.children.unshift(defsTag)}}}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/reusePaths.js"],"sourcesContent":["'use strict';\n\nconst { collectStylesheet } = require('../lib/style');\nconst { detachNodeFromParent, querySelectorAll } = require('../lib/xast');\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n * @typedef {import('../lib/types').XastNode} XastNode\n */\n\nexports.name = 'reusePaths';\nexports.description =\n  'Finds <path> elements with the same d, fill, and ' +\n  'stroke, and converts them to <use> elements ' +\n  'referencing a single <path> def.';\n\n/**\n * Finds <path> elements with the same d, fill, and stroke, and converts them to\n * <use> elements referencing a single <path> def.\n *\n * @author Jacob Howcroft\n *\n * @type {import('./plugins-types').Plugin<'reusePaths'>}\n */\nexports.fn = (root) => {\n  const stylesheet = collectStylesheet(root);\n\n  /**\n   * @type {Map<string, Array<XastElement>>}\n   */\n  const paths = new Map();\n\n  /**\n   * Reference to the first defs element that is a direct child of the svg\n   * element if one exists.\n   *\n   * @type {XastElement}\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs\n   */\n  let svgDefs;\n\n  /**\n   * Set of hrefs that reference the id of another node.\n   *\n   * @type {Set<string>}\n   */\n  const hrefs = new Set();\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.name === 'path' && node.attributes.d != null) {\n          const d = node.attributes.d;\n          const fill = node.attributes.fill || '';\n          const stroke = node.attributes.stroke || '';\n          const key = d + ';s:' + stroke + ';f:' + fill;\n          let list = paths.get(key);\n          if (list == null) {\n            list = [];\n            paths.set(key, list);\n          }\n          list.push(node);\n        }\n\n        if (\n          svgDefs == null &&\n          node.name === 'defs' &&\n          parentNode.type === 'element' &&\n          parentNode.name === 'svg'\n        ) {\n          svgDefs = node;\n        }\n\n        if (node.name === 'use') {\n          for (const name of ['href', 'xlink:href']) {\n            const href = node.attributes[name];\n\n            if (href != null && href.startsWith('#') && href.length > 1) {\n              hrefs.add(href.slice(1));\n            }\n          }\n        }\n      },\n\n      exit: (node, parentNode) => {\n        if (node.name === 'svg' && parentNode.type === 'root') {\n          let defsTag = svgDefs;\n\n          if (defsTag == null) {\n            defsTag = {\n              type: 'element',\n              name: 'defs',\n              attributes: {},\n              children: [],\n            };\n            // TODO remove legacy parentNode in v4\n            Object.defineProperty(defsTag, 'parentNode', {\n              writable: true,\n              value: node,\n            });\n          }\n\n          let index = 0;\n          for (const list of paths.values()) {\n            if (list.length > 1) {\n              /** @type {XastElement} */\n              const reusablePath = {\n                type: 'element',\n                name: 'path',\n                attributes: {},\n                children: [],\n              };\n\n              for (const attr of ['fill', 'stroke', 'd']) {\n                if (list[0].attributes[attr] != null) {\n                  reusablePath.attributes[attr] = list[0].attributes[attr];\n                }\n              }\n\n              const originalId = list[0].attributes.id;\n              if (\n                originalId == null ||\n                hrefs.has(originalId) ||\n                stylesheet.rules.some(\n                  (rule) => rule.selector === `#${originalId}`\n                )\n              ) {\n                reusablePath.attributes.id = 'reuse-' + index++;\n              } else {\n                reusablePath.attributes.id = originalId;\n                delete list[0].attributes.id;\n              }\n              // TODO remove legacy parentNode in v4\n              Object.defineProperty(reusablePath, 'parentNode', {\n                writable: true,\n                value: defsTag,\n              });\n              defsTag.children.push(reusablePath);\n              // convert paths to <use>\n              for (const pathNode of list) {\n                delete pathNode.attributes.d;\n                delete pathNode.attributes.stroke;\n                delete pathNode.attributes.fill;\n\n                if (\n                  defsTag.children.includes(pathNode) &&\n                  pathNode.children.length === 0\n                ) {\n                  if (Object.keys(pathNode.attributes).length === 0) {\n                    detachNodeFromParent(pathNode, defsTag);\n                    continue;\n                  }\n\n                  if (\n                    Object.keys(pathNode.attributes).length === 1 &&\n                    pathNode.attributes.id != null\n                  ) {\n                    detachNodeFromParent(pathNode, defsTag);\n                    const selector = `[xlink\\\\:href=#${pathNode.attributes.id}], [href=#${pathNode.attributes.id}]`;\n                    for (const child of querySelectorAll(node, selector)) {\n                      if (child.type !== 'element') {\n                        continue;\n                      }\n                      for (const name of ['href', 'xlink:href']) {\n                        if (child.attributes[name] != null) {\n                          child.attributes[name] =\n                            '#' + reusablePath.attributes.id;\n                        }\n                      }\n                    }\n                    continue;\n                  }\n                }\n\n                pathNode.name = 'use';\n                pathNode.attributes['xlink:href'] =\n                  '#' + reusablePath.attributes.id;\n              }\n            }\n          }\n          if (defsTag.children.length !== 0) {\n            if (node.attributes['xmlns:xlink'] == null) {\n              node.attributes['xmlns:xlink'] = 'http://www.w3.org/1999/xlink';\n            }\n\n            if (svgDefs == null) {\n              node.children.unshift(defsTag);\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"]}}