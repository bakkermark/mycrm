{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const proc=typeof process===\"object\"&&process?process:{stdout:null,stderr:null};const EE=require(\"events\");const Stream=require(\"stream\");const SD=require(\"string_decoder\").StringDecoder;const EOF=Symbol(\"EOF\");const MAYBE_EMIT_END=Symbol(\"maybeEmitEnd\");const EMITTED_END=Symbol(\"emittedEnd\");const EMITTING_END=Symbol(\"emittingEnd\");const EMITTED_ERROR=Symbol(\"emittedError\");const CLOSED=Symbol(\"closed\");const READ=Symbol(\"read\");const FLUSH=Symbol(\"flush\");const FLUSHCHUNK=Symbol(\"flushChunk\");const ENCODING=Symbol(\"encoding\");const DECODER=Symbol(\"decoder\");const FLOWING=Symbol(\"flowing\");const PAUSED=Symbol(\"paused\");const RESUME=Symbol(\"resume\");const BUFFERLENGTH=Symbol(\"bufferLength\");const BUFFERPUSH=Symbol(\"bufferPush\");const BUFFERSHIFT=Symbol(\"bufferShift\");const OBJECTMODE=Symbol(\"objectMode\");const DESTROYED=Symbol(\"destroyed\");const EMITDATA=Symbol(\"emitData\");const EMITEND=Symbol(\"emitEnd\");const EMITEND2=Symbol(\"emitEnd2\");const ASYNC=Symbol(\"async\");const defer=__name(fn=>Promise.resolve().then(fn),\"defer\");const doIter=global._MP_NO_ITERATOR_SYMBOLS_!==\"1\";const ASYNCITERATOR=doIter&&Symbol.asyncIterator||Symbol(\"asyncIterator not implemented\");const ITERATOR=doIter&&Symbol.iterator||Symbol(\"iterator not implemented\");const isEndish=__name(ev=>ev===\"end\"||ev===\"finish\"||ev===\"prefinish\",\"isEndish\");const isArrayBuffer=__name(b=>b instanceof ArrayBuffer||typeof b===\"object\"&&b.constructor&&b.constructor.name===\"ArrayBuffer\"&&b.byteLength>=0,\"isArrayBuffer\");const isArrayBufferView=__name(b=>!Buffer.isBuffer(b)&&ArrayBuffer.isView(b),\"isArrayBufferView\");class Pipe{static{__name(this,\"Pipe\")}constructor(src,dest,opts){this.src=src;this.dest=dest;this.opts=opts;this.ondrain=()=>src[RESUME]();dest.on(\"drain\",this.ondrain)}unpipe(){this.dest.removeListener(\"drain\",this.ondrain)}proxyErrors(){}end(){this.unpipe();if(this.opts.end)this.dest.end()}}class PipeProxyErrors extends Pipe{static{__name(this,\"PipeProxyErrors\")}unpipe(){this.src.removeListener(\"error\",this.proxyErrors);super.unpipe()}constructor(src,dest,opts){super(src,dest,opts);this.proxyErrors=er=>dest.emit(\"error\",er);src.on(\"error\",this.proxyErrors)}}module.exports=class Minipass extends Stream{static{__name(this,\"Minipass\")}constructor(options){super();this[FLOWING]=false;this[PAUSED]=false;this.pipes=[];this.buffer=[];this[OBJECTMODE]=options&&options.objectMode||false;if(this[OBJECTMODE])this[ENCODING]=null;else this[ENCODING]=options&&options.encoding||null;if(this[ENCODING]===\"buffer\")this[ENCODING]=null;this[ASYNC]=options&&!!options.async||false;this[DECODER]=this[ENCODING]?new SD(this[ENCODING]):null;this[EOF]=false;this[EMITTED_END]=false;this[EMITTING_END]=false;this[CLOSED]=false;this[EMITTED_ERROR]=null;this.writable=true;this.readable=true;this[BUFFERLENGTH]=0;this[DESTROYED]=false}get bufferLength(){return this[BUFFERLENGTH]}get encoding(){return this[ENCODING]}set encoding(enc){if(this[OBJECTMODE])throw new Error(\"cannot set encoding in objectMode\");if(this[ENCODING]&&enc!==this[ENCODING]&&(this[DECODER]&&this[DECODER].lastNeed||this[BUFFERLENGTH]))throw new Error(\"cannot change encoding\");if(this[ENCODING]!==enc){this[DECODER]=enc?new SD(enc):null;if(this.buffer.length)this.buffer=this.buffer.map(chunk=>this[DECODER].write(chunk))}this[ENCODING]=enc}setEncoding(enc){this.encoding=enc}get objectMode(){return this[OBJECTMODE]}set objectMode(om){this[OBJECTMODE]=this[OBJECTMODE]||!!om}get[\"async\"](){return this[ASYNC]}set[\"async\"](a){this[ASYNC]=this[ASYNC]||!!a}write(chunk,encoding,cb){if(this[EOF])throw new Error(\"write after end\");if(this[DESTROYED]){this.emit(\"error\",Object.assign(new Error(\"Cannot call write after a stream was destroyed\"),{code:\"ERR_STREAM_DESTROYED\"}));return true}if(typeof encoding===\"function\")cb=encoding,encoding=\"utf8\";if(!encoding)encoding=\"utf8\";const fn=this[ASYNC]?defer:f=>f();if(!this[OBJECTMODE]&&!Buffer.isBuffer(chunk)){if(isArrayBufferView(chunk))chunk=Buffer.from(chunk.buffer,chunk.byteOffset,chunk.byteLength);else if(isArrayBuffer(chunk))chunk=Buffer.from(chunk);else if(typeof chunk!==\"string\")this.objectMode=true}if(this[OBJECTMODE]){if(this.flowing&&this[BUFFERLENGTH]!==0)this[FLUSH](true);if(this.flowing)this.emit(\"data\",chunk);else this[BUFFERPUSH](chunk);if(this[BUFFERLENGTH]!==0)this.emit(\"readable\");if(cb)fn(cb);return this.flowing}if(!chunk.length){if(this[BUFFERLENGTH]!==0)this.emit(\"readable\");if(cb)fn(cb);return this.flowing}if(typeof chunk===\"string\"&&!(encoding===this[ENCODING]&&!this[DECODER].lastNeed)){chunk=Buffer.from(chunk,encoding)}if(Buffer.isBuffer(chunk)&&this[ENCODING])chunk=this[DECODER].write(chunk);if(this.flowing&&this[BUFFERLENGTH]!==0)this[FLUSH](true);if(this.flowing)this.emit(\"data\",chunk);else this[BUFFERPUSH](chunk);if(this[BUFFERLENGTH]!==0)this.emit(\"readable\");if(cb)fn(cb);return this.flowing}read(n){if(this[DESTROYED])return null;if(this[BUFFERLENGTH]===0||n===0||n>this[BUFFERLENGTH]){this[MAYBE_EMIT_END]();return null}if(this[OBJECTMODE])n=null;if(this.buffer.length>1&&!this[OBJECTMODE]){if(this.encoding)this.buffer=[this.buffer.join(\"\")];else this.buffer=[Buffer.concat(this.buffer,this[BUFFERLENGTH])]}const ret=this[READ](n||null,this.buffer[0]);this[MAYBE_EMIT_END]();return ret}[READ](n,chunk){if(n===chunk.length||n===null)this[BUFFERSHIFT]();else{this.buffer[0]=chunk.slice(n);chunk=chunk.slice(0,n);this[BUFFERLENGTH]-=n}this.emit(\"data\",chunk);if(!this.buffer.length&&!this[EOF])this.emit(\"drain\");return chunk}end(chunk,encoding,cb){if(typeof chunk===\"function\")cb=chunk,chunk=null;if(typeof encoding===\"function\")cb=encoding,encoding=\"utf8\";if(chunk)this.write(chunk,encoding);if(cb)this.once(\"end\",cb);this[EOF]=true;this.writable=false;if(this.flowing||!this[PAUSED])this[MAYBE_EMIT_END]();return this}[RESUME](){if(this[DESTROYED])return;this[PAUSED]=false;this[FLOWING]=true;this.emit(\"resume\");if(this.buffer.length)this[FLUSH]();else if(this[EOF])this[MAYBE_EMIT_END]();else this.emit(\"drain\")}resume(){return this[RESUME]()}pause(){this[FLOWING]=false;this[PAUSED]=true}get destroyed(){return this[DESTROYED]}get flowing(){return this[FLOWING]}get paused(){return this[PAUSED]}[BUFFERPUSH](chunk){if(this[OBJECTMODE])this[BUFFERLENGTH]+=1;else this[BUFFERLENGTH]+=chunk.length;this.buffer.push(chunk)}[BUFFERSHIFT](){if(this.buffer.length){if(this[OBJECTMODE])this[BUFFERLENGTH]-=1;else this[BUFFERLENGTH]-=this.buffer[0].length}return this.buffer.shift()}[FLUSH](noDrain){do{}while(this[FLUSHCHUNK](this[BUFFERSHIFT]()));if(!noDrain&&!this.buffer.length&&!this[EOF])this.emit(\"drain\")}[FLUSHCHUNK](chunk){return chunk?(this.emit(\"data\",chunk),this.flowing):false}pipe(dest,opts){if(this[DESTROYED])return;const ended=this[EMITTED_END];opts=opts||{};if(dest===proc.stdout||dest===proc.stderr)opts.end=false;else opts.end=opts.end!==false;opts.proxyErrors=!!opts.proxyErrors;if(ended){if(opts.end)dest.end()}else{this.pipes.push(!opts.proxyErrors?new Pipe(this,dest,opts):new PipeProxyErrors(this,dest,opts));if(this[ASYNC])defer(()=>this[RESUME]());else this[RESUME]()}return dest}unpipe(dest){const p=this.pipes.find(p2=>p2.dest===dest);if(p){this.pipes.splice(this.pipes.indexOf(p),1);p.unpipe()}}addListener(ev,fn){return this.on(ev,fn)}on(ev,fn){const ret=super.on(ev,fn);if(ev===\"data\"&&!this.pipes.length&&!this.flowing)this[RESUME]();else if(ev===\"readable\"&&this[BUFFERLENGTH]!==0)super.emit(\"readable\");else if(isEndish(ev)&&this[EMITTED_END]){super.emit(ev);this.removeAllListeners(ev)}else if(ev===\"error\"&&this[EMITTED_ERROR]){if(this[ASYNC])defer(()=>fn.call(this,this[EMITTED_ERROR]));else fn.call(this,this[EMITTED_ERROR])}return ret}get emittedEnd(){return this[EMITTED_END]}[MAYBE_EMIT_END](){if(!this[EMITTING_END]&&!this[EMITTED_END]&&!this[DESTROYED]&&this.buffer.length===0&&this[EOF]){this[EMITTING_END]=true;this.emit(\"end\");this.emit(\"prefinish\");this.emit(\"finish\");if(this[CLOSED])this.emit(\"close\");this[EMITTING_END]=false}}emit(ev,data,...extra){if(ev!==\"error\"&&ev!==\"close\"&&ev!==DESTROYED&&this[DESTROYED])return;else if(ev===\"data\"){return!data?false:this[ASYNC]?defer(()=>this[EMITDATA](data)):this[EMITDATA](data)}else if(ev===\"end\"){return this[EMITEND]()}else if(ev===\"close\"){this[CLOSED]=true;if(!this[EMITTED_END]&&!this[DESTROYED])return;const ret2=super.emit(\"close\");this.removeAllListeners(\"close\");return ret2}else if(ev===\"error\"){this[EMITTED_ERROR]=data;const ret2=super.emit(\"error\",data);this[MAYBE_EMIT_END]();return ret2}else if(ev===\"resume\"){const ret2=super.emit(\"resume\");this[MAYBE_EMIT_END]();return ret2}else if(ev===\"finish\"||ev===\"prefinish\"){const ret2=super.emit(ev);this.removeAllListeners(ev);return ret2}const ret=super.emit(ev,data,...extra);this[MAYBE_EMIT_END]();return ret}[EMITDATA](data){for(const p of this.pipes){if(p.dest.write(data)===false)this.pause()}const ret=super.emit(\"data\",data);this[MAYBE_EMIT_END]();return ret}[EMITEND](){if(this[EMITTED_END])return;this[EMITTED_END]=true;this.readable=false;if(this[ASYNC])defer(()=>this[EMITEND2]());else this[EMITEND2]()}[EMITEND2](){if(this[DECODER]){const data=this[DECODER].end();if(data){for(const p of this.pipes){p.dest.write(data)}super.emit(\"data\",data)}}for(const p of this.pipes){p.end()}const ret=super.emit(\"end\");this.removeAllListeners(\"end\");return ret}collect(){const buf=[];if(!this[OBJECTMODE])buf.dataLength=0;const p=this.promise();this.on(\"data\",c=>{buf.push(c);if(!this[OBJECTMODE])buf.dataLength+=c.length});return p.then(()=>buf)}concat(){return this[OBJECTMODE]?Promise.reject(new Error(\"cannot concat in objectMode\")):this.collect().then(buf=>this[OBJECTMODE]?Promise.reject(new Error(\"cannot concat in objectMode\")):this[ENCODING]?buf.join(\"\"):Buffer.concat(buf,buf.dataLength))}promise(){return new Promise((resolve,reject)=>{this.on(DESTROYED,()=>reject(new Error(\"stream destroyed\")));this.on(\"error\",er=>reject(er));this.on(\"end\",()=>resolve())})}[ASYNCITERATOR](){const next=__name(()=>{const res=this.read();if(res!==null)return Promise.resolve({done:false,value:res});if(this[EOF])return Promise.resolve({done:true});let resolve=null;let reject=null;const onerr=__name(er=>{this.removeListener(\"data\",ondata);this.removeListener(\"end\",onend);reject(er)},\"onerr\");const ondata=__name(value=>{this.removeListener(\"error\",onerr);this.removeListener(\"end\",onend);this.pause();resolve({value,done:!!this[EOF]})},\"ondata\");const onend=__name(()=>{this.removeListener(\"error\",onerr);this.removeListener(\"data\",ondata);resolve({done:true})},\"onend\");const ondestroy=__name(()=>onerr(new Error(\"stream destroyed\")),\"ondestroy\");return new Promise((res2,rej)=>{reject=rej;resolve=res2;this.once(DESTROYED,ondestroy);this.once(\"error\",onerr);this.once(\"end\",onend);this.once(\"data\",ondata)})},\"next\");return{next}}[ITERATOR](){const next=__name(()=>{const value=this.read();const done=value===null;return{value,done}},\"next\");return{next}}destroy(er){if(this[DESTROYED]){if(er)this.emit(\"error\",er);else this.emit(DESTROYED);return this}this[DESTROYED]=true;this.buffer.length=0;this[BUFFERLENGTH]=0;if(typeof this.close===\"function\"&&!this[CLOSED])this.close();if(er)this.emit(\"error\",er);else this.emit(DESTROYED);return this}static isStream(s){return!!s&&(s instanceof Minipass||s instanceof Stream||s instanceof EE&&(typeof s.pipe===\"function\"||typeof s.write===\"function\"&&typeof s.end===\"function\"))}};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["p","ret","res"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/minipass@3.3.6/node_modules/minipass/index.js"],"sourcesContent":["'use strict'\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null,\n}\nconst EE = require('events')\nconst Stream = require('stream')\nconst SD = require('string_decoder').StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor (src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe () {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors () {}\n  end () {\n    this.unpipe()\n    if (this.opts.end)\n      this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe () {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor (src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nmodule.exports = class Minipass extends Stream {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = []\n    this.buffer = []\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[ASYNC] = options && !!options.async || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\n\n  get ['async'] () { return this[ASYNC] }\n  set ['async'] (a) { this[ASYNC] = this[ASYNC] || !!a }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0)\n        this[FLUSH](true)\n\n      if (this.flowing)\n        this.emit('data', chunk)\n      else\n        this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n\n      if (cb)\n        fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0)\n      this[FLUSH](true)\n\n    if (this.flowing)\n      this.emit('data', chunk)\n    else\n      this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0)\n      this.emit('readable')\n\n    if (cb)\n      fn(cb)\n\n    return this.flowing\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE])\n      n = null\n\n    if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding)\n        this.buffer = [this.buffer.join('')]\n      else\n        this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this.buffer[0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer[0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer[0].length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] (noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!noDrain && !this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end)\n        dest.end()\n    } else {\n      this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts)\n        : new PipeProxyErrors(this, dest, opts))\n      if (this[ASYNC])\n        defer(() => this[RESUME]())\n      else\n        this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe (dest) {\n    const p = this.pipes.find(p => p.dest === dest)\n    if (p) {\n      this.pipes.splice(this.pipes.indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this.pipes.length && !this.flowing)\n      this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC])\n        defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else\n        fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !data ? false\n        : this[ASYNC] ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      const ret = super.emit('error', data)\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA] (data) {\n    for (const p of this.pipes) {\n      if (p.dest.write(data) === false)\n        this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND] () {\n    if (this[EMITTED_END])\n      return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC])\n      defer(() => this[EMITEND2]())\n    else\n      this[EMITEND2]()\n  }\n\n  [EMITEND2] () {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this.pipes) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this.pipes) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    if (!this[OBJECTMODE])\n      buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer.length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\n      s instanceof EE && (\n        typeof s.pipe === 'function' || // readable\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\n      ))\n  }\n}\n"]}}