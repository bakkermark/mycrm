{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{inheritableAttrs,elemsGroups}=require(\"./_collections.js\");exports.name=\"collapseGroups\";exports.description=\"collapses useless groups\";const hasAnimatedAttr=__name((node,name)=>{if(node.type===\"element\"){if(elemsGroups.animation.includes(node.name)&&node.attributes.attributeName===name){return true}for(const child of node.children){if(hasAnimatedAttr(child,name)){return true}}}return false},\"hasAnimatedAttr\");exports.fn=()=>{return{element:{exit:(node,parentNode)=>{if(parentNode.type===\"root\"||parentNode.name===\"switch\"){return}if(node.name!==\"g\"||node.children.length===0){return}if(Object.keys(node.attributes).length!==0&&node.children.length===1){const firstChild=node.children[0];if(firstChild.type===\"element\"&&firstChild.attributes.id==null&&node.attributes.filter==null&&(node.attributes.class==null||firstChild.attributes.class==null)&&(node.attributes[\"clip-path\"]==null&&node.attributes.mask==null||firstChild.name===\"g\"&&node.attributes.transform==null&&firstChild.attributes.transform==null)){for(const[name,value]of Object.entries(node.attributes)){if(hasAnimatedAttr(firstChild,name)){return}if(firstChild.attributes[name]==null){firstChild.attributes[name]=value}else if(name===\"transform\"){firstChild.attributes[name]=value+\" \"+firstChild.attributes[name]}else if(firstChild.attributes[name]===\"inherit\"){firstChild.attributes[name]=value}else if(inheritableAttrs.includes(name)===false&&firstChild.attributes[name]!==value){return}delete node.attributes[name]}}}if(Object.keys(node.attributes).length===0){for(const child of node.children){if(child.type===\"element\"&&elemsGroups.animation.includes(child.name)){return}}const index=parentNode.children.indexOf(node);parentNode.children.splice(index,1,...node.children);for(const child of node.children){Object.defineProperty(child,\"parentNode\",{writable:true,value:parentNode})}}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAMA,KAAM,CAAE,iBAAkB,WAAY,EAAI,QAAQ,mBAAmB,EAErE,QAAQ,KAAO,iBACf,QAAQ,YAAc,2BAKtB,MAAM,gBAAkB,QAAC,KAAM,OAAS,CACtC,GAAI,KAAK,OAAS,UAAW,CAC3B,GACE,YAAY,UAAU,SAAS,KAAK,IAAI,GACxC,KAAK,WAAW,gBAAkB,KAClC,CACA,MAAO,KACT,CACA,UAAW,SAAS,KAAK,SAAU,CACjC,GAAI,gBAAgB,MAAO,IAAI,EAAG,CAChC,MAAO,KACT,CACF,CACF,CACA,MAAO,MACT,EAfwB,mBAuCxB,QAAQ,GAAK,IAAM,CACjB,MAAO,CACL,QAAS,CACP,KAAM,CAAC,KAAM,aAAe,CAC1B,GAAI,WAAW,OAAS,QAAU,WAAW,OAAS,SAAU,CAC9D,MACF,CAEA,GAAI,KAAK,OAAS,KAAO,KAAK,SAAS,SAAW,EAAG,CACnD,MACF,CAGA,GACE,OAAO,KAAK,KAAK,UAAU,EAAE,SAAW,GACxC,KAAK,SAAS,SAAW,EACzB,CACA,MAAM,WAAa,KAAK,SAAS,CAAC,EAElC,GACE,WAAW,OAAS,WACpB,WAAW,WAAW,IAAM,MAC5B,KAAK,WAAW,QAAU,OACzB,KAAK,WAAW,OAAS,MACxB,WAAW,WAAW,OAAS,QAC/B,KAAK,WAAW,WAAW,GAAK,MAChC,KAAK,WAAW,MAAQ,MACvB,WAAW,OAAS,KACnB,KAAK,WAAW,WAAa,MAC7B,WAAW,WAAW,WAAa,MACvC,CACA,SAAW,CAAC,KAAM,KAAK,IAAK,OAAO,QAAQ,KAAK,UAAU,EAAG,CAE3D,GAAI,gBAAgB,WAAY,IAAI,EAAG,CACrC,MACF,CACA,GAAI,WAAW,WAAW,IAAI,GAAK,KAAM,CACvC,WAAW,WAAW,IAAI,EAAI,KAChC,SAAW,OAAS,YAAa,CAC/B,WAAW,WAAW,IAAI,EACxB,MAAQ,IAAM,WAAW,WAAW,IAAI,CAC5C,SAAW,WAAW,WAAW,IAAI,IAAM,UAAW,CACpD,WAAW,WAAW,IAAI,EAAI,KAChC,SACE,iBAAiB,SAAS,IAAI,IAAM,OACpC,WAAW,WAAW,IAAI,IAAM,MAChC,CACA,MACF,CACA,OAAO,KAAK,WAAW,IAAI,CAC7B,CACF,CACF,CAGA,GAAI,OAAO,KAAK,KAAK,UAAU,EAAE,SAAW,EAAG,CAG7C,UAAW,SAAS,KAAK,SAAU,CACjC,GACE,MAAM,OAAS,WACf,YAAY,UAAU,SAAS,MAAM,IAAI,EACzC,CACA,MACF,CACF,CAEA,MAAM,MAAQ,WAAW,SAAS,QAAQ,IAAI,EAC9C,WAAW,SAAS,OAAO,MAAO,EAAG,GAAG,KAAK,QAAQ,EAErD,UAAW,SAAS,KAAK,SAAU,CACjC,OAAO,eAAe,MAAO,aAAc,CACzC,SAAU,KACV,MAAO,UACT,CAAC,CACH,CACF,CACF,CACF,CACF,CACF","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/collapseGroups.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastNode} XastNode\n */\n\nconst { inheritableAttrs, elemsGroups } = require('./_collections.js');\n\nexports.name = 'collapseGroups';\nexports.description = 'collapses useless groups';\n\n/**\n * @type {(node: XastNode, name: string) => boolean}\n */\nconst hasAnimatedAttr = (node, name) => {\n  if (node.type === 'element') {\n    if (\n      elemsGroups.animation.includes(node.name) &&\n      node.attributes.attributeName === name\n    ) {\n      return true;\n    }\n    for (const child of node.children) {\n      if (hasAnimatedAttr(child, name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Collapse useless groups.\n *\n * @example\n * <g>\n *     <g attr1=\"val1\">\n *         <path d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <g>\n *     <g>\n *         <path attr1=\"val1\" d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <path attr1=\"val1\" d=\"...\"/>\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'collapseGroups'>}\n */\nexports.fn = () => {\n  return {\n    element: {\n      exit: (node, parentNode) => {\n        if (parentNode.type === 'root' || parentNode.name === 'switch') {\n          return;\n        }\n        // non-empty groups\n        if (node.name !== 'g' || node.children.length === 0) {\n          return;\n        }\n\n        // move group attibutes to the single child element\n        if (\n          Object.keys(node.attributes).length !== 0 &&\n          node.children.length === 1\n        ) {\n          const firstChild = node.children[0];\n          // TODO untangle this mess\n          if (\n            firstChild.type === 'element' &&\n            firstChild.attributes.id == null &&\n            node.attributes.filter == null &&\n            (node.attributes.class == null ||\n              firstChild.attributes.class == null) &&\n            ((node.attributes['clip-path'] == null &&\n              node.attributes.mask == null) ||\n              (firstChild.name === 'g' &&\n                node.attributes.transform == null &&\n                firstChild.attributes.transform == null))\n          ) {\n            for (const [name, value] of Object.entries(node.attributes)) {\n              // avoid copying to not conflict with animated attribute\n              if (hasAnimatedAttr(firstChild, name)) {\n                return;\n              }\n              if (firstChild.attributes[name] == null) {\n                firstChild.attributes[name] = value;\n              } else if (name === 'transform') {\n                firstChild.attributes[name] =\n                  value + ' ' + firstChild.attributes[name];\n              } else if (firstChild.attributes[name] === 'inherit') {\n                firstChild.attributes[name] = value;\n              } else if (\n                inheritableAttrs.includes(name) === false &&\n                firstChild.attributes[name] !== value\n              ) {\n                return;\n              }\n              delete node.attributes[name];\n            }\n          }\n        }\n\n        // collapse groups without attributes\n        if (Object.keys(node.attributes).length === 0) {\n          // animation elements \"add\" attributes to group\n          // group should be preserved\n          for (const child of node.children) {\n            if (\n              child.type === 'element' &&\n              elemsGroups.animation.includes(child.name)\n            ) {\n              return;\n            }\n          }\n          // replace current node with all its children\n          const index = parentNode.children.indexOf(node);\n          parentNode.children.splice(index, 1, ...node.children);\n          // TODO remove legacy parentNode in v4\n          for (const child of node.children) {\n            Object.defineProperty(child, 'parentNode', {\n              writable: true,\n              value: parentNode,\n            });\n          }\n        }\n      },\n    },\n  };\n};\n"]}}