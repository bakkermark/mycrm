{"code":"(()=>{\n\"use strict\";exports.name=\"cleanupAttrs\";exports.description=\"cleanups attributes from newlines, trailing and repeating spaces\";const regNewlinesNeedSpace=/(\\S)\\r?\\n(\\S)/g;const regNewlines=/\\r?\\n/g;const regSpaces=/\\s{2,}/g;exports.fn=(root,params)=>{const{newlines=true,trim=true,spaces=true}=params;return{element:{enter:node=>{for(const name of Object.keys(node.attributes)){if(newlines){node.attributes[name]=node.attributes[name].replace(regNewlinesNeedSpace,(match,p1,p2)=>p1+\" \"+p2);node.attributes[name]=node.attributes[name].replace(regNewlines,\"\")}if(trim){node.attributes[name]=node.attributes[name].trim()}if(spaces){node.attributes[name]=node.attributes[name].replace(regSpaces,\" \")}}}}}};\n})()\n","warnings":[],"map":{"version":3,"mappings":";aAEA,QAAQ,KAAO,eACf,QAAQ,YACN,mEAEF,MAAM,qBAAuB,iBAC7B,MAAM,YAAc,SACpB,MAAM,UAAY,UASlB,QAAQ,GAAK,CAAC,KAAM,SAAW,CAC7B,KAAM,CAAE,SAAW,KAAM,KAAO,KAAM,OAAS,IAAK,EAAI,OACxD,MAAO,CACL,QAAS,CACP,MAAQ,MAAS,CACf,UAAW,QAAQ,OAAO,KAAK,KAAK,UAAU,EAAG,CAC/C,GAAI,SAAU,CAEZ,KAAK,WAAW,IAAI,EAAI,KAAK,WAAW,IAAI,EAAE,QAC5C,qBACA,CAAC,MAAO,GAAI,KAAO,GAAK,IAAM,EAChC,EAEA,KAAK,WAAW,IAAI,EAAI,KAAK,WAAW,IAAI,EAAE,QAC5C,YACA,EACF,CACF,CACA,GAAI,KAAM,CACR,KAAK,WAAW,IAAI,EAAI,KAAK,WAAW,IAAI,EAAE,KAAK,CACrD,CACA,GAAI,OAAQ,CACV,KAAK,WAAW,IAAI,EAAI,KAAK,WAAW,IAAI,EAAE,QAC5C,UACA,GACF,CACF,CACF,CACF,CACF,CACF,CACF","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/svgo@3.0.3/node_modules/svgo/plugins/cleanupAttrs.js"],"sourcesContent":["'use strict';\n\nexports.name = 'cleanupAttrs';\nexports.description =\n  'cleanups attributes from newlines, trailing and repeating spaces';\n\nconst regNewlinesNeedSpace = /(\\S)\\r?\\n(\\S)/g;\nconst regNewlines = /\\r?\\n/g;\nconst regSpaces = /\\s{2,}/g;\n\n/**\n * Cleanup attributes values from newlines, trailing and repeating spaces.\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'cleanupAttrs'>}\n */\nexports.fn = (root, params) => {\n  const { newlines = true, trim = true, spaces = true } = params;\n  return {\n    element: {\n      enter: (node) => {\n        for (const name of Object.keys(node.attributes)) {\n          if (newlines) {\n            // new line which requires a space instead of themselve\n            node.attributes[name] = node.attributes[name].replace(\n              regNewlinesNeedSpace,\n              (match, p1, p2) => p1 + ' ' + p2\n            );\n            // simple new line\n            node.attributes[name] = node.attributes[name].replace(\n              regNewlines,\n              ''\n            );\n          }\n          if (trim) {\n            node.attributes[name] = node.attributes[name].trim();\n          }\n          if (spaces) {\n            node.attributes[name] = node.attributes[name].replace(\n              regSpaces,\n              ' '\n            );\n          }\n        }\n      },\n    },\n  };\n};\n"]}}