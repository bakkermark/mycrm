{"code":"(()=>{\n\"use strict\";var __create=Object.create;var __defProp=Object.defineProperty;var __getOwnPropDesc=Object.getOwnPropertyDescriptor;var __getOwnPropNames=Object.getOwnPropertyNames;var __getProtoOf=Object.getPrototypeOf;var __hasOwnProp=Object.prototype.hasOwnProperty;var __name=(target2,value)=>__defProp(target2,\"name\",{value,configurable:true});var __copyProps=(to,from,except,desc)=>{if(from&&typeof from===\"object\"||typeof from===\"function\"){for(let key of __getOwnPropNames(from))if(!__hasOwnProp.call(to,key)&&key!==except)__defProp(to,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable})}return to};var __toESM=(mod,isNodeMode,target2)=>(target2=mod!=null?__create(__getProtoOf(mod)):{},__copyProps(isNodeMode||!mod||!mod.__esModule?__defProp(target2,\"default\",{value:mod,enumerable:true}):target2,mod));var import_node_fs=require(\"node:fs\");var import_node_path=require(\"node:path\");var import_tools=require(\"@iconify/tools\");var import_utils=require(\"@iconify/utils\");const sources={svg:[{dir:\"src/assets/images/iconify-svg\",monotone:false,prefix:\"custom\"}],icons:[],json:[require.resolve(\"@iconify-json/tabler/icons.json\"),{filename:require.resolve(\"@iconify-json/fa/icons.json\"),icons:[\"facebook\",\"google\",\"twitter\",\"circle\"]}]};const target=(0,import_node_path.join)(__dirname,\"icons.css\");(async function(){const dir=(0,import_node_path.dirname)(target);try{await import_node_fs.promises.mkdir(dir,{recursive:true})}catch(err){}const allIcons=[];if(sources.icons){const sourcesJSON=sources.json?sources.json:sources.json=[];const organizedList=organizeIconsList(sources.icons);for(const prefix in organizedList){const filename=require.resolve(`@iconify/json/json/${prefix}.json`);sourcesJSON.push({filename,icons:organizedList[prefix]})}}if(sources.json){for(let i=0;i<sources.json.length;i++){const item=sources.json[i];const filename=typeof item===\"string\"?item:item.filename;const content=JSON.parse(await import_node_fs.promises.readFile(filename,\"utf8\"));for(const key in content){if(key===\"prefix\"&&content.prefix===\"tabler\"){for(const k in content.icons)content.icons[k].body=content.icons[k].body.replace(/stroke-width=\"2\"/g,'stroke-width=\"1.5\"')}}if(typeof item!==\"string\"&&item.icons?.length){const filteredContent=(0,import_utils.getIcons)(content,item.icons);if(!filteredContent)throw new Error(`Cannot find required icons in ${filename}`);allIcons.push(filteredContent)}else{allIcons.push(content)}}}if(sources.svg){for(let i=0;i<sources.svg.length;i++){const source=sources.svg[i];const iconSet=await(0,import_tools.importDirectory)(source.dir,{prefix:source.prefix});await iconSet.forEach(async(name,type)=>{if(type!==\"icon\")return;const svg=iconSet.toSVG(name);if(!svg){iconSet.remove(name);return}try{await(0,import_tools.cleanupSVG)(svg);if(source.monotone){await(0,import_tools.parseColors)(svg,{defaultColor:\"currentColor\",callback:(attr,colorStr,color)=>{return!color||(0,import_tools.isEmptyColor)(color)?colorStr:\"currentColor\"}})}await(0,import_tools.runSVGO)(svg)}catch(err){console.error(`Error parsing ${name} from ${source.dir}:`,err);iconSet.remove(name);return}iconSet.fromSVG(name,svg)});allIcons.push(iconSet.export())}}const cssContent=allIcons.map(iconSet=>(0,import_utils.getIconsCSS)(iconSet,Object.keys(iconSet.icons),{iconSelector:\".{prefix}-{name}\",mode:\"mask\"})).join(\"\\n\");await import_node_fs.promises.writeFile(target,cssContent,\"utf8\");console.log(`Saved CSS to ${target}!`)})().catch(err=>{console.error(err)});function organizeIconsList(icons){const sorted=Object.create(null);icons.forEach(icon=>{const item=(0,import_utils.stringToIcon)(icon);if(!item)return;const prefix=item.prefix;const prefixList=sorted[prefix]?sorted[prefix]:sorted[prefix]=[];const name=item.name;if(!prefixList.includes(name))prefixList.push(name)});return sorted}__name(organizeIconsList,\"organizeIconsList\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["fs"],"sources":["/Users/markbakker/RiderProjects/mycrm/src/plugins/iconify/build-icons.ts"],"sourcesContent":["/**\n * This is an advanced example for creating icon bundles for Iconify SVG Framework.\n *\n * It creates a bundle from:\n * - All SVG files in a directory.\n * - Custom JSON files.\n * - Iconify icon sets.\n * - SVG framework.\n *\n * This example uses Iconify Tools to import and clean up icons.\n * For Iconify Tools documentation visit https://docs.iconify.design/tools/tools2/\n */\nimport { promises as fs } from 'node:fs'\nimport { dirname, join } from 'node:path'\n\n// Installation: npm install --save-dev @iconify/tools @iconify/utils @iconify/json @iconify/iconify\nimport { cleanupSVG, importDirectory, isEmptyColor, parseColors, runSVGO } from '@iconify/tools'\nimport type { IconifyJSON } from '@iconify/types'\nimport { getIcons, getIconsCSS, stringToIcon } from '@iconify/utils'\n\n/**\n * Script configuration\n */\ninterface BundleScriptCustomSVGConfig {\n\n  // Path to SVG files\n  dir: string\n\n  // True if icons should be treated as monotone: colors replaced with currentColor\n  monotone: boolean\n\n  // Icon set prefix\n  prefix: string\n}\n\ninterface BundleScriptCustomJSONConfig {\n\n  // Path to JSON file\n  filename: string\n\n  // List of icons to import. If missing, all icons will be imported\n  icons?: string[]\n}\n\ninterface BundleScriptConfig {\n\n  // Custom SVG to import and bundle\n  svg?: BundleScriptCustomSVGConfig[]\n\n  // Icons to bundled from @iconify/json packages\n  icons?: string[]\n\n  // List of JSON files to bundled\n  // Entry can be a string, pointing to filename or a BundleScriptCustomJSONConfig object (see type above)\n  // If entry is a string or object without 'icons' property, an entire JSON file will be bundled\n  json?: (string | BundleScriptCustomJSONConfig)[]\n}\n\nconst sources: BundleScriptConfig = {\n  svg: [\n    {\n      dir: 'src/assets/images/iconify-svg',\n      monotone: false,\n      prefix: 'custom',\n    },\n\n    // {\n    //   dir: 'emojis',\n    //   monotone: false,\n    //   prefix: 'emoji',\n    // },\n  ],\n\n  icons: [\n    // 'mdi:home',\n    // 'mdi:account',\n    // 'mdi:login',\n    // 'mdi:logout',\n    // 'octicon:book-24',\n    // 'octicon:code-square-24',\n  ],\n\n  json: [\n    // Custom JSON file\n    // 'json/gg.json',\n\n    // Iconify JSON file (@iconify/json is a package name, /json/ is directory where files are, then filename)\n    require.resolve('@iconify-json/tabler/icons.json'),\n    {\n      filename: require.resolve('@iconify-json/fa/icons.json'),\n      icons: [\n        'facebook',\n        'google',\n        'twitter',\n        'circle',\n      ],\n    },\n\n    // Custom file with only few icons\n    // {\n    //   filename: require.resolve('@iconify-json/line-md/icons.json'),\n    //   icons: [\n    //     'home-twotone-alt',\n    //     'github',\n    //     'document-list',\n    //     'document-code',\n    //     'image-twotone',\n    //   ],\n    // },\n  ],\n}\n\n// File to save bundle to\nconst target = join(__dirname, 'icons.css')\n\n/**\n * Do stuff!\n */\n\n;(async function () {\n  // Create directory for output if missing\n  const dir = dirname(target)\n  try {\n    await fs.mkdir(dir, {\n      recursive: true,\n    })\n  }\n  catch (err) {\n    //\n  }\n\n  const allIcons: IconifyJSON[] = []\n\n  /**\n   * Convert sources.icons to sources.json\n   */\n  if (sources.icons) {\n    const sourcesJSON = sources.json ? sources.json : (sources.json = [])\n\n    // Sort icons by prefix\n    const organizedList = organizeIconsList(sources.icons)\n\n    for (const prefix in organizedList) {\n      const filename = require.resolve(`@iconify/json/json/${prefix}.json`)\n\n      sourcesJSON.push({\n        filename,\n        icons: organizedList[prefix],\n      })\n    }\n  }\n\n  /**\n   * Bundle JSON files and collect icons\n   */\n  if (sources.json) {\n    for (let i = 0; i < sources.json.length; i++) {\n      const item = sources.json[i]\n\n      // Load icon set\n      const filename = typeof item === 'string' ? item : item.filename\n      const content = JSON.parse(await fs.readFile(filename, 'utf8')) as IconifyJSON\n\n      for (const key in content) {\n        if (key === 'prefix' && content.prefix === 'tabler') {\n          for (const k in content.icons)\n            content.icons[k].body = content.icons[k].body.replace(/stroke-width=\"2\"/g, 'stroke-width=\"1.5\"')\n        }\n      }\n\n      // Filter icons\n      if (typeof item !== 'string' && item.icons?.length) {\n        const filteredContent = getIcons(content, item.icons)\n\n        if (!filteredContent)\n          throw new Error(`Cannot find required icons in ${filename}`)\n\n        // Collect filtered icons\n        allIcons.push(filteredContent)\n      }\n      else {\n        // Collect all icons from the JSON file\n        allIcons.push(content)\n      }\n    }\n  }\n\n  /**\n   * Bundle custom SVG icons and collect icons\n   */\n  if (sources.svg) {\n    for (let i = 0; i < sources.svg.length; i++) {\n      const source = sources.svg[i]\n\n      // Import icons\n      const iconSet = await importDirectory(source.dir, {\n        prefix: source.prefix,\n      })\n\n      // Validate, clean up, fix palette, etc.\n      await iconSet.forEach(async (name, type) => {\n        if (type !== 'icon')\n          return\n\n        // Get SVG instance for parsing\n        const svg = iconSet.toSVG(name)\n\n        if (!svg) {\n          // Invalid icon\n          iconSet.remove(name)\n\n          return\n        }\n\n        // Clean up and optimise icons\n        try {\n          // Clean up icon code\n          await cleanupSVG(svg)\n\n          if (source.monotone) {\n            // Replace color with currentColor, add if missing\n            // If icon is not monotone, remove this code\n            await parseColors(svg, {\n              defaultColor: 'currentColor',\n              callback: (attr, colorStr, color) => {\n                return !color || isEmptyColor(color) ? colorStr : 'currentColor'\n              },\n            })\n          }\n\n          // Optimise\n          await runSVGO(svg)\n        }\n        catch (err) {\n          // Invalid icon\n          console.error(`Error parsing ${name} from ${source.dir}:`, err)\n          iconSet.remove(name)\n\n          return\n        }\n\n        // Update icon from SVG instance\n        iconSet.fromSVG(name, svg)\n      })\n\n      // Collect the SVG icon\n      allIcons.push(iconSet.export())\n    }\n  }\n\n  // Generate CSS from collected icons\n  const cssContent = allIcons\n    .map(iconSet => getIconsCSS(\n      iconSet,\n      Object.keys(iconSet.icons),\n      {\n        iconSelector: '.{prefix}-{name}',\n        mode: 'mask',\n      },\n    ))\n    .join('\\n')\n\n  // Save the CSS to a file\n  await fs.writeFile(target, cssContent, 'utf8')\n\n  console.log(`Saved CSS to ${target}!`)\n})().catch(err => {\n  console.error(err)\n})\n\n/**\n * Sort icon names by prefix\n */\nfunction organizeIconsList(icons: string[]): Record<string, string[]> {\n  const sorted: Record<string, string[]> = Object.create(null)\n\n  icons.forEach(icon => {\n    const item = stringToIcon(icon)\n\n    if (!item)\n      return\n\n    const prefix = item.prefix\n    const prefixList = sorted[prefix] ? sorted[prefix] : (sorted[prefix] = [])\n\n    const name = item.name\n\n    if (!prefixList.includes(name))\n      prefixList.push(name)\n  })\n\n  return sorted\n}\n"]}}