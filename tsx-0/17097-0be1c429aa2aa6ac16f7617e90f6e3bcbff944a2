{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const hlo=require(\"./high-level-opt.js\");const Unpack=require(\"./unpack.js\");const fs=require(\"fs\");const fsm=require(\"fs-minipass\");const path=require(\"path\");const stripSlash=require(\"./strip-trailing-slashes.js\");module.exports=(opt_,files,cb)=>{if(typeof opt_===\"function\"){cb=opt_,files=null,opt_={}}else if(Array.isArray(opt_)){files=opt_,opt_={}}if(typeof files===\"function\"){cb=files,files=null}if(!files){files=[]}else{files=Array.from(files)}const opt=hlo(opt_);if(opt.sync&&typeof cb===\"function\"){throw new TypeError(\"callback not supported for sync tar functions\")}if(!opt.file&&typeof cb===\"function\"){throw new TypeError(\"callback only supported with file option\")}if(files.length){filesFilter(opt,files)}return opt.file&&opt.sync?extractFileSync(opt):opt.file?extractFile(opt,cb):opt.sync?extractSync(opt):extract(opt)};const filesFilter=__name((opt,files)=>{const map=new Map(files.map(f=>[stripSlash(f),true]));const filter=opt.filter;const mapHas=__name((file,r)=>{const root=r||path.parse(file).root||\".\";const ret=file===root?false:map.has(file)?map.get(file):mapHas(path.dirname(file),root);map.set(file,ret);return ret},\"mapHas\");opt.filter=filter?(file,entry)=>filter(file,entry)&&mapHas(stripSlash(file)):file=>mapHas(stripSlash(file))},\"filesFilter\");const extractFileSync=__name(opt=>{const u=new Unpack.Sync(opt);const file=opt.file;const stat=fs.statSync(file);const readSize=opt.maxReadSize||16*1024*1024;const stream=new fsm.ReadStreamSync(file,{readSize,size:stat.size});stream.pipe(u)},\"extractFileSync\");const extractFile=__name((opt,cb)=>{const u=new Unpack(opt);const readSize=opt.maxReadSize||16*1024*1024;const file=opt.file;const p=new Promise((resolve,reject)=>{u.on(\"error\",reject);u.on(\"close\",resolve);fs.stat(file,(er,stat)=>{if(er){reject(er)}else{const stream=new fsm.ReadStream(file,{readSize,size:stat.size});stream.on(\"error\",reject);stream.pipe(u)}})});return cb?p.then(cb,cb):p},\"extractFile\");const extractSync=__name(opt=>new Unpack.Sync(opt),\"extractSync\");const extract=__name(opt=>new Unpack(opt),\"extract\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/extract.js"],"sourcesContent":["'use strict'\n\n// tar -x\nconst hlo = require('./high-level-opt.js')\nconst Unpack = require('./unpack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {}\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null\n  }\n\n  if (!files) {\n    files = []\n  } else {\n    files = Array.from(files)\n  }\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  if (files.length) {\n    filesFilter(opt, files)\n  }\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size,\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => new Unpack.Sync(opt)\n\nconst extract = opt => new Unpack(opt)\n"]}}