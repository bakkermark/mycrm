{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const mkdirp=require(\"mkdirp\");const fs=require(\"fs\");const path=require(\"path\");const chownr=require(\"chownr\");const normPath=require(\"./normalize-windows-path.js\");class SymlinkError extends Error{static{__name(this,\"SymlinkError\")}constructor(symlink,path2){super(\"Cannot extract through symbolic link\");this.path=path2;this.symlink=symlink}get name(){return\"SylinkError\"}}class CwdError extends Error{static{__name(this,\"CwdError\")}constructor(path2,code){super(code+\": Cannot cd into '\"+path2+\"'\");this.path=path2;this.code=code}get name(){return\"CwdError\"}}const cGet=__name((cache,key)=>cache.get(normPath(key)),\"cGet\");const cSet=__name((cache,key,val)=>cache.set(normPath(key),val),\"cSet\");const checkCwd=__name((dir,cb)=>{fs.stat(dir,(er,st)=>{if(er||!st.isDirectory()){er=new CwdError(dir,er&&er.code||\"ENOTDIR\")}cb(er)})},\"checkCwd\");module.exports=(dir,opt,cb)=>{dir=normPath(dir);const umask=opt.umask;const mode=opt.mode|448;const needChmod=(mode&umask)!==0;const uid=opt.uid;const gid=opt.gid;const doChown=typeof uid===\"number\"&&typeof gid===\"number\"&&(uid!==opt.processUid||gid!==opt.processGid);const preserve=opt.preserve;const unlink=opt.unlink;const cache=opt.cache;const cwd=normPath(opt.cwd);const done=__name((er,created)=>{if(er){cb(er)}else{cSet(cache,dir,true);if(created&&doChown){chownr(created,uid,gid,er2=>done(er2))}else if(needChmod){fs.chmod(dir,mode,cb)}else{cb()}}},\"done\");if(cache&&cGet(cache,dir)===true){return done()}if(dir===cwd){return checkCwd(dir,done)}if(preserve){return mkdirp(dir,{mode}).then(made=>done(null,made),done)}const sub=normPath(path.relative(cwd,dir));const parts=sub.split(\"/\");mkdir_(cwd,parts,mode,cache,unlink,cwd,null,done)};const mkdir_=__name((base,parts,mode,cache,unlink,cwd,created,cb)=>{if(!parts.length){return cb(null,created)}const p=parts.shift();const part=normPath(path.resolve(base+\"/\"+p));if(cGet(cache,part)){return mkdir_(part,parts,mode,cache,unlink,cwd,created,cb)}fs.mkdir(part,mode,onmkdir(part,parts,mode,cache,unlink,cwd,created,cb))},\"mkdir_\");const onmkdir=__name((part,parts,mode,cache,unlink,cwd,created,cb)=>er=>{if(er){fs.lstat(part,(statEr,st)=>{if(statEr){statEr.path=statEr.path&&normPath(statEr.path);cb(statEr)}else if(st.isDirectory()){mkdir_(part,parts,mode,cache,unlink,cwd,created,cb)}else if(unlink){fs.unlink(part,er2=>{if(er2){return cb(er2)}fs.mkdir(part,mode,onmkdir(part,parts,mode,cache,unlink,cwd,created,cb))})}else if(st.isSymbolicLink()){return cb(new SymlinkError(part,part+\"/\"+parts.join(\"/\")))}else{cb(er)}})}else{created=created||part;mkdir_(part,parts,mode,cache,unlink,cwd,created,cb)}},\"onmkdir\");const checkCwdSync=__name(dir=>{let ok=false;let code=\"ENOTDIR\";try{ok=fs.statSync(dir).isDirectory()}catch(er){code=er.code}finally{if(!ok){throw new CwdError(dir,code)}}},\"checkCwdSync\");module.exports.sync=(dir,opt)=>{dir=normPath(dir);const umask=opt.umask;const mode=opt.mode|448;const needChmod=(mode&umask)!==0;const uid=opt.uid;const gid=opt.gid;const doChown=typeof uid===\"number\"&&typeof gid===\"number\"&&(uid!==opt.processUid||gid!==opt.processGid);const preserve=opt.preserve;const unlink=opt.unlink;const cache=opt.cache;const cwd=normPath(opt.cwd);const done=__name(created2=>{cSet(cache,dir,true);if(created2&&doChown){chownr.sync(created2,uid,gid)}if(needChmod){fs.chmodSync(dir,mode)}},\"done\");if(cache&&cGet(cache,dir)===true){return done()}if(dir===cwd){checkCwdSync(cwd);return done()}if(preserve){return done(mkdirp.sync(dir,mode))}const sub=normPath(path.relative(cwd,dir));const parts=sub.split(\"/\");let created=null;for(let p=parts.shift(),part=cwd;p&&(part+=\"/\"+p);p=parts.shift()){part=normPath(path.resolve(part));if(cGet(cache,part)){continue}try{fs.mkdirSync(part,mode);created=created||part;cSet(cache,part,true)}catch(er){const st=fs.lstatSync(part);if(st.isDirectory()){cSet(cache,part,true);continue}else if(unlink){fs.unlinkSync(part);fs.mkdirSync(part,mode);created=created||part;cSet(cache,part,true);continue}else if(st.isSymbolicLink()){return new SymlinkError(part,part+\"/\"+parts.join(\"/\"))}}}return done(created)};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["path","er","created"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/tar@6.2.0/node_modules/tar/lib/mkdir.js"],"sourcesContent":["'use strict'\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp')\nconst fs = require('fs')\nconst path = require('path')\nconst chownr = require('chownr')\nconst normPath = require('./normalize-windows-path.js')\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst cGet = (cache, key) => cache.get(normPath(key))\nconst cSet = (cache, key, val) => cache.set(normPath(key), val)\n\nconst checkCwd = (dir, cb) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory()) {\n      er = new CwdError(dir, er && er.code || 'ENOTDIR')\n    }\n    cb(er)\n  })\n}\n\nmodule.exports = (dir, opt, cb) => {\n  dir = normPath(dir)\n\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (er, created) => {\n    if (er) {\n      cb(er)\n    } else {\n      cSet(cache, dir, true)\n      if (created && doChown) {\n        chownr(created, uid, gid, er => done(er))\n      } else if (needChmod) {\n        fs.chmod(dir, mode, cb)\n      } else {\n        cb()\n      }\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true) {\n    return done()\n  }\n\n  if (dir === cwd) {\n    return checkCwd(dir, done)\n  }\n\n  if (preserve) {\n    return mkdirp(dir, { mode }).then(made => done(null, made), done)\n  }\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length) {\n    return cb(null, created)\n  }\n  const p = parts.shift()\n  const part = normPath(path.resolve(base + '/' + p))\n  if (cGet(cache, part)) {\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) {\n        statEr.path = statEr.path && normPath(statEr.path)\n        cb(statEr)\n      } else if (st.isDirectory()) {\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      } else if (unlink) {\n        fs.unlink(part, er => {\n          if (er) {\n            return cb(er)\n          }\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      } else if (st.isSymbolicLink()) {\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      } else {\n        cb(er)\n      }\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst checkCwdSync = dir => {\n  let ok = false\n  let code = 'ENOTDIR'\n  try {\n    ok = fs.statSync(dir).isDirectory()\n  } catch (er) {\n    code = er.code\n  } finally {\n    if (!ok) {\n      throw new CwdError(dir, code)\n    }\n  }\n}\n\nmodule.exports.sync = (dir, opt) => {\n  dir = normPath(dir)\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (created) => {\n    cSet(cache, dir, true)\n    if (created && doChown) {\n      chownr.sync(created, uid, gid)\n    }\n    if (needChmod) {\n      fs.chmodSync(dir, mode)\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true) {\n    return done()\n  }\n\n  if (dir === cwd) {\n    checkCwdSync(cwd)\n    return done()\n  }\n\n  if (preserve) {\n    return done(mkdirp.sync(dir, mode))\n  }\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()) {\n    part = normPath(path.resolve(part))\n    if (cGet(cache, part)) {\n      continue\n    }\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cSet(cache, part, true)\n    } catch (er) {\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cSet(cache, part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cSet(cache, part, true)\n        continue\n      } else if (st.isSymbolicLink()) {\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n      }\n    }\n  }\n\n  return done(created)\n}\n"]}}