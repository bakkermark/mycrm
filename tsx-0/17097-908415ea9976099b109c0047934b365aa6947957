{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});var fs=require(\"fs\");var util=require(\"util\");var stream=require(\"stream\");var Readable=stream.Readable;var Writable=stream.Writable;var PassThrough=stream.PassThrough;var Pend=require(\"pend\");var EventEmitter=require(\"events\").EventEmitter;exports.createFromBuffer=createFromBuffer;exports.createFromFd=createFromFd;exports.BufferSlicer=BufferSlicer;exports.FdSlicer=FdSlicer;util.inherits(FdSlicer,EventEmitter);function FdSlicer(fd,options){options=options||{};EventEmitter.call(this);this.fd=fd;this.pend=new Pend;this.pend.max=1;this.refCount=0;this.autoClose=!!options.autoClose}__name(FdSlicer,\"FdSlicer\");FdSlicer.prototype.read=function(buffer,offset,length,position,callback){var self=this;self.pend.go(function(cb){fs.read(self.fd,buffer,offset,length,position,function(err,bytesRead,buffer2){cb();callback(err,bytesRead,buffer2)})})};FdSlicer.prototype.write=function(buffer,offset,length,position,callback){var self=this;self.pend.go(function(cb){fs.write(self.fd,buffer,offset,length,position,function(err,written,buffer2){cb();callback(err,written,buffer2)})})};FdSlicer.prototype.createReadStream=function(options){return new ReadStream(this,options)};FdSlicer.prototype.createWriteStream=function(options){return new WriteStream(this,options)};FdSlicer.prototype.ref=function(){this.refCount+=1};FdSlicer.prototype.unref=function(){var self=this;self.refCount-=1;if(self.refCount>0)return;if(self.refCount<0)throw new Error(\"invalid unref\");if(self.autoClose){fs.close(self.fd,onCloseDone)}function onCloseDone(err){if(err){self.emit(\"error\",err)}else{self.emit(\"close\")}}__name(onCloseDone,\"onCloseDone\")};util.inherits(ReadStream,Readable);function ReadStream(context,options){options=options||{};Readable.call(this,options);this.context=context;this.context.ref();this.start=options.start||0;this.endOffset=options.end;this.pos=this.start;this.destroyed=false}__name(ReadStream,\"ReadStream\");ReadStream.prototype._read=function(n){var self=this;if(self.destroyed)return;var toRead=Math.min(self._readableState.highWaterMark,n);if(self.endOffset!=null){toRead=Math.min(toRead,self.endOffset-self.pos)}if(toRead<=0){self.destroyed=true;self.push(null);self.context.unref();return}self.context.pend.go(function(cb){if(self.destroyed)return cb();var buffer=new Buffer(toRead);fs.read(self.context.fd,buffer,0,toRead,self.pos,function(err,bytesRead){if(err){self.destroy(err)}else if(bytesRead===0){self.destroyed=true;self.push(null);self.context.unref()}else{self.pos+=bytesRead;self.push(buffer.slice(0,bytesRead))}cb()})})};ReadStream.prototype.destroy=function(err){if(this.destroyed)return;err=err||new Error(\"stream destroyed\");this.destroyed=true;this.emit(\"error\",err);this.context.unref()};util.inherits(WriteStream,Writable);function WriteStream(context,options){options=options||{};Writable.call(this,options);this.context=context;this.context.ref();this.start=options.start||0;this.endOffset=options.end==null?Infinity:+options.end;this.bytesWritten=0;this.pos=this.start;this.destroyed=false;this.on(\"finish\",this.destroy.bind(this))}__name(WriteStream,\"WriteStream\");WriteStream.prototype._write=function(buffer,encoding,callback){var self=this;if(self.destroyed)return;if(self.pos+buffer.length>self.endOffset){var err=new Error(\"maximum file length exceeded\");err.code=\"ETOOBIG\";self.destroy();callback(err);return}self.context.pend.go(function(cb){if(self.destroyed)return cb();fs.write(self.context.fd,buffer,0,buffer.length,self.pos,function(err2,bytes){if(err2){self.destroy();cb();callback(err2)}else{self.bytesWritten+=bytes;self.pos+=bytes;self.emit(\"progress\");cb();callback()}})})};WriteStream.prototype.destroy=function(){if(this.destroyed)return;this.destroyed=true;this.context.unref()};util.inherits(BufferSlicer,EventEmitter);function BufferSlicer(buffer,options){EventEmitter.call(this);options=options||{};this.refCount=0;this.buffer=buffer;this.maxChunkSize=options.maxChunkSize||Number.MAX_SAFE_INTEGER}__name(BufferSlicer,\"BufferSlicer\");BufferSlicer.prototype.read=function(buffer,offset,length,position,callback){var end=position+length;var delta=end-this.buffer.length;var written=delta>0?delta:length;this.buffer.copy(buffer,offset,position,end);setImmediate(function(){callback(null,written)})};BufferSlicer.prototype.write=function(buffer,offset,length,position,callback){buffer.copy(this.buffer,position,offset,offset+length);setImmediate(function(){callback(null,length,buffer)})};BufferSlicer.prototype.createReadStream=function(options){options=options||{};var readStream=new PassThrough(options);readStream.destroyed=false;readStream.start=options.start||0;readStream.endOffset=options.end;readStream.pos=readStream.endOffset||this.buffer.length;var entireSlice=this.buffer.slice(readStream.start,readStream.pos);var offset=0;while(true){var nextOffset=offset+this.maxChunkSize;if(nextOffset>=entireSlice.length){if(offset<entireSlice.length){readStream.write(entireSlice.slice(offset,entireSlice.length))}break}readStream.write(entireSlice.slice(offset,nextOffset));offset=nextOffset}readStream.end();readStream.destroy=function(){readStream.destroyed=true};return readStream};BufferSlicer.prototype.createWriteStream=function(options){var bufferSlicer=this;options=options||{};var writeStream=new Writable(options);writeStream.start=options.start||0;writeStream.endOffset=options.end==null?this.buffer.length:+options.end;writeStream.bytesWritten=0;writeStream.pos=writeStream.start;writeStream.destroyed=false;writeStream._write=function(buffer,encoding,callback){if(writeStream.destroyed)return;var end=writeStream.pos+buffer.length;if(end>writeStream.endOffset){var err=new Error(\"maximum file length exceeded\");err.code=\"ETOOBIG\";writeStream.destroyed=true;callback(err);return}buffer.copy(bufferSlicer.buffer,writeStream.pos,0,buffer.length);writeStream.bytesWritten+=buffer.length;writeStream.pos=end;writeStream.emit(\"progress\");callback()};writeStream.destroy=function(){writeStream.destroyed=true};return writeStream};BufferSlicer.prototype.ref=function(){this.refCount+=1};BufferSlicer.prototype.unref=function(){this.refCount-=1;if(this.refCount<0){throw new Error(\"invalid unref\")}};function createFromBuffer(buffer,options){return new BufferSlicer(buffer,options)}__name(createFromBuffer,\"createFromBuffer\");function createFromFd(fd,options){return new FdSlicer(fd,options)}__name(createFromFd,\"createFromFd\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["buffer","err"],"sources":["/Users/markbakker/RiderProjects/mycrm/node_modules/.pnpm/fd-slicer@1.1.0/node_modules/fd-slicer/index.js"],"sourcesContent":["var fs = require('fs');\nvar util = require('util');\nvar stream = require('stream');\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar PassThrough = stream.PassThrough;\nvar Pend = require('pend');\nvar EventEmitter = require('events').EventEmitter;\n\nexports.createFromBuffer = createFromBuffer;\nexports.createFromFd = createFromFd;\nexports.BufferSlicer = BufferSlicer;\nexports.FdSlicer = FdSlicer;\n\nutil.inherits(FdSlicer, EventEmitter);\nfunction FdSlicer(fd, options) {\n  options = options || {};\n  EventEmitter.call(this);\n\n  this.fd = fd;\n  this.pend = new Pend();\n  this.pend.max = 1;\n  this.refCount = 0;\n  this.autoClose = !!options.autoClose;\n}\n\nFdSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {\n      cb();\n      callback(err, bytesRead, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {\n      cb();\n      callback(err, written, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.createReadStream = function(options) {\n  return new ReadStream(this, options);\n};\n\nFdSlicer.prototype.createWriteStream = function(options) {\n  return new WriteStream(this, options);\n};\n\nFdSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nFdSlicer.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  if (self.autoClose) {\n    fs.close(self.fd, onCloseDone);\n  }\n\n  function onCloseDone(err) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      self.emit('close');\n    }\n  }\n};\n\nutil.inherits(ReadStream, Readable);\nfunction ReadStream(context, options) {\n  options = options || {};\n  Readable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = options.end;\n  this.pos = this.start;\n  this.destroyed = false;\n}\n\nReadStream.prototype._read = function(n) {\n  var self = this;\n  if (self.destroyed) return;\n\n  var toRead = Math.min(self._readableState.highWaterMark, n);\n  if (self.endOffset != null) {\n    toRead = Math.min(toRead, self.endOffset - self.pos);\n  }\n  if (toRead <= 0) {\n    self.destroyed = true;\n    self.push(null);\n    self.context.unref();\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    var buffer = new Buffer(toRead);\n    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {\n      if (err) {\n        self.destroy(err);\n      } else if (bytesRead === 0) {\n        self.destroyed = true;\n        self.push(null);\n        self.context.unref();\n      } else {\n        self.pos += bytesRead;\n        self.push(buffer.slice(0, bytesRead));\n      }\n      cb();\n    });\n  });\n};\n\nReadStream.prototype.destroy = function(err) {\n  if (this.destroyed) return;\n  err = err || new Error(\"stream destroyed\");\n  this.destroyed = true;\n  this.emit('error', err);\n  this.context.unref();\n};\n\nutil.inherits(WriteStream, Writable);\nfunction WriteStream(context, options) {\n  options = options || {};\n  Writable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = (options.end == null) ? Infinity : +options.end;\n  this.bytesWritten = 0;\n  this.pos = this.start;\n  this.destroyed = false;\n\n  this.on('finish', this.destroy.bind(this));\n}\n\nWriteStream.prototype._write = function(buffer, encoding, callback) {\n  var self = this;\n  if (self.destroyed) return;\n\n  if (self.pos + buffer.length > self.endOffset) {\n    var err = new Error(\"maximum file length exceeded\");\n    err.code = 'ETOOBIG';\n    self.destroy();\n    callback(err);\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {\n      if (err) {\n        self.destroy();\n        cb();\n        callback(err);\n      } else {\n        self.bytesWritten += bytes;\n        self.pos += bytes;\n        self.emit('progress');\n        cb();\n        callback();\n      }\n    });\n  });\n};\n\nWriteStream.prototype.destroy = function() {\n  if (this.destroyed) return;\n  this.destroyed = true;\n  this.context.unref();\n};\n\nutil.inherits(BufferSlicer, EventEmitter);\nfunction BufferSlicer(buffer, options) {\n  EventEmitter.call(this);\n\n  options = options || {};\n  this.refCount = 0;\n  this.buffer = buffer;\n  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;\n}\n\nBufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var end = position + length;\n  var delta = end - this.buffer.length;\n  var written = (delta > 0) ? delta : length;\n  this.buffer.copy(buffer, offset, position, end);\n  setImmediate(function() {\n    callback(null, written);\n  });\n};\n\nBufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  buffer.copy(this.buffer, position, offset, offset + length);\n  setImmediate(function() {\n    callback(null, length, buffer);\n  });\n};\n\nBufferSlicer.prototype.createReadStream = function(options) {\n  options = options || {};\n  var readStream = new PassThrough(options);\n  readStream.destroyed = false;\n  readStream.start = options.start || 0;\n  readStream.endOffset = options.end;\n  // by the time this function returns, we'll be done.\n  readStream.pos = readStream.endOffset || this.buffer.length;\n\n  // respect the maxChunkSize option to slice up the chunk into smaller pieces.\n  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);\n  var offset = 0;\n  while (true) {\n    var nextOffset = offset + this.maxChunkSize;\n    if (nextOffset >= entireSlice.length) {\n      // last chunk\n      if (offset < entireSlice.length) {\n        readStream.write(entireSlice.slice(offset, entireSlice.length));\n      }\n      break;\n    }\n    readStream.write(entireSlice.slice(offset, nextOffset));\n    offset = nextOffset;\n  }\n\n  readStream.end();\n  readStream.destroy = function() {\n    readStream.destroyed = true;\n  };\n  return readStream;\n};\n\nBufferSlicer.prototype.createWriteStream = function(options) {\n  var bufferSlicer = this;\n  options = options || {};\n  var writeStream = new Writable(options);\n  writeStream.start = options.start || 0;\n  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;\n  writeStream.bytesWritten = 0;\n  writeStream.pos = writeStream.start;\n  writeStream.destroyed = false;\n  writeStream._write = function(buffer, encoding, callback) {\n    if (writeStream.destroyed) return;\n\n    var end = writeStream.pos + buffer.length;\n    if (end > writeStream.endOffset) {\n      var err = new Error(\"maximum file length exceeded\");\n      err.code = 'ETOOBIG';\n      writeStream.destroyed = true;\n      callback(err);\n      return;\n    }\n    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);\n\n    writeStream.bytesWritten += buffer.length;\n    writeStream.pos = end;\n    writeStream.emit('progress');\n    callback();\n  };\n  writeStream.destroy = function() {\n    writeStream.destroyed = true;\n  };\n  return writeStream;\n};\n\nBufferSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nBufferSlicer.prototype.unref = function() {\n  this.refCount -= 1;\n\n  if (this.refCount < 0) {\n    throw new Error(\"invalid unref\");\n  }\n};\n\nfunction createFromBuffer(buffer, options) {\n  return new BufferSlicer(buffer, options);\n}\n\nfunction createFromFd(fd, options) {\n  return new FdSlicer(fd, options);\n}\n"]}}